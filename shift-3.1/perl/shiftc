#!/usr/bin/perl
#
# Copyright (C) 2012-2014 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration
# (NASA).  All Rights Reserved.
#
# This software is distributed under the NASA Open Source Agreement
# (NOSA), version 1.3.  The NOSA has been approved by the Open Source
# Initiative.  See http://www.opensource.org/licenses/nasa1.3.php
# for the complete NOSA document.
#
# THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY OF ANY
# KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT
# LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM TO
# SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
# A PARTICULAR PURPOSE, OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT
# THE SUBJECT SOFTWARE WILL BE ERROR FREE, OR ANY WARRANTY THAT
# DOCUMENTATION, IF PROVIDED, WILL CONFORM TO THE SUBJECT SOFTWARE. THIS
# AGREEMENT DOES NOT, IN ANY MANNER, CONSTITUTE AN ENDORSEMENT BY
# GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT OF ANY RESULTS, RESULTING
# DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER APPLICATIONS RESULTING
# FROM USE OF THE SUBJECT SOFTWARE.  FURTHER, GOVERNMENT AGENCY DISCLAIMS
# ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY SOFTWARE, IF
# PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT "AS IS".
#
# RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS AGAINST THE UNITED STATES
# GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY PRIOR
# RECIPIENT.  IF RECIPIENT'S USE OF THE SUBJECT SOFTWARE RESULTS IN ANY
# LIABILITIES, DEMANDS, DAMAGES, EXPENSES OR LOSSES ARISING FROM SUCH USE,
# INCLUDING ANY DAMAGES FROM PRODUCTS BASED ON, OR RESULTING FROM,
# RECIPIENT'S USE OF THE SUBJECT SOFTWARE, RECIPIENT SHALL INDEMNIFY AND
# HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
# SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT, TO THE EXTENT PERMITTED
# BY LAW.  RECIPIENT'S SOLE REMEDY FOR ANY SUCH MATTER SHALL BE THE
# IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
#

# This program is the Mesh Client and provides a simplified user
# interface for invoking remote Mesh commands.  This program is also
# the Shift client for automated file transfers, which can be used with
# or without Mesh.  To use Shift with Mesh, comment out all "=for mesh"
# and "=cut mesh" lines.  The name of this program must start with
# "shift" when used without Mesh and must not start with "shift" when
# used with Mesh.

require 5.006_001;
use strict;
use Cwd qw(abs_path);
use Data::Dumper;
use Digest::MD5 qw(md5);
use Fcntl qw(:flock :mode);
use File::Basename;
use File::Copy;
use File::Find;
use File::Glob qw(:glob);
use File::Path;
use File::Spec;
use File::Spec::Unix;
use File::Temp qw(tempdir tempfile);
use Getopt::Long qw(:config bundling no_ignore_case require_order);
use IO::File;
use IO::Socket::UNIX;
use IPC::Open2;
use IPC::Open3;
use POSIX;
use Socket;
use Sys::Hostname;
use Text::ParseWords;

use constant SFTP_APPEND => 0x04;
use constant SFTP_CREAT => 0x08;
use constant SFTP_READ => 0x01;
use constant SFTP_TRUNC => 0x10;
use constant SFTP_WRITE => 0x02;
use constant SFTP_EXCL => 0x20;

our $VERSION = 0.821;

$Data::Dumper::Indent = 0;
$Data::Dumper::Purity = 1;

#########################
#### default options ####
#########################
my %opts = (
    abs0 => abs_path($0),
    argv => [$0, @ARGV],
    base0 => basename($0),
    caux => "shift-aux",
    cmgr => "shift-mgr",
    p => "none",
    mgr => "none",
    tmp_d => File::Spec->tmpdir,
);

###############################
#### site-specific options ####
###############################

=for mesh

$opts{a} = "MAPHOST";
$opts{af} = "MAPPRINT";
$opts{d} = 7;
$opts{i} = glob("~/.ssh/id_rsa");
$opts{p} = "MPHOST";
$opts{pf} = "MPPRINT";


#######################
#### parse options ####
#######################
exit 1 if (!GetOptions(\%opts,
    "a=s", "b", "d=i", "f", "g", "h", "i=s", "k", "keygen-user=s",
    "m=s", "n", "N", "p=s", "r=s", "s=s", "t=s", "u=s", "v",
    "o=s" => sub {
        my ($key, $val) = split(/=|\s+/, $_[1], 2);
        $val = shift @ARGV if (!defined $val);
        $opts{$_[0] . lc($key)} = " $val";
    }
));
# spawn new agent in batch mode or if shift transfer
$opts{n} = 1 if ($opts{b} || $ARGV[0] =~ /^shiftc?$/);
# kill agent on exit when new agent forced
$opts{k} = 1 if ($opts{n});
if ($opts{'keygen-user'}) {
    # format for inclusion on mesh-keygen command line
    $opts{'keygen-user'} = "--user=" . $opts{'keygen-user'};
    # adjust expiration time for keygen users
    $opts{d} = 60;
}
$opts{ssh_l} = "-l $opts{u}" if ($opts{u});
# skip login messages when not in verbose mode
$opts{ssh_q} = '-q' if (!$opts{v});
# set remote shift transport to client transport
$opts{remote} = $opts{t} if ($opts{t});

################################
#### define aliases for vfs ####
################################
if ($opts{r} || $opts{s}) {
    foreach (qw(a d i m p t u)) {
        $opts{abs0} .= " -$_ '$opts{$_}'" if ($opts{$_});
    }
    my @ng_cmds = qw(cat cd chgrp chmod chown cmp cp df diff du file ln ls mkdir
        mv pwd rm rmdir test touch);
    my @cmds = qw(grep head less more tail tee wc);
    #TODO: find, more/less without whole file
    #TODO: can't use noglob alias with piped input (set -f destroys input)
    #TODO: support csh
    if ($opts{r} eq 'bash') {
        #TODO: could do redirection by getting orig cmd, rewriting < to
        # cat, rewriting > to tee, then rexec'ing (only if history 1 works)
        print qq|unset -f mc_cd ; |;
        print qq|unset -f mc_ng ; |;
        print qq|unalias $_ ; | foreach (@cmds, @ng_cmds);
        print q|export COMP_WORDBREAKS=${COMP_WORDBREAKS}: ; |;
        print qq|complete -r $_ ; | foreach (@cmds, @ng_cmds);
        # terminate vfs socket process
        system("$opts{abs0} -b -N -p none exit");
    } elsif ($opts{s} eq 'bash') {
        # need perl 5.8.5 as glob is broken in earlier versions
        require 5.008_005;
        print qq|mc_cd () { eval `$opts{abs0} cd "\$@"`; RC=\$?; set +f; return \$RC ; } ; |;
        print qq|mc_ng () { $opts{abs0} "\$@"; RC=\$?; set +f; return \$RC ; } ; |;
        # aliases where glob can be safely disabled with set -f
        print qq|alias $_='set -f; mc_ng $_$opts{"o$_"}' ; | foreach (@ng_cmds);
        # aliases where glob cannot be disabled as set -f destroys stdin
        print qq|alias $_='$opts{abs0} $_$opts{"o$_"}' ; | foreach (@cmds);
        print qq|alias cd='set -f; mc_cd' ; |;
        # need to remove : to allow completion of scp-style paths to work
        print q|export COMP_WORDBREAKS=${COMP_WORDBREAKS/\:/} ; |;
        print qq|complete -o default -o filenames -o nospace -C '$opts{abs0} complete' $_ ; |
            foreach (@cmds, @ng_cmds);
    }
    exit;
}

###################
#### show help ####
###################
$opts{h} = 1 if (scalar(@ARGV) == 0 && !$opts{g});
if ($opts{h}) {
    print "Usage: $opts{base0} [OPTION]... COMMAND\n";
    print "\n";
    print "Execute COMMAND as if proxied hosts were directly connected.\n";
    print "\n";
    print "Options (defaults in brackets):\n";
    print "    -a MAP       set Mesh Authentication Point to MAP [$opts{a}]\n";
    print "    -b           batch mode (disable key renewal, implies -k)\n";
    print "    -d DAYS      keys are valid for DAYS days [$opts{d}]\n";
    print "    -g           force generation of new key\n";
    print "    -h           help\n";
    print "    -i IDENTITY  set long term identity file to IDENTITY [$opts{i}]\n";
    print "    -k           kill spawned agent (no effect if agent preexists)\n";
    print "    -n           force spawning of new agent\n";
    print "    -oCMD OPTS   set alias options for CMD to OPTS\n";
    print "    -p MP        set Mesh Proxy to MP [$opts{p}]\n";
    print "    -r SHELL     remove aliases for SHELL shell\n";
    print "    -s SHELL     set aliases for SHELL shell\n";
    print "    -t TRANSPORT set transport mechanism to TRANSPORT [sftp]\n";
    print "    -u USER      set remote user to USER [" . getpwuid($<) . "]\n";
    print "    -v           verbose mode\n";
    exit;
}
print STDERR "Using version $VERSION\n" if ($opts{v});

###############################
#### execute local command ####
###############################
if (scalar(@ARGV) > 0) {
    # ignore command if key generation forced and no arguments given
    my $cmd = shift @ARGV;
    if ($cmd !~ /(?:^|\W)(?:bbcp|bbftp|bbscp|globus-url-copy|mesh-keykill|mesh-keytime|pcp\+|rm|rsync|scp|sftp|shiftc?|ssh|ssh-balance)$/ && $< != 0) {
        # resolve all symlinks to support links to host:/path in VFS
        #   (exclude rm so linked targets are not removed)
        #   (exclude root to prevent unintended exposure/modification)
        @ARGV = map {File::Spec::Link->resolve_all($_)} @ARGV;
    }
    my $argv_hostpath = 0;
    $argv_hostpath ||= hostpath($_) foreach (@ARGV);
    if ($cmd =~ /(?:^|\W)pwd$/) {
        print "$ENV{PWD}\n";
        exit;
    } elsif ($cmd !~ /(?:^|\W)(?:bbcp|bbftp|bbscp|globus-url-copy|mesh-keykill|mesh-keytime|pcp\+|rsync|scp|sftp|ssh|ssh-balance)$/ &&
            !$argv_hostpath && (!hostpath($ENV{PWD}) ||
            grep(!/^[-\/]/, @ARGV) == 0 || $cmd =~ /(?:^|\W)complete$/ &&
            $ARGV[1] =~ /^\//)) {
        if ($cmd =~ /^(?:exit|shiftc?)$/) {
            # do nothing for now
        } elsif ($cmd =~ /(?:^|\W)(?:ls|du)$/ && hostpath($ENV{PWD}) &&
                grep(/^\//, @ARGV) == 0) {
            # add implicit current directory to remote ls/du
            push(@ARGV, $ENV{PWD});
        } else {
            exit if ($cmd =~ /(?:^|\W)complete$/);
            unshift(@ARGV, $cmd);
            unshift(@ARGV, qw(echo builtin)) if ($cmd =~ /(?:^|\W)cd$/);
            @ARGV = map {glob($_)} @ARGV;
            exit WEXITSTATUS(system(@ARGV));
        }
    } elsif ($cmd =~ /(?:^|\W)complete$/) {
        @ARGV = ($ARGV[1]);
    }
    # add previously shifted command back into argument list
    unshift(@ARGV, $cmd);
}

=cut mesh

###################################
#### find agent base directory ####
###################################
my $agent_sock = qx(ssh-agent -c);
my $agent_base;
if ($agent_sock =~ /SSH_AUTH_SOCK\s+([^;]+);/) {
    $agent_base = dirname(dirname($1));
} else {
    $agent_base = "/tmp";
}
if ($agent_sock =~ /SSH_AGENT_PID\s+(\d+);/) {
    kill(SIGTERM, $1) && waitpid($1, 0);
}
print STDERR "Agent base directory is $agent_base\n" if ($opts{v});
$agent_sock = undef;

####################
#### find agent ####
####################
if (!$opts{n}) {
    my @agents = glob("$agent_base/ssh-*/agent.*");
    push(@agents, glob("/tmp/ssh-*/agent.*")) if ($agent_base ne "/tmp");
    unshift(@agents, $ENV{SSH_AUTH_SOCK});
    foreach my $agent (@agents) {
        my @stat = stat $agent;
        next if ($stat[4] != $< || ! -S $agent);
        print STDERR "Checking validity of agent socket $agent\n" if ($opts{v});
        $ENV{SSH_AUTH_SOCK} = $agent;
        my $out = qx(ssh-add -l 2>&1);
        next if ($out =~ /open a connection|authentication socket/);
        $agent_sock = $agent;
        last;
    }
}

=for mesh

#####################
#### start agent ####
#####################
if (!$opts{N} && !defined $agent_sock) {
    print STDERR "Starting agent\n" if ($opts{v});
    $agent_sock = qx(ssh-agent -c);
    if ($opts{k} && $agent_sock =~ /SSH_AGENT_PID\s+(\d+);/) {
        $opts{k} = $1;
        print STDERR "Agent pid is $opts{k}\n" if ($opts{v});
    }
    if ($agent_sock =~ /SSH_AUTH_SOCK\s+([^;]+);/) {
        $agent_sock = $1;
    } else {
        die "Unable to start agent\n";
    }
}
print STDERR "Agent socket is $agent_sock\n" if ($opts{v});
$ENV{SSH_AUTH_SOCK} = $agent_sock;

##################
#### find key ####
##################
my $agent_key;
if (!$opts{N} && !$opts{g}) {
    # ignore agent keys if key generation forced
    my $agent_keys = qx(ssh-add -l);
    while ($agent_keys =~ /.ssh\/meshkey\.(\d+)/g) {
        if ($1 > time - 60) {
            $agent_key = $1;
            last;
        }
    }
}

#################
#### add key ####
#################
if (!$opts{N} && !$agent_key && !$opts{g}) {
    # ignore existing keys if key generation forced
    my @keys = glob("~/.ssh/meshkey.[0-9]*");
    foreach my $key (@keys) {
        if ($key =~ /\.(\d+)$/) {
            my $time = $1 - time;
            if ($time < 0) {
                print STDERR "Removing expired key $key\n" if ($opts{v});
                unlink $key;
                unlink "$key.pub";
                next;
            }
            print STDERR "Checking validity of key $key\n" if ($opts{v});
            my $out = qx(ssh-keygen -l -f $key.pub);
            if ($out =~ /not a public key file/) {
                print STDERR "Removing invalid key $key\n" if ($opts{v});
                unlink $key;
                unlink "$key.pub";
                next;
            }
            $agent_key = $key;
            print STDERR "Adding key $agent_key to agent\n" if ($opts{v});
            qx(ssh-add -t $time $agent_key 2>&1);
            die "Unable to add key to agent\n" if ($?);
            last;
        }
    }
}

######################
#### generate key ####
######################
if ($opts{p} ne 'none' && (!$agent_key || $opts{g})) {
    die "Key generation required but batch mode enabled\n" if ($opts{b});
    print STDERR "Testing initialization of host keys\n" if ($opts{v});
    for my $h (qw(a p)) {
        my $hf = $h . "f";
        my $out = qx(ssh -ax -oBatchMode=yes $opts{ssh_l} $opts{$h} bad-cmd 2>&1);
        if ($out =~ /verification\s+failed/) {
            print STDERR "No host key found for $opts{$h}\n";
            print STDERR "...continue if fingerprint is $opts{$hf}\n";
            qx(ssh -aqx -oStrictHostKeyChecking=ask -oPreferredAuthentications=none $opts{ssh_l} $opts{$h} bad-cmd 2>&1);
        }
    }

    print STDERR "Testing initialization of agent identities\n" if ($opts{v});
    my $out = qx(ssh -ax -i /dev/null -oBatchMode=yes $opts{ssh_l} $opts{a} bad-cmd 2>&1);
    if ($out =~ /verification\s+failed/) {
        die "Host key verification failed for $opts{a}\n"
    } elsif ($out =~ /denied/ && $out =~ /publickey/) {
        if (! -r $opts{i}) {
            print STDERR "Cannot find identity $opts{i}\n";
            print STDERR "...do you wish to generate it? (y/n)  ";
            my $line = <STDIN>;
            $line =~ s/\s*\r?\n$//;
            if ($line eq 'y') {
                print STDERR "Generating identity $opts{i}\n" if ($opts{v});
                system("ssh-keygen -t rsa -f $opts{i}");
                die "Unable to generate identity $opts{i}\n" if ($?);
                chmod(0600, $opts{i});
            } else {
                die "Unable to continue without identity $opts{i}\n";
            }
        }
        print STDERR "Adding identity $opts{i} to agent\n";
        system("ssh-add $opts{i}");
        die "Unable to add identity to agent\n" if ($?);
        print STDERR "Testing initialization of identity $opts{i}\n" if ($opts{v});
        $out = qx(ssh -ax -i /dev/null -oBatchMode=yes $opts{ssh_l} $opts{a} bad-cmd 2>&1);
        if ($out =~ /denied/ && $out =~ /publickey/) {
            print STDERR "Checking validity of public key $opts{i}.pub\n" if ($opts{v});
            $out = qx(ssh-keygen -l -f $opts{i}.pub) if (-r "$opts{i}.pub");
            if ($out =~ /not a public key file/ || ! -r "$opts{i}.pub") {
                print STDERR "Generating public key $opts{i}.pub from identity $opts{i}\n";
                system("ssh-keygen -y -f $opts{i} >$opts{i}.pub");
                if ($?) {
                    unlink "$opts{i}.pub";
                    die "Unable to generate public key $opts{i}.pub\n" 
                }
            }
            print STDERR "Initializing identity on $opts{a} (provide login information)\n";
            system("ssh $opts{ssh_q} -x -oPubkeyAuthentication=no $opts{ssh_l} $opts{a} mesh-keygen --init-add <$opts{i}.pub");
            die "Unable to initialize identity\n" if ($?);
        }
    } elsif ($out =~ /denied/ && $out =~ /command/) {
        # identity already loaded
    } else {
        die "Unknown output encountered: '$out'\n"
    }
    if (! -d glob("~/.ssh")) {
        print STDERR "Creating ~/.ssh\n" if ($opts{v});
        mkdir glob("~/.ssh");
        chmod(0700, glob("~/.ssh"));
    }
    my $time = time + $opts{d} * 24 * 60 * 60;
    $agent_key = glob("~/.ssh/meshkey.$time");
    $time -= time;
    print STDERR "Generating key on $opts{p} (provide login information)\n";
    system("ssh $opts{ssh_q} -Ax -oPubkeyAuthentication=no $opts{ssh_l} $opts{p} mesh-keygen " . $opts{'keygen-user'} . " >$agent_key");
    if ($? || -z $agent_key) {
        unlink $agent_key;
        die "Unable to generate key\n";
    }
    chmod(0600, $agent_key);
    print STDERR "Generating public key $agent_key.pub from private key $agent_key\n" if ($opts{v});
    system("ssh-keygen -y -f $agent_key >$agent_key.pub");
    print STDERR "Adding key $agent_key to agent\n" if ($opts{v});
    system("ssh-add -t $time $agent_key");
    die "Unable to add key to agent\n" if ($?);

    #######################
    #### update client ####
    #######################
    if (!$opts{"keygen-user"}) {
        # do not update client when key generated for different user
        my $mcv = qx(ssh -Aqx -oBatchMode=yes $opts{ssh_l} $opts{p} mesh-update --file=mc --version);
        $mcv =~ s/\s*\r?\n$//;
        print STDERR "Latest client version is $mcv\n" if ($opts{v});
        if ($mcv > $VERSION) {
            print STDERR "A newer version of the client is available ($mcv vs. $VERSION)\n";
            print STDERR "...do you wish to replace the current version? (y/n)  ";
            my $line = <STDIN>;
            $line =~ s/\s*\r?\n$//;
            if ($line eq 'y') {
                system("ssh -Aqx -oBatchMode=yes $opts{ssh_l} $opts{p} mesh-update --file=mc >$opts{abs0}");
                # reexec with original arguments to take advantage of fixes
                exec @{$opts{argv}} if (!$opts{g});
            }
        }
    }

    # ignore command if key generation forced and no arguments given
    exit if ($opts{g} && scalar(@ARGV) == 0);
}

=cut mesh

##########################
#### clean up on exit ####
##########################
END {exit_clean()};
use sigtrap qw(handler exit_clean normal-signals);

########################
#### modify command ####
########################
# openssh-specific optimizations
if (qx(ssh -V 2>&1) =~ /openssh/i) {
    # choose more efficient ciphers if available
    if (qx(ssh -c arcfour128,blowfish-cbc,aes128-cbc 2>&1) !~
            /unknown cipher|bad ssh2/i) {
        $opts{ssh_o} .= " -c arcfour128,blowfish-cbc,aes128-cbc";
    }
    # choose more efficient macs if available
    if (qx(ssh -m umac-64\@openssh.com,hmac-md5,hmac-sha1 2>&1) !~
            /unknown mac|bad ssh2/i) {
        $opts{ssh_o} .= ' -m umac-64@openssh.com,hmac-md5,hmac-sha1';
    }
}

# make sure to keep the space at the end
$opts{sshmp} = "ssh $opts{ssh_q} -Ax $opts{ssh_o} -oBatchMode=yes $opts{ssh_l} $opts{p} "
    if ($opts{p} ne 'none');
# re-add options for when there is no proxy
$opts{ssh} = "$opts{sshmp}ssh $opts{ssh_q} -ax $opts{ssh_o} -oBatchMode=yes $opts{ssh_l}";

=for mesh

print STDERR "Old command is '" . join("' '", @ARGV) . "'\n" if ($opts{v});
my $argc = scalar(@ARGV);
if ($ARGV[0] =~ /(?:^|\W)(?:scp|sftp)$/) {
    my ($fh, $wrap) = tempfile(UNLINK => 1);
    print $fh "#!/bin/sh\nexec $opts{ssh} \$@";
    close $fh;
    chmod(0700, $wrap);
    splice(@ARGV, 1, 0, ("-S", $wrap));
} elsif ($ARGV[0] =~ /(?:^|\W)bbcp$/) {
    splice(@ARGV, 1, 0, ("-S", "$opts{ssh} %H bbcp", "-T", "$opts{ssh} %H bbcp"));
} elsif ($ARGV[0] =~ /(?:^|\W)(?:bbftp|bbscp)$/) {
    splice(@ARGV, 1, 0, ("-L", $opts{ssh}));
} elsif ($ARGV[0] =~ /(?:^|\W)globus-url-copy$/) {
    my $dir = glob("~/.globus");
    mkdir $dir if (! -d $dir);
    my $file = "$dir/gridftp-ssh";
    open(FILE, '>', $file);
    print FILE "#!/bin/sh\n$opts{ssh} \$2 sshftp";
    close FILE;
    chmod(0700, $file);
    # reduce $argc since no additional args are spliced onto @ARGV
    $argc--;
} elsif ($ARGV[0] =~ /(?:^|\W)pcp\+$/) {
    splice(@ARGV, 1, 0, ("-s", "$opts{ssh_l} $opts{p}"));
} elsif ($ARGV[0] =~ /(?:^|\W)rsync$/) {
    splice(@ARGV, 1, 0, ("-e", $opts{ssh}));
} elsif ($ARGV[0] =~ /(?:^|\W)ssh$/) {
    splice(@ARGV, 0, 1, split(/\s+/, $opts{ssh}));
} elsif ($ARGV[0] =~ /(?:^|\W)(?:mesh-keykill|mesh-keytime|ssh-balance)$/) {
    splice(@ARGV, 0, 0, split(/\s+/, $opts{sshmp}));
}
print STDERR "New command is '" . join("' '", @ARGV) . "'\n" if ($opts{v});

=cut mesh

if ($opts{base0} =~ /^shift/ || $ARGV[0] =~ /^shiftc?$/) {
    # need perl 5.8.5 as glob is broken in earlier versions
    require 5.008_005;
    shift_();
    exit;
}

=for mesh

################################
#### execute remote command ####
################################
if (scalar(@ARGV) > $argc) {
    # use system instead of exec so can clean up afterwards
    my $rc = WEXITSTATUS(system(@ARGV));
    exit $rc;
}

###################
#### find sftp ####
###################
my @sftps = glob("$opts{tmp_d}/mesh-*/sftp.*");
my $sftp_time = -1;
my $sftp_sock;
foreach my $sftp (@sftps) {
    my @stat = stat $sftp;
    next if ($stat[4] != $< || ! -S $sftp || $stat[9] < $sftp_time);
    print STDERR "Checking validity of sftp socket $sftp\n" if ($opts{v});
    my $sftpd = IO::Socket::UNIX->new(
        Peer => $sftp,
        Proto => 'tcp',
    );
    next if (!$sftpd);
    $sftp_sock = $sftp;
    $sftp_time = $stat[9];
}

############################
#### start sftp for vfs ####
############################
if (!defined $sftp_sock) {
    $opts{sftp_d} = tempdir("mesh-XXXXXXXX", DIR => $opts{tmp_d});
    $sftp_sock = "$opts{sftp_d}/sftp.$$";
    mkdir "$opts{sftp_d}/empty";
    sftp_require($opts{sftp_d}) if (!eval "require Net::SFTP::Foreign");

    my $server = IO::Socket::UNIX->new(
        Listen => 10,
        Local => $sftp_sock,
        Proto => 'tcp',
    );

    if (fork) {
        close $server;
        # prevent cleanup
        $opts{sftp_d} = undef;
        $opts{k} = undef;
    } else {
        close STDIN;
        close STDOUT;
        close STDERR;
        setsid;
        open(STDIN, "</dev/null");
        open(STDOUT, ">/dev/null");
        open(STDERR, ">/dev/null");

        while (my $client = $server->accept) {
            $_ = <$client>;
            if (!$_) {
                close $client;
                next;
            }
            my $pwd;
            eval;
            my %copts;
            for (my $i = 1; $i < scalar(@ARGV); $i++) {
                if ($ARGV[$i] =~ /^--(\w+)$/) {
                    $copts{$1} = 1;
                } elsif ($ARGV[$i] =~ /^--(\w+)=(.*)$/) {
                    $copts{$1} = $2;
                } elsif ($ARGV[$i] =~ /^-(\d+)$/) {
                    $copts{$1} = 1;
                } elsif ($ARGV[$i] =~ /^-(\w+)$/) {
                    $copts{$_} = 1 foreach (split(//, $1));
                } elsif (!defined $copts{-arg1} && $ARGV[0] =~
                        /(?:^|\W)(?:chgrp|chown|chmod|grep)$/) {
                    # first non-option argument
                    $copts{-arg1} = $ARGV[$i];
                } else {
                    my ($host, $path) = hostpath($ARGV[$i]);
                    if ($host eq 'localhost')  {
                        # rewrite arg for /localhost/path case
                        $ARGV[$i] = $path;
                        if ($path !~ /^\//) {
                            # relative path
                            ($host, $path) = hostpath($pwd);
                            $path .= "/" . $ARGV[$i] if ($host ne 'localhost');
                        }
                    }
                    if ($host ne 'localhost') {
                        $path = File::Spec::Unix->canonpath($path);
                        1 while ($path =~ s/(?:^|\/?(?:[^\/]*\/))\.\.//);
                        $path = "/" if (!$path);
                        # original argument
                        $copts{-arg} = splice(@ARGV, $i--, 1);
                        if ($path =~ /[*?[]/ &&
                                $ARGV[0] !~ /(?:^|\W)(?:ls|complete)$/) {
                            my @glob = sftp($host)->glob($path, names_only => 1);
                            next if (scalar(@glob) == 0);
                            $path = shift @glob;
                            @glob = map {hostpath($host, $_)} @glob;
                            splice(@ARGV, $i + 1, 0, @glob);
                        }
                        push(@{$copts{-argv}}, hostpath($host, $path));
                        if ($ARGV[0] =~ /(?:^|\W)(cd|chgrp|chmod|chown|complete|df|du|head|ls|mkdir|rm|rmdir|tail|test|touch)$/) {
#TODO: this should probably be done differently (i.e. should rename
#      all paths, then execute subs on all args at once)
                            $copts{-argsleft} = scalar(@ARGV) - $i - 1;
                            my $sub = \&{"v$1"};
                            &{$sub}($client, $host, $path, \%copts);
                            last if ($1 eq 'cd');
                        } elsif ($ARGV[0] !~ /(?:^|\W)(?:cp|ln|mv|tee)$/) {
                            #### commands that use tmp files for remote files ####
                            my $tmp = sftp_tmp() . "-" . basename($path);
                            if ($ARGV[0] =~ /(?:^|\W)file$/) {
                                #### commands that use first n bytes of files ####
                                open(FILE, '>', $tmp);
                                my $fh = sftp($host)->open($path);
                                print FILE sftp($host)->read($fh, 4096);
                                close $fh;
                                close FILE;
                            } else {
                                #### commands that use entire files ####
                                if ($tmp ne $copts{-arg}) {
                                    my $ref = {};
                                    transport('get', $host, $path, $tmp, $ref);
                                    transport('end', $host);
                                    #TODO: do something with error
                                }
                            }
                            splice(@ARGV, ++$i, 0, $tmp);
                            $copts{-argc}++;
                        }
                    } else {
                        $copts{-argc}++;
                        push(@{$copts{-argv}}, glob($ARGV[$i]));
                    }
                }
            }

            if ($ARGV[0] =~ /(?:^|\W)(cp|ln|mv|tee)$/) {
                #### commands that process all arguments at once ####
                my $sub = \&{"v$1"};
                &{$sub}($client, \%copts);
            } 
            if ($copts{-argc} || $copts{-arg1} && $ARGV[0] =~ /(?:^|\W)grep$/) {
                #### commands that execute locally on local files ####
                if ($ARGV[0] =~ /(?:^|\W)ls$/) {
                    # add directory to ls output
                    sftp_echo($client, "");
                    sftp_echo($client, $ARGV[-1] . ":")
                        if ($copts{-argc} == 1 && -d $ARGV[-1]);
                }
                @ARGV = map {glob($_)} @ARGV;
                sftp_cmd($client, @ARGV);
            }
            close $client;
            last if ($ARGV[0] eq 'exit');
        }
        exit;
    }
}

#############################
#### execute vfs command ####
#############################
my $server = IO::Socket::UNIX->new(
    Peer => $sftp_sock,
    Proto => 'tcp',
);
print $server scalar(Data::Dumper->Dump([\@ARGV, $ENV{PWD},
    $ENV{SSH_AUTH_SOCK}], [qw(*ARGV pwd agent_sock)])) . "\n";
my $rc = 0;
if ($ARGV[0] =~ /(?:^|\W)tee$/) {
    while (<STDIN>) {
        print;
        print $server $_;
    }
} else {
    while (<$server>) {
        eval;
        $rc |= WEXITSTATUS(system(@ARGV));
        unlink grep(/meshtmp-/, @ARGV);
    }
}
exit $rc;

=cut mesh

################
#### escape ####
################
# return uri-escaped version of given string
sub escape {
    my $text = shift;
    $text =~ s/([^A-Za-z0-9\-\._~\/])/sprintf("%%%02X", ord($1))/eg
        if (defined $text);
    return $text;
}

##################
#### unescape ####
##################
# return uri-unescaped version of given string
sub unescape {
    my $text = shift;
    $text =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if (defined $text);
    return $text;
}

####################
#### exit_clean ####
####################
# clean up agents/directories and exit
sub exit_clean {
    my $rc = $?;

    if ($opts{k} > 1) {
        # kill spawned agent
        print STDERR "Killing agent with pid $opts{k}\n" if ($opts{v});
        kill(SIGTERM, $opts{k}) && waitpid($opts{k}, 0);
    }

    if ($opts{sftp_d} =~ /mesh-.{8}$/) {
        # rmtree complains about current directory without chdir
        chdir "/";
        # remove temporary directory and all contents
        rmtree($opts{sftp_d});
    }

    exit $rc;
}

##############
#### fqdn ####
##############
# return fully qualified version of given host name
sub fqdn {
    my $host = shift;
    if ($host =~ /^\d+\.\d+\.\d+\.\d+$/) {
        my $name = gethostbyaddr(inet_aton($host), AF_INET);
        return $name if ($name);
    } else {
        my @cols = gethostbyname($host);
        return $cols[0] if ($cols[0]);
    }
    return $host;
}

##################
#### hostpath ####
##################
# return parsed host/path in list context or true if remote path in scalar
sub hostpath {
    my $path = $_[-1];
    my $host = scalar(@_) > 1 ? $_[0] : 'localhost';
    if (scalar(@_) > 1) {
        # multiple arguments
        # return host-path for non-localhost and original path otherwise
        return $path if ($host eq 'localhost');
        return "$host:$path";
    } elsif ($path =~ /^([\w.-]+):(.*)?/) {
        my ($h, $p) = ($1, $2);
        # remove user name if specified
        #TODO: do something with user?
        $h = (split(/@/, $h))[-1];
        if ($h ne 'file' && $p !~ /^\/\//) {
            # single host-path argument in scp format
            ($host, $path) = ($h, $p);
            # remove leading ~/ since it is implied
            $path =~ s/^~\/+//;
            # resolve home dir for relative paths
            if (wantarray && $path !~ /^\//) {
                $path = sftp($host)->cwd . "/" . $path;
            }
        }
    }
    # for list context, return (host, path)
    # for scalar context, return true if non-localhost host-path
    return wantarray ? ($host, $path) : ($host ne 'localhost' ? 1 : 0);
}

##############
#### sftp ####
##############
# return new/cached sftp connection to given host
sub sftp {
    my $host = shift;
    my $no_cwd = shift;
    
    if ($opts{"sftp_$host"}) {
        # use cwd to check for dead connection
        $opts{"sftp_$host"}->cwd if (!$no_cwd);
        # return cached connection to host if still connected
        return $opts{"sftp_$host"} if ($opts{"sftp_$host"}->{_connected});
    }
    # use global agent socket for authentication
    $ENV{SSH_AUTH_SOCK} = $agent_sock;
    # create and cache new connection to host
    $opts{"sftp_$host"} = Net::SFTP::Foreign->new(
        autoflush => 1,
        open2_cmd => "$opts{ssh} -s $host sftp",
    );
    if ($host !~ /\./) {
        my $fqdn = fqdn($host);
        # cache under fully qualified host name as well
        $opts{"sftp_$fqdn"} = $opts{"sftp_$host"} if ($fqdn ne $host);
    }
    return $opts{"sftp_$host"};
}

##################
#### sftp_cmd ####
##################
# execute given command via given socket
sub sftp_cmd {
    my $ref = shift;
    if (ref $ref eq 'IO::Socket::UNIX') {
        print $ref scalar(Data::Dumper->Dump([[@_]], [qw(*ARGV)])) . "\n";
    }
}

###################
#### sftp_echo ####
###################
# print given message via given socket or set text in given hash
sub sftp_echo {
    my $ref = shift;
    return if (!defined $ref || !defined $_[0]);
    if (ref $ref eq 'IO::Socket::UNIX') {
        # use echo to print message
        print $ref scalar(Data::Dumper->Dump([["echo", @_]], [qw(*ARGV)])) . "\n";
    } else {
        $ref->{text} .= join(" ", @_);
    }
}

####################
#### sftp_error ####
####################
# print given error message via given socket or set error text in given hash
sub sftp_error {
    my $ref = shift;
    return if (!defined $ref || !defined $_[0]);
    if (ref $ref eq 'IO::Socket::UNIX') {
        # use echo to print message
        print $ref scalar(Data::Dumper->Dump([["echo", @_]], [qw(*ARGV)])) . "\n";
        # use false to set non-zero exit code
        print $ref scalar(Data::Dumper->Dump([["false"]], [qw(*ARGV)])) . "\n";
    } else {
        # indicate error using special delimiter
        $ref->{text} .= "\\E" . join(" ", @_);
    }
}

######################
#### sftp_warning ####
######################
# print given warning message via given socket or set warning text in given hash
sub sftp_warning {
    my $ref = shift;
    return if (!defined $ref || !defined $_[0]);
    if (ref $ref eq 'IO::Socket::UNIX') {
        # use echo to print message
        print $ref scalar(Data::Dumper->Dump([["echo", @_]], [qw(*ARGV)])) . "\n";
        # use false to set non-zero exit code
        print $ref scalar(Data::Dumper->Dump([["false"]], [qw(*ARGV)])) . "\n";
    } else {
        # indicate warning using special delimiter
        $ref->{text} .= "\\W" . join(" ", @_);
    }
}

#################
#### sftp_ls ####
#################
# return formatted ls string of given remote file
sub sftp_ls {
    #TODO: size is negative in some cases (perhaps showing 64-bit results
    #      on 32-bit system?
    my ($name, $attrs) = ($_[0]->{filename}, $_[0]->{a});
    $name = basename($name) if ($_[1]);
    return $name if (!$_[2]);
    $name = "$name -> $_[0]->{link}" if ($_[0]->{link});
    my $user = getpwuid($attrs->uid);
    $user = $attrs->uid if (!$user);
    my $group = getgrgid($attrs->gid);
    $group = $attrs->gid if (!$group);
    return sprintf("%10s %4d %7s %7s %9d %12s %s",
        sftp_ls_mode($attrs->perm), 1, $user, $group, $attrs->size, 
        strftime("%b %d  %Y", localtime $attrs->mtime), $name);
}

######################
#### sftp_ls_mode ####
######################
# return formatted ls permission string corresponding to given mode
sub sftp_ls_mode {
    my $mode = shift;
    my @perms = qw(--- --x -w- -wx r-- r-x rw- rwx);
    my @ftype = qw(. p c ? d ? b ? - ? l ? s ? ? ?);
    $ftype[0] = '';
    my $setids = ($mode & 07000) >> 9;
    my @permstrs = @perms[
        ($mode & 0700) >> 6, ($mode & 0070) >> 3, $mode & 0007];
    my $ftype = $ftype[($mode & 0170000) >> 12];
  
    if ($setids) {
        $permstrs[2] =~ s/([-x])$/$1 eq 'x' ? 't' : 'T'/e if ($setids & 01);
        $permstrs[0] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e if ($setids & 04);
        $permstrs[1] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e if ($setids & 02);
    }
  
    return join('', $ftype, @permstrs);
}

##################
#### sftp_tmp ####
##################
# return new temporary file name (with handle in array context)
sub sftp_tmp {
    my %dir;
    # create in vfs socket directory if it exists
    $dir{DIR} = defined $opts{sftp_d} ? $opts{sftp_d} : $opts{tmp_d};
    my ($tmpfh, $tmp) = tempfile("meshtmp-XXXXXXXX", %dir);
    if (wantarray) {
        # in array context, return both file handle and file name
        return ($tmpfh, $tmp);
    } else {
        close $tmpfh;
        # in scalar context, return just file name
        return $tmp;
    }
}

################
#### shift_ ####
################
# starting point for all shift functionality
sub shift_ {
    # shift: Self-Healing Independent File Transfer
    my $shift = $opts{base0} !~ /^shift/ ? " " . shift @ARGV : "";
    $opts{command} = join(" ", @{$opts{argv}});
    die "Invalid options\n" if (!GetOptions(\%opts,
        "clients=i", "cpu=i", "create-tar", "directory|d", "disk=i", "encrypt",
        "extract-tar", "files=s", "help|h", "history", "host-file=s",
        "host-list=s", "hosts=i", "id=s", "identity=s", "ignore-times|I",
        "io=i", "dereference|L", "index-tar", "local=s", "mgr=s",
        "mgr-identity=s", "mgr-user=s", "net=i", "no-check", "no-cron",
        "no-mail", "no-offline", "no-preserve", "no-dereference|P", "pid=i",
        "recursive|R|r", "remote=s", "restart", "retry=i", "search=s", "size=s",
        "split=s", "split-tar=s", "state=s", "stats", "status:s", "stop",
        "stripe=s", "sync", "no-target-directory|T", "user=s", "verify",
        "verify-fast", "wait",
        #TODO: deprecated options: remove when enough time passed
        "preserve|p", "quiet",
    ));
    my %in_opts = map {$_ => 1} keys %opts;
#TODO: deprecated options: remove when enough time passed
    if ($opts{preserve}) {
        print STDERR "NOTE: The -p/--preserve options are deprecated as attributes are now\n";
        print STDERR "      preserved by default.  If you DO NOT wish to preserve attributes,\n";
        print STDERR "      use the --no-preserve option.\n"
    }
    if ($opts{quiet}) {
        $opts{"no-mail"} = 1;
        print STDERR "NOTE: The --quiet option is deprecated and is now named --no-mail for\n";
        print STDERR "      consistency with other options.  Please use --no-mail in the future.\n";
    }
#TODO: end deprecated options

    my %hosts = map {fqdn($_) => 1} split(/,/, $opts{'host-list'});
    if ($opts{'host-file'}) {
        if (open(FILE, '<', $opts{'host-file'})) {
            while (<FILE>) {
                chomp;
                $hosts{fqdn($_)} = 1;
            }
            close FILE;
        } else {
            die "Unable to read host file " . $opts{'host-file'} . ": $!\n";
        }
    }
    if (scalar(keys %hosts) != 0) {
        $opts{hosts} = scalar(keys %hosts) + 1 if (!defined $opts{hosts});
        $opts{'host-list'} = join(",", keys %hosts);
        $in_opts{'host-list'} = 1;
        $in_opts{hosts} = 1;
    }

    if ($opts{base0} =~ /^shift/) {
        # these options are only needed when shift is standalone without mesh
        $opts{ssh} .= " -i $opts{identity}" if ($opts{identity});
        $opts{ssh} .= " -l $opts{user}" if ($opts{user});
        $opts{ssh} .= " -q";
    }

    #TODO: for initial testing, turn clients/hosts off for everyone by default
    foreach (qw(check cron mail offline preserve)) {
        $opts{$_} = $opts{"no-$_"} ? 0 : 1;
        $in_opts{$_} = 1 if ($in_opts{"no-$_"});
    }
    $opts{check} = 1 if ($opts{sync});
    # do not use cron if root
    $opts{cron} = 0 if ($< == 0);
    $opts{init_size} = 10000;
    $opts{mail} = 0 if ($opts{wait});
    $opts{mgr} = unescape($opts{mgr}) if ($opts{mgr});
    $opts{'no-dereference'} = 1 if ($opts{recursive});
    $opts{offline} = 0 if ($opts{'create-tar'} || $opts{'extract-tar'});
    $opts{preserve} = 1 if ($opts{sync});
    $opts{recursive} = 1 if ($opts{'create-tar'});
    $opts{verify} = 1 if ($opts{sync} || $opts{"verify-fast"});

    if ($opts{'split-tar'} =~ /^([1-9]\d*)([kmgt])?$/i) {
        # byte string conversions
        my %bytes = ('' => 1, K => 1E3, M => 1E6, G => 1E9, T => 1E12);
        my $unit = defined $2 ? $2 : '';
        $opts{'split-tar'} = $1 * $bytes{uc $unit};
    } else {
        $opts{'split-tar'} = 500E9;
    }
 
    my $host = fqdn(hostname);
    if ($opts{pid} > 0) {
        # immediately exit if users should not be on the system
        exit if (-e "/etc/nologin");
        # check not already running
        my $run = qx(ps -o command -p $opts{pid});
        if ($run =~ /shift/) {
            # send keepalive
            if ($opts{id}) {
                my $out = shift_mgr("--alive --id=$opts{id} --host=$host");
                shift_stop() if ($out =~ /stop/);
            }
            exit;
        }
        #TODO: hack to add basic paths in case not available via cron
        #      this should really save the user's path and recreate it
        #      for the general case
        $ENV{PATH} .= ":/bin:/usr/bin:/usr/local/bin";
    }

    #TODO: sup should check after certain time and notify user that no
    #      progress has been made on a particular transfer
    #TODO: need warning if key about to expire as have no way to notify
    #      user once key expires
    #TODO: intercept SIGTERM and remove id?
    #TODO: --overwrite option?

    my $usage = "Usage: $opts{base0}$shift [OPTION]... SOURCE DEST\n" .
        "  or:  $opts{base0}$shift [OPTION]... SOURCE... DIRECTORY\n" .
        "  or:  $opts{base0}$shift [OPTION]...\n";
    if ($opts{stop} && $opts{id}) {
        my $out = shift_mgr("--stop --id=$opts{id}");
        die "$$out\n" if (ref $out);
        shift_stop();
    } elsif ($opts{stats}) {
        my $out = shift_mgr("--stats");
        die "$$out\n" if (ref $out);
        print $out;
        exit;
    } elsif ($opts{history}) {
        my $id = $opts{id} ? "--id=$opts{id}" : "";
        my $search = $opts{search} ? "--search=" . escape($opts{search}) : "";
        my $out = shift_mgr("--history $id $search");
        die "$$out\n" if (ref $out);
        print $out;
        exit;
    } elsif (defined $opts{status}) {
        my $id = $opts{id} ? "--id=$opts{id}" : "";
        my $search = $opts{search} ? "--search=" . escape($opts{search}) : "";
        my $state = $opts{state} ? "--state=$opts{state}" : "";
        my $status = $opts{status} ? "=$opts{status}" : "";
        # use file in case of very large output
        my ($fh, $file) = tempfile(DIR => $opts{tmp_d});
        close $file;
        my $out = shift_mgr("--status$status $id $search $state", undef, $file);
        die "$$out\n" if (ref $out);
        open($fh, '<', $file);
        print while (<$fh>);
        exit;
    } elsif ($opts{'create-tar'} && $opts{'extract-tar'}) {
        die "--create-tar and --extract-tar are mutually exclusive\n";
    } elsif ($opts{'index-tar'} && !$opts{'create-tar'}) {
        die "--index-tar requires the --create-tar option\n";
    } elsif ($opts{sync} && ($opts{'create-tar'} || $opts{'extract-tar'})) {
        die "--sync cannot be used with --create-tar/--extract-tar\n";
    } elsif ($opts{restart} && !$opts{id}) {
        die "--restart requires the --id option\n";
    } elsif ($opts{stop} && !$opts{id}) {
        die "--stop requires the --id option\n";
    } elsif ($opts{help}) {
        print "$usage\n";
        print "Reliably transfer SOURCE to DEST, multiple SOURCE(s) to DIRECTORY,\n";
        print "or arbitrary SOURCE to DEST and/or SOURCE(s) to DIRECTORY combinations\n";
        print "read from stdin.\n";
        print "\n";
        print "Local paths are specified normally.  A path PATH on a remote host HOST\n";
        print "is specified using scp-style \"HOST:PATH\".\n";
        print "\n";
        print "Options (defaults in brackets):\n";
        print "      --clients=NUM         use at most NUM clients per host [1]\n";
        print "      --cpu=NUM             throttle transfer at local cpu usage of NUM %\n";
        print "      --create-tar          create tar file of SOURCE(s) at DEST\n";
        print "  -d, --directory           create any missing parent directories\n";
        print "      --disk=NUM            throttle transfer at target disk usage of NUM %\n";
        print "      --encrypt             encrypt data stream(s) during remote transfers\n";
        print "      --extract-tar         extract tar file at SOURCE to DEST\n";
        print "      --files=COUNT         process transfer in batches of COUNT files\n";
        print "                              (use suffix {k,m,b/g,t} for 10E{3,6,9,12}) [1k]\n";
        print "  -h, --help                help\n";
        print "      --history             show list of transfer commands and origin host\n";
        print "      --host-file=FILE      parallelize transfer on hosts in FILE (one per line)\n";
        print "      --host-list=LIST      parallelize transfer on hosts in LIST\n";
        print "      --hosts=NUM           parallelize transfer on at most NUM client hosts [1]\n";
        print "      --id=NUM              use transfer identifier NUM for other commands\n";
        print "      --identity=FILE       access remote systems with ssh identity in FILE\n";
        print "  -I, --ignore-times        don't skip files that match size and time\n";
        print "      --index-tar           create table of contents during tar creation\n";
        print "      --io=NUM              throttle transfer at local i/o usage of NUM MB/s\n";
        print "  -L, --dereference         always follow symbolic links\n";
        print "      --local=LIST          set local transport mechanism to one of LIST\n";
        print "                              (LIST subset of {mcp,rsync,cp})\n";
        print "      --mgr=HOST            set host of shift manager to HOST\n";
        print "      --mgr-identity=FILE   access manager host with ssh identity in FILE\n";
        print "      --mgr-user=USER       access manager host as user USER\n";
        print "      --net=NUM             throttle transfer at local network usage of NUM MB/s\n";
        print "      --no-check            do not check file existence/size (not recommended)\n";
        print "      --no-cron             do not recover from host/process failures via cron\n";
        print "      --no-mail             do not send status emails\n";
        print "      --no-offline          do not release DMF-managed files after transfer\n";
        print "      --no-preserve         do not preserve times, permissions, and ownership\n";
        print "  -P, --no-dereference      never follow symbolic links\n";
        print "  -R, -r, --recursive       copy directories recursively\n";
        print "      --remote=LIST         set remote transport mechanism to one of LIST\n";
#TODO: add bbcp,globus-url-copy if/when generally available
        print "                              (LIST subset of {bbftp,fish,rsync,sftp})\n";
        print "      --restart             restart transfer with given --id\n";
        print "      --retry=NUM           retry failed operations up to NUM times [2]\n";
        print "      --search=REGEX        show only status/history matching regex REGEX\n";
        print "      --size=SIZE           process transfer in batches of SIZE bytes\n";
        print "                              (use suffix {k,m,g,t} for {KB,MB,GB,TB}) [4g]\n";
        print "      --split=SIZE          parallelize single files using chunks of SIZE bytes\n";
        print "                              (use suffix {k,m,g,t} for {KB,MB,GB,TB}) [0]\n";
        print "      --split-tar=SIZE      create tar files of around SIZE bytes\n";
        print "                              (use suffix {k,m,g,t} for {KB,MB,GB,TB}) [500g]\n";
        print "      --state=STATE         show only operations with state STATE in status\n";
        print "                              (STATE one of {done,error,none,queue,run,warn})\n";
        print "      --stats               show stats across all transfers\n";
        print "      --status[=csv]        show brief status of all transfers\n";
        print "                              or detailed status of transfer with given --id\n";
        print "      --stop                stop transfer with given --id\n";
        print "      --stripe=SIZE|NUM     use 1 stripe per SIZE bytes or NUM stripes\n";
        print "                              (use suffix {k,m,g,t} for {KB,MB,GB,TB}) [1g]\n";
        print "      --sync                synchronize files at destination\n";
        print "  -T, --no-target-directory treat target as a normal file\n";
        print "      --user=USER           access remote systems as user USER\n";
        print "      --verify              verify/rectify integrity of all destination files\n";
        print "      --verify-fast         verify faster but less safely by reusing src buffer\n";
        print "      --wait                block until transfer completes\n";
        print "                              (exit 0 = success, 1 = failure)\n";
        exit;
    }

    # unpack sftp module if necessary
    $opts{sftp_d} = tempdir("mesh-XXXXXXXX", DIR => $opts{tmp_d});
    sftp_require($opts{sftp_d}) if (!eval
        'require Net::SFTP::Foreign && $Net::SFTP::Foreign::VERSION >= 1.75');

    # process arguments
    if (!$opts{id}) {
        print "Computing file operations\n" if ($opts{v});
        my ($logfh, $log) = sftp_tmp();

        # send options
        foreach (qw(check clients command cpu create-tar cron disk encrypt
                    extract-tar files host-list hosts index-tar io local mail
                    net offline preserve remote retry size split split-tar
                    stripe verify verify-fast wait)) {
            print $logfh "args=getopt,$_ text=", escape($opts{$_}), "\n"
                if (defined $opts{$_});
        }
        # send client version
        print $logfh "args=getopt,version text=$VERSION\n";
        # send current directory
        print $logfh "args=getopt,cwd text=", escape(getcwd()), "\n";
        # indicate all options sent
        print $logfh "args=getopt,end\n";

        my ($nfiles, $ndirs, $n0) = (0, 0, 0);
        my $meter = "$nfiles/$ndirs";
        print "Reading argument lines from stdin...\n" if (scalar(@ARGV) == 0);
        print "Directories/files found: $meter";
        if (scalar(@ARGV) > 0) {
            shift_args(\$logfh, $log, \$meter, \$nfiles, \$ndirs, \$n0,
                $host, \@ARGV);
        } else {
            while (my $line = <STDIN>) {
                $line =~ s/^\s+|\s+$//g;
                my @args = quotewords('\s+', 0, $line);
                shift_args(\$logfh, $log, \$meter, \$nfiles, \$ndirs, \$n0,
                    $host, \@args);
            }
        }
        print "\n"; # this is for meter
        print $logfh "args=last\n";
        close $logfh;
        if ($ndirs + $nfiles > 0) {
            shift_init($log, $n0, $ndirs + $nfiles);
            print "Shift id is $opts{id}\n";
            STDOUT->flush;
        } else {
            print $usage;
            exit;
        }
    } elsif ($opts{restart}) {
        # send options that can be respecified
        my ($logfh, $log) = sftp_tmp();
        foreach (qw(clients cpu cron disk encrypt files host-list hosts io
                    local mail net offline remote retry size stripe)) {
            print $logfh "args=getopt,$_ text=", escape($opts{$_}), "\n"
                if ($in_opts{$_});
        }
        # indicate all options sent
        print $logfh "args=getopt,end\n";
        my $out = shift_mgr("--restart --id=$opts{id} --host=$host --put", $log);
        die "$$out\n" if (ref $out);
    } elsif (!defined $opts{pid}) {
        print $usage;
        exit;
    }

    # this will either start a child or do nothing if one already started
    shift_child();

    # prevent cleanup
    $opts{sftp_d} = undef;
    $opts{k} = undef;

    # do not use crontab when extra clients
    POSIX::_exit(0) if ($opts{id} =~ /\D/);

#TODO: cron job will never exit if doesn't pass first checks (e.g. invalid key)
    if ($opts{cron}) {
        # install crontab
        print STDERR "Installing crontab\n" if ($opts{v});
        my $tab;
        if (open(TAB, '-|', "crontab -l 2>/dev/null")) {
            while (<TAB>) {
                # ignore garbage added by crontab
                next if (/^#.*(?:edit the master|installed on|Cron version)/);
                $tab .= $_;
            }
            close TAB;
        }
        # replace pid if entry already exists in crontab
        if ($tab !~ s/(--id=$opts{id}\s+--pid=)\d+/$1$opts{child_pid}/) {
            # construct new crontab entry
            $tab .= "\n*/10 * * * * $opts{abs0}";
            if (basename($opts{abs0}) !~ /^shift/) {
                $tab .= " -u $opts{u}" if ($opts{u});
                $tab .= " -b -p $opts{p} shift";
            }
            if ($opts{mgr}) {
                my $mgr = escape($opts{mgr});
                # percent needs to be escaped in crontab
                $mgr =~ s/%/\\%/g;
                $tab .= " --mgr=$mgr";
            }
            if ($opts{"mgr-user"}) {
                my $user = escape($opts{"mgr-user"});
                # percent needs to be escaped in crontab
                $user =~ s/%/\\%/g;
                $tab .= " --mgr-user=$user";
            }
            $tab .= " --mgr-identity=" . $opts{"mgr-identity"}
                if ($opts{"mgr-identity"});
            $tab .= " --identity=$opts{identity}" if ($opts{identity});
            $tab .= " --user=$opts{user}" if ($opts{user});
            $tab .= " --id=$opts{id} --pid=$opts{child_pid} >/dev/null 2>&1\n";
        }
        my ($fh, $file) = tempfile();
        print $fh $tab;
        close $fh;
        my $out = qx(crontab $file 2>&1);
        $opts{cron} = 0 if (!defined $out || $?);
        unlink $file;
    }
    if (!$opts{cron}) {
        print STDERR "WARNING: Unable to install crontab or --no-cron option specified.\n";
        print STDERR "         Automated recovery across host/process failures is disabled.\n";
    }
    if ($opts{wait}) {
        print "Waiting for transfer to complete...";
        STDOUT->flush;
        # set exit to 1 in case killed while waiting
        $? = 1;
        waitpid($opts{child_pid}, 0);
        my $out = shift_mgr("--status --state=none --id=$opts{id}");
        print "\n\n", $out;
        POSIX::_exit(1) if ($out !~ /done/);
    } else {
        print STDERR "Detaching process (use --status option to monitor progress)\n";
    }
    # use _exit to avoid END block processing
    POSIX::_exit(0);
    #TODO: what if died while generating file list?
}

####################
#### shift_args ####
####################
sub shift_args {
    my ($logfh_ref, $log, $meter, $nfiles, $ndirs, $n0, $host, $args) = @_;
    my $logfh = $$logfh_ref;
    my @args = @{$args};

    my $dst = pop(@args);
    my ($dhost, $dpath) = hostpath($dst);
    my $dmode;
    if ($dhost ne 'localhost') {
        # remote dst
        $dhost = fqdn($dhost);
        my $test = sftp($dhost)->realpath($dpath);
        if (!defined $test) {
            # dst does not exist so use parent directory
            my $dir = dirname($dpath);
            # make parent directories if requested
            sftp($dhost)->mkpath($dir) if ($opts{directory});
            if ($opts{'extract-tar'}) {
                # make dst if extracting tar
                sftp($dhost)->mkdir($dpath);
                my $dattrs = sftp($dhost)->stat($dpath);
                $dmode = $dattrs->perm if (defined $dattrs);
            }
            $test = "$dir/__shift_test__";
            # reconstruct dpath using real path of parent
            my $absdir = sftp($dhost)->realpath($dir);
            $dpath = "$absdir/" . basename($dpath) if (defined $absdir);
        } else {
            die "$dst exists or is a directory\n" if ($opts{'create-tar'});
            $dpath = $test;
            my $dattrs = sftp($dhost)->stat($dpath);
            $dmode = $dattrs->perm if (defined $dattrs);
            $test .= "/" if (S_ISDIR($dmode));
            # use different file name to avoid accidental DMF recall
            $test .= "__shift_test__";
        }
        # check writability
        my $ref = {};
        vtouch($ref, $dhost, $test);
        die "$dst is not writable, not authorized for writes, or parent directory missing\n"
            if ($ref->{text} =~ /denied/);
        sftp($dhost)->remove($test);
        $dst = hostpath($dhost, $dpath);
        #TODO: error handling if can't remove
    } else {
        # local dst
        $dst = abs_path($dpath);
        die "$dst exists or is a directory\n"
            if (-e $dst && $opts{'create-tar'});
        if (!defined $dst && $opts{directory}) {
            # make parent directories if requested
            eval {mkpath(dirname($dpath))};
            $dst = abs_path($dpath);
        } elsif (!defined $dst) {
            die "Parent directory of $dpath does not exist\n";
        }
        if (! -e $dst && $opts{'extract-tar'}) {
            # make dst if extracting tar
            mkdir($dpath);
            $dst = abs_path($dpath);
        }
        $dmode = (stat($dst))[2];
        # check writability
        my $test = $dst;
        $test .= "/" if (S_ISDIR($dmode));
        # use different file name to avoid accidental DMF recall
        $test .= "__shift_test__";
        die "$dst is not writable\n" if (!open(FILE, '>', $test));
        close FILE;
        unlink $test;
    }
    if (!S_ISDIR($dmode)) {
        die "$dst is not a directory\n" if (!$opts{'create-tar'} &&
            (scalar(@args) > 1 || $opts{'extract-tar'}));
    }

    my $tar_size = 0;
    my $tar_split = 1;
    my $itarfh;

#TODO: need to handle C-c after this point
    # dereference links, check for errors, and expand wildcards
    my %spaths;
    foreach my $src (@args) {
        my ($shost, $spath) = hostpath($src);
        if ($shost ne 'localhost') {
            # remote src
            if ($dhost ne 'localhost') {
                die "\nTransfers between remote hosts are not supported\n";
            }
            # check for wildcards
            if ($spath =~ /[[*?]/) {
                my @glob = sftp($shost)->glob($spath);
                if (scalar @glob > 0) {
                    # process expanded pathnames and ignore this arg
                    push(@args, map {hostpath($shost, $_->{filename})} @glob);
                    next;
                }
            }
            $shost = fqdn($shost);
            my $dir = sftp($shost)->realpath(dirname($spath));
            my $base = basename($spath);
            $dir .= "/" if ($dir !~ /\/$/);
            # if trailing slash on dir link, then resolve top level
            # even if --no-dereference is specified per posix spec
            my $slash = $spath =~ /.\/$/ ? 1 : 0;
            $spath = $dir . $base;
            $src .= "/" if ($slash);

            my $sattrs = sftp($shost)->stat($spath);
            if (!defined $sattrs && $opts{'no-dereference'}) {
                $sattrs = sftp($shost)->lstat($spath);
            }
            if (!defined $spath || !defined $sattrs) {
                print STDERR "\n$src: No such file or directory\n";
                next;
            }
            my $smode = $sattrs->perm;
            if (!S_ISDIR($smode) && !S_ISREG($smode) && !S_ISLNK($smode)) {
                print STDERR "\nSkipping unsupported file $src\n";
                next;
            }
            if (S_ISDIR($smode) && (!S_ISLNK($smode) || $slash) &&
                    !$opts{recursive}) {
                print STDERR "\n$src is a directory\n";
                next;
            }
            if (S_ISDIR($smode) && (!S_ISLNK($smode) || $slash) &&
                    defined $dmode && !S_ISDIR($dmode) &&
                    !$opts{'create-tar'}) {
                print STDERR "\n$dst is a file\n";
                next;
            }
            if ((!S_ISDIR($smode) || S_ISLNK($smode) && !$slash) &&
                    defined $dmode && S_ISDIR($dmode) &&
                    $opts{'no-target-directory'}) {
                print STDERR
                    "\nCannot overwrite directory $dst with non-directory\n";
                next;
            }
            if (S_ISDIR($smode) && (!S_ISLNK($smode) || $slash) &&
                    defined $dmode && !S_ISDIR($dmode) &&
                    $opts{'no-target-directory'}) {
                print STDERR
                    "\nCannot overwrite non-directory $dst with directory\n";
                next;
            }

            # check readability
            if (S_ISREG($smode)) {
                my $test = sftp($shost)->open($spath, SFTP_READ);
                if (!$test) {
                    print STDERR
                        "\n$src is not readable or not authorized for reads\n";
                    next;
                }
                close $test if ($test);
            }

            # postpone source processing until later for aggregation
            push(@{$spaths{$shost}}, {path => $spath, slash => $slash,
                mode => $smode});
        } else {
            # local src
            # resolve src dir to absolute path but keep base name the same
            my $dir = abs_path(dirname($src));
            my $base = basename($src);
            $dir .= "/" if ($dir !~ /\/$/);
            # if trailing slash on dir link, then resolve top level
            # even if --no-dereference is specified per posix spec
            my $slash = $src =~ /.\/$/ ? 1 : 0;
            $src = $dir . $base;
            $slash = 0 if (! -l $src || ! -d $src);
            $src .= "/" if ($slash);

            my $smode = (stat($src))[2];
            if (!defined $smode && -l $src && $opts{'no-dereference'}) {
                $smode = (lstat($src))[2];
            }
            if (!defined $smode) {
                print STDERR "\n$src: No such file or directory\n";
                next;
            }
            if (!S_ISDIR($smode) && !S_ISREG($smode) && !S_ISLNK($smode)) {
                print STDERR "\nSkipping unsupported file $src\n";
                next;
            }
            if (S_ISDIR($smode) && (! -l $src || $slash) && !$opts{recursive}) {
                print STDERR "\n$src is a directory\n";
                next;
            }
            if (S_ISDIR($smode) && (! -l $src || $slash) && defined $dmode &&
                    !S_ISDIR($dmode) && !$opts{'create-tar'}) {
                print STDERR "\n$dst is a file\n";
                next;
            }
            if ((!S_ISDIR($smode) || -l $src && !$slash) && defined $dmode &&
                    S_ISDIR($dmode) && $opts{'no-target-directory'}) {
                print STDERR
                    "\nCannot overwrite directory $dst with non-directory\n";
                next;
            }
            if (S_ISDIR($smode) && (! -l $src || $slash) && defined $dmode &&
                    !S_ISDIR($dmode) && $opts{'no-target-directory'}) {
                print STDERR
                    "\nCannot overwrite non-directory $dst with directory\n";
                next;
            }

            # check readability
            if (S_ISREG($src) && !open(FILE, '<', $src)) {
                print STDERR "\n$src is not readable\n";
                next;
            }
            close FILE;

            # postpone source processing until later for aggregation
            push(@{$spaths{$shost}}, {src => $src, path => $spath,
                slash => $slash, mode => $smode});
        }
    }

    # compute remote files and sizes
    foreach my $shost (keys %spaths) {
        next if ($shost eq 'localhost');
        # try shift-aux
        my $aux_fail = 1;
        my $extra;
        $extra .= " -L" if ($opts{dereference});
        $extra .= " -P" if ($opts{'no-dereference'});
        $extra .= " --extract-tar" if ($opts{'extract-tar'});
        # use open3 instead of open with pipe as it destroys stdin
        my $pid = open3(\*IN, \*OUT, \*ERR,
            "$opts{ssh} $shost $opts{caux} find $extra " .
            join(" ", map {escape($_->{path})} @{$spaths{$shost}}));
        close IN;
        while (<OUT>) {
            s/\s*\r?\n$//;
            $aux_fail = 0;
            if (!/,/) {
                # errors indicated by comma-less line
                print STDERR "\n$_\n";
                next;
            }
            my @cols = split(/,/);
            my $spath = shift @cols;
            my $spath_is_dir = $spath =~ s/\/$//;
            my $type = shift @cols;
            my $file = unescape(shift @cols);
            my $usrc = unescape(shift @cols);
            my $size = shift @cols;
            my $bytes = $opts{'extract-tar'} ? pop @cols : "";
            my $lattrs = pop @cols;
            $lattrs =~ s/;/,/g;
            $lattrs = undef if ($lattrs eq 'undef');
            my $acls = pop @cols;
            $acls =~ s/;/,/g;
            $acls = undef if ($acls eq 'undef');
            my $attrs = join(",", @cols, $size);

            # begin log entry
            my $usrc = escape(hostpath($shost, $usrc));
            if ($type eq 'mkdir') {
                print $logfh "args=mkdir";
                $$ndirs++;
            } elsif ($type =~ /^ln:([^,]+)/) {
                print $logfh "args=ln,$1";
                $$nfiles++;
            } elsif ($opts{sync}) {
                print $logfh "args=ckattr",
                    ($opts{'ignore-times'} ? "0," : ","), $usrc;
                $$nfiles++;
            } else {
                print $logfh "args=$type,$usrc";
                $$nfiles++;
            }

            # compute dst
            my $udst;
            if ($opts{'create-tar'}) {
                $udst = $dst;
                # must add split extension before calling tar_create
                $udst .= "-$tar_split.tar" if ($tar_split);
                $bytes = tar_create($dhost, $dpath, \$tar_split,
                    \$itarfh, \$tar_size, $type, $file, $size, $attrs);
            } elsif (defined $dmode && !S_ISDIR($dmode)) {
                $udst = $dst;
            } elsif (!$spath_is_dir && !$opts{'extract-tar'}) {
                $udst = $dst;
                $udst .= "/" . basename($file) if (defined $dmode);
            } else {
                $udst = $file;
                my $sdir = (defined $dmode && !$opts{'no-target-directory'}) ?
                    dirname($spath) : $spath;
                $udst =~ s/^\Q$sdir\E\/?//;
                # ignore root of src when -T used with existing dst
                next if (!$udst && defined $dmode &&
                        $opts{'no-target-directory'});
                substr($udst, 0, 0) = "/" if ($udst);
                $udst = $dst . $udst;
            }
            $udst = escape($udst);

            print $logfh ",$udst host=$host size=$size attrs=$attrs";
            print $logfh " acls=$acls" if ($acls);
            print $logfh " lustre_attrs=$lattrs" if ($lattrs);
            print $logfh " bytes=$bytes tar_bytes=$bytes"
                if ($opts{'extract-tar'} || $opts{'create-tar'});
            print $logfh " tar_name=" . escape($file)
                if ($opts{'create-tar'});
            print $logfh " tar_last=1"
                if ($opts{'create-tar'} && $tar_size == 0);
            print $logfh "\n";

            # update meter
            print "\e[" . length($$meter) . "D";
            $$meter = "$$ndirs/$$nfiles";
            print $$meter;
            if ($$ndirs + $$nfiles - $$n0 >= $opts{init_size}) {
                close $logfh;
                shift_init($log, $$n0, $$ndirs + $$nfiles);
#TODO: what about errors after child forked?  Must stop processing
                open($logfh, '>', $log);
                $$n0 = $$ndirs + $$nfiles;
            }
        }
        close OUT;
        close ERR;
        waitpid($pid, 0);

        # no additional processing needed if shift-aux succeeded
        next if (!$aux_fail);

        # process remote tar files if shift-aux fails
        if ($opts{'extract-tar'}) {
            # try to dmget all tar files just in case
            stderr_off();
            if (open(DMGET, '|-',
                    "$opts{ssh} $shost dmget -q >/dev/null 2>/dev/null")) {
                print DMGET join("\n", map {$_->{path}} @{$spaths{$shost}});
                close DMGET;
            }
            stderr_on();
            foreach my $sref (@{$spaths{$shost}}) {
                tar_extract(hostpath($shost, $sref->{path}), $dst, $logfh_ref,
                    $log, $meter, $nfiles, $ndirs, $n0, $host);
            }
            next;
        }

        # compute files and sizes using sftp if shift-aux fails
        # note that this case does not support acls, dmf, or striping
        foreach my $sref (@{$spaths{$shost}}) {
            my %deref;
            $deref{follow_links} = 1 if ($opts{dereference});
            sftp($shost)->find($sref->{path}, %deref, on_error => sub {
                print STDERR "\nError processing $_[1]\n";
            }, wanted => sub {
                my $file = $_[1];
                my $fattrs = $file->{a};
                my $usrc = $file->{filename};
                if (!S_ISDIR($fattrs->perm) && !S_ISREG($fattrs->perm) &&
                        !S_ISLNK($fattrs->perm)) {
                    print STDERR "\nSkipping unsupported file $usrc\n";
                    return undef;
                }
                if ($opts{dereference} || S_ISLNK($fattrs->perm) &&
                        !$opts{'no-dereference'}) {
                    my $fattrs_stat = sftp($shost)->stat($usrc);
                    # resolve file symlinks by default
                    if (defined $fattrs_stat && !S_ISDIR($fattrs_stat->perm)) {
                        $usrc = sftp($shost)->realpath($usrc);
                        $fattrs = $fattrs_stat;
                    }
                }
                $usrc = escape(hostpath($shost, $usrc));

                # don't have user/group name in this case so base on uid/gid
                my $attrs = join(",", $fattrs->perm & 07777,
                    $fattrs->uid, $fattrs->gid, $fattrs->atime,
                    $fattrs->mtime, "uid_" . $fattrs->uid,
                    "gid_" . $fattrs->gid, $fattrs->size);

                # begin log entry
                my $type;
                if (S_ISLNK($fattrs->perm)) {
                    my $ln = sftp($shost)->readlink($file->{filename});
                    print $logfh "args=ln,", escape($ln);
                    $$nfiles++;
                    $type = "ln:$ln";
                } elsif (S_ISDIR($fattrs->perm)) {
                    print $logfh "args=mkdir";
                    $$ndirs++;
                    $type = "mkdir";
                } elsif ($opts{sync}) {
                    print $logfh "args=ckattr",
                        ($opts{'ignore-times'} ? "0," : ","), $usrc;
                    $$nfiles++;
                } else {
                    print $logfh "args=cp,$usrc";
                    $$nfiles++;
                    $type = "cp";
                }

                # compute dst
                my $udst;
                my $bytes;
                if ($opts{'create-tar'}) {
                    $udst = $dst;
                    # must add split extension before calling tar_create
                    $udst .= "-$tar_split.tar" if ($tar_split);
                    $bytes = tar_create($dhost, $dpath, \$tar_split, \$itarfh,
                        \$tar_size, $type, $sref->{path}, $fattrs->size, $attrs);
                } elsif (defined $dmode && !S_ISDIR($dmode)) {
                    $udst = $dst;
                } elsif (!S_ISDIR($sref->{mode})) {
                    $udst = $dst;
                    $udst .= "/" . basename($file->{filename})
                        if (defined $dmode);
                } else {
                    $udst = $file->{filename};
                    my $sdir = (defined $dmode && !$opts{'no-target-directory'}) ?
                        dirname($sref->{path}) : $sref->{path};
                    $udst =~ s/^\Q$sdir\E\/?//;
                    # ignore root of src when -T used with existing dst
                    return undef if (!$udst && defined $dmode &&
                            $opts{'no-target-directory'});
                    substr($udst, 0, 0) = "/" if ($udst);
                    $udst = $dst . $udst;
                }
                $udst = escape($udst);

                print $logfh ",$udst host=$host size=", $fattrs->size, " attrs=$attrs";
                print $logfh " bytes=$bytes tar_bytes=$bytes tar_name=" .
                    escape($file->{filename}) if ($opts{'create-tar'});
                print $logfh " tar_last=1"
                    if ($opts{'create-tar'} && $tar_size == 0);
                print $logfh "\n";

                # update meter
                print "\e[" . length($$meter) . "D";
                $$meter = "$$ndirs/$$nfiles";
                print $$meter;
                if ($$ndirs + $$nfiles - $$n0 >= $opts{init_size}) {
                    close $logfh;
                    shift_init($log, $$n0, $$ndirs + $$nfiles);
                    open($logfh, '>', $log);
                    $$n0 = $$ndirs + $$nfiles;
                }
                return undef;
            });
        }
    }

    # process local tar files
    if ($opts{'extract-tar'}) {
        # try to dmget all tar files just in case
        stderr_off();
        if (open(DMGET, '|-', "dmget -q >/dev/null 2>/dev/null")) {
            print DMGET join("\n", map {$_->{src}} @{$spaths{localhost}});
            close DMGET;
        }
        stderr_on();
        foreach my $sref (@{$spaths{localhost}}) {
            tar_extract($sref->{src}, $dst, $logfh_ref, $log, $meter, $nfiles,
                $ndirs, $n0, $host);
        }
        delete $spaths{localhost};
    }

    # compute local files and sizes
    my $dmfh;
    foreach my $sref (@{$spaths{localhost}}) {
        # test whether source is on DMF file system
        my $dmf;
        stderr_off();
        if (open(DMATTR, '-|', "dmattr", "-a", "state", $sref->{path})) {
            my $state = <DMATTR>;
            close DMATTR;
            $dmf = 1 if ($state =~ /^[A-Z]{3}$/);
            open($dmfh, '|-', "dmget -q >/dev/null 2>/dev/null")
                if (!$dmfh && $dmf);
        }
        stderr_on();

        my %deref;
        $deref{follow_fast} = 1 if ($opts{dereference});
        find({%deref, no_chdir => 1, follow_skip => 2, wanted => sub {
            my $file = $_;
            # compute src
            my $usrc;
            if ($opts{dereference}) {
                # resolve all symlinks
                $usrc = $File::Find::fullname;
                # fullname can be empty for some reason
                $usrc = abs_path($file) if (!$usrc);
            } elsif (-l $file && ($sref->{slash} || ! -d $file &&
                    !$opts{'no-dereference'}) &&
                    $File::Find::topdir eq $file) {
                # resolve file symlinks by default
                $usrc = abs_path($file);
                # keep dangling links as is
                $usrc = $file if (! -e $usrc);
            } else {
                # keep symlinks unresolved
                $usrc = $file;
            }

            # always get stat info of real file
            my @stat = -l $usrc ? lstat($usrc) : stat($usrc);
            if (scalar(@stat) == 0) {
                print STDERR "\nCannot stat file $usrc\n";
                return;
            }
            if (!S_ISDIR($stat[2]) && !S_ISREG($stat[2]) &&
                    !S_ISLNK($stat[2])) {
                print STDERR "\nSkipping unsupported file $usrc\n";
                return;
            }
            $stat[2] &= 07777;
            # resolve uid/gid if possible
            my $user = getpwuid($stat[4]);
            my $group = getgrgid($stat[5]);
            $user = "uid_$stat[4]" if (!$user);
            $group = "gid_$stat[5]" if (!$group);
            my $attrs = join(",", @stat[2,4,5,8,9],
                escape($user), escape($group), $stat[7]);

            stderr_off();
            # try to get acls
            my @acls;
            #TODO: other operating systems may use something different
            open(FILE, '-|', "getfacl", "-cps", "--", $usrc);
            while (<FILE>) {
                chomp;
                next if (!$_);
                push(@acls, escape($_));
            }
            close FILE;

            # try to get lustre striping
            my @lattrs;
            open(FILE, '-|', "lfs", "getstripe", "-d", $usrc);
            while (<FILE>) {
                $lattrs[0] = $1 if (/stripe_count:\s*(-?\d+)/);
                $lattrs[1] = $1 if (/stripe_size:\s*(-?\d+)/);
            }
            close FILE;
            $lattrs[0] = 0 if (!defined $lattrs[0] && defined $lattrs[1]);
            $lattrs[1] = 0 if (!defined $lattrs[1] && defined $lattrs[0]);
            stderr_on();

            print $dmfh $usrc, "\n" if ($dmf);

            # begin log entry
            my $type;
            if (-l $usrc) {
                my $ln = readlink($usrc);
                print $logfh "args=ln,", escape($ln);
                $$nfiles++;
                $type = "ln:$ln";
            } elsif (-d $usrc) {
                print $logfh "args=mkdir";
                $$ndirs++;
                $type = "mkdir";
            } elsif ($opts{sync}) {
                $usrc = escape($usrc);
                print $logfh "args=ckattr" .
                    ($opts{'ignore-times'} ? "0" : "") . ",$usrc";
                $$nfiles++;
            } else {
                $usrc = escape($usrc);
                print $logfh "args=cp,$usrc";
                $$nfiles++;
                $type = "cp";
            }

            # compute dst
            my $udst;
            my $bytes;
            my $tar_name;
            if ($opts{'create-tar'}) {
                # use original (possibly relative) path name
                $tar_name = $file;
                $tar_name =~ s/^\Q$sref->{src}\E/$sref->{path}/;
                $udst = $dst;
                # must add split extension before calling tar_create
                $udst .= "-$tar_split.tar" if ($tar_split);
                $bytes = tar_create($dhost, $dpath, \$tar_split, \$itarfh,
                    \$tar_size, $type, $tar_name, $stat[7], $attrs);
            } elsif (defined $dmode && !S_ISDIR($dmode)) {
                $udst = $dst;
            } elsif (!S_ISDIR($sref->{mode})) {
                $udst = $dst;
                $udst .= "/" . basename($file) if (defined $dmode);
            } else {
                $udst = $file;
                my $sdir = (defined $dmode && !$opts{'no-target-directory'}) ?
                    dirname($sref->{src}) : $sref->{src};
                $udst =~ s/^\Q$sdir\E\/?//;
                # ignore root of src when -T used with existing dst
                return if (!$udst && defined $dmode &&
                        $opts{'no-target-directory'});
                substr($udst, 0, 0) = "/" if ($udst);
                $udst = $dst . $udst;
            }
            $udst = escape($udst);

            print $logfh ",$udst host=$host size=$stat[7] attrs=$attrs";
            print $logfh " acls=" . join(",", @acls)
                if (scalar(@acls) > 0);
            print $logfh " lustre_attrs=" . join(",", @lattrs)
                if (scalar(@lattrs) > 0);
            print $logfh " bytes=$bytes tar_bytes=$bytes tar_name=" .
                escape($tar_name) if ($opts{'create-tar'});
            print $logfh " tar_last=1"
                if ($opts{'create-tar'} && $tar_size == 0);
            print $logfh "\n";

            # update meter
            print "\e[" . length($$meter) . "D";
            $$meter = "$$ndirs/$$nfiles";
            print $$meter;
            if ($$ndirs + $$nfiles - $$n0 >= $opts{init_size}) {
                close $logfh;
                shift_init($log, $$n0, $$ndirs + $$nfiles);
                open($logfh, '>', $log);
                $$n0 = $$ndirs + $$nfiles;
            }
        }}, $sref->{src});
    }
    close $dmfh if ($dmfh);

    if ($opts{'create-tar'} && $tar_size > 0) {
        # use special op so manager can dynamically insert tar_last
        my $udst = $dst;
        $udst .= "-$tar_split.tar" if ($tar_split);
        print $logfh "args=tar_last,", escape($udst), " size=$tar_size\n";
        tar_create($dhost, $dpath, \$tar_split, \$itarfh, \$tar_size);
    }
}

#####################
#### shift_child ####
#####################
# perform various interactions with shift manager to transfer files
sub shift_child {
    $opts{child_pid} = fork if (!$opts{child_pid});
    return if ($opts{child_pid});

    # find agents loaded with a key from ~/.ssh/id* for other hosts
    my @agents = glob("$agent_base/ssh-*/agent.*");
    push(@agents, glob("/tmp/ssh-*/agent.*")) if ($agent_base ne "/tmp");
    unshift(@agents, $ENV{SSH_AUTH_SOCK});
    my @host_agents;
    foreach my $agent (@agents) {
        my @stat = stat $agent;
        next if ($stat[4] != $< || ! -S $agent);
        $ENV{SSH_AUTH_SOCK} = $agent;
        my $out = qx(ssh-add -l 2>&1);
        push(@host_agents, $agent) if ($out =~ /\.ssh.id/);
    }
    # restore agent socket
    $ENV{SSH_AUTH_SOCK} = $agent_sock;
    # ensure at least one agent to cover host-based authentication
    push(@host_agents, $agent_sock) if (scalar(@host_agents) == 0);

    # detach process
    close STDIN;
    close STDOUT;
    close STDERR;
    setsid;
    open(STDIN, "</dev/null");
    open(STDOUT, ">/dev/null");
    open(STDERR, ">/dev/null");

    my ($logfh, $log) = sftp_tmp();
    my ($taskfh, $task) = sftp_tmp();
    close $taskfh;

    my $host = fqdn(hostname);
    my $load = {};
    my (@rhost, @rpath);
    my @rop = ('get', 'put');
    my $size;

    # use catchall exception handler to report client failures
    $SIG{__DIE__} = sub {
        our @exception = @_ if (defined $^S && !$^S);
    };
    END {
        our @exception;
        if (@exception) {
            my $text = localtime(time) . ": @exception";
            chomp $text;
            print $logfh "args=getopt,exception text=", escape($text);
            shift_mgr("--id=$opts{id} --host=$host --put", $log, undef, 1440);
        }
    }

    # send file system information
    print $logfh shift_mounts($host);

    TASK: while (1) {
        # add load to results for throttling
        print $logfh shift_load($load, $size, \@rhost, \@rpath), "\n";
        # send client version
        print $logfh "args=getopt,version text=$VERSION\n";
        $size = 0;

        # retrieve next batch for processing
        close $logfh;
        my $out = shift_mgr("--id=$opts{id} --host=$host --pid=$$ --get --put",
            $log, $task, 1440);
        die "$$out\n" if (ref $out);
        #TODO: error checking if id doesn't exist
        open($logfh, '>', $log);

        my $rsize;
        my $run = time;
        my %ops;
        open($taskfh, '<', $task);
        while (my $line = <$taskfh>) {
            $line =~ s/\s*\r?\n$//;
            $_ = $line;
            s/=/ /g;
            my %op = split(/\s+/);
            my @args = split(/,/, $op{args});
            my $cmd = shift @args;
            if ($cmd eq 'client') {
                # check that id is in expected format
                next if ($args[0] !~ /^\d+\.\d+$/);
                my $cmd = $opts{abs0};
                if (basename($opts{abs0}) !~ /^shift/) {
                    $cmd .= " -u $opts{u}" if ($opts{u});
                    $cmd .= " -b -p $opts{p} shift";
                }
                $cmd .= " --mgr=" . escape($opts{mgr}) if ($opts{mgr});
                $cmd .= " --mgr-user=" . escape($opts{"mgr-user"})
                    if ($opts{"mgr-user"});
                $cmd .= " --id=$args[0] --pid=-1 >/dev/null 2>&1";
                my $out = qx($cmd);
                if ($? || $out) {
                    $op{state} = "error";
                    $op{text} = escape("Client spawn '$cmd' failed");
                    print $logfh
                        join(" ", map {"$_=$op{$_}"} sort(keys(%op))) . "\n";
                }
            } elsif ($cmd eq 'getopt') {
                # check validity of option
                if ($args[0] =~ /^(?:local|remote)$/) {
                    FIND: foreach my $t (split(/,/, $op{text})) {
                        foreach my $path (split(/:/, $ENV{PATH})) {
                            if ($t eq 'fish' || -x "$path/$t") {
                                $opts{$args[0]} = $t;
                                last FIND;
                            }
                        }
                    }
                } elsif ($args[0] =~ /^(?:check|create-tar|cron|encrypt|extract-tar|index-tar|no-stripe|offline|preserve|stripe|verify|verify-fast)$/) {
                    $opts{$args[0]} = defined $op{text} ?
                        unescape($op{text}) : 1;
                }
            } elsif ($cmd eq 'host') {
                # check that host is in expected format
                next if ($args[0] !~ /^[\w.-]+$/);
                my $rcmd = "ssh -Axq -oBatchMode=yes $args[0] $opts{base0}";
                if ($opts{base0} !~ /^shift/) {
                    $rcmd .= " -u $opts{u}" if ($opts{u});
                    $rcmd .= " -b -p $opts{p} shift";
                }
                $rcmd .= " --mgr=" . escape($opts{mgr}) if ($opts{mgr});
                $rcmd .= " --mgr-user=" . escape($opts{"mgr-user"})
                    if ($opts{"mgr-user"});
                $rcmd .= " --mgr-identity=" . $opts{"mgr-identity"}
                    if ($opts{"mgr-identity"});
                $rcmd .= " --identity=$opts{identity}" if ($opts{identity});
                $rcmd .= " --user=$opts{user}" if ($opts{user});
                $rcmd .= " --id=$opts{id} --pid=-1 >/dev/null 2>&1";
                my $done;
                foreach my $agent (@host_agents) {
                    $ENV{SSH_AUTH_SOCK} = $agent;
                    my $out = qx($rcmd);
                    if (!$? && !$out) {
                        $done = 1;
                        last;
                    }
                }
                $ENV{SSH_AUTH_SOCK} = $agent_sock;
                if (!$done) {
                    $op{state} = "error";
                    $op{text} = escape("Host spawn '$rcmd' failed");
                    print $logfh
                        join(" ", map {"$_=$op{$_}"} sort(keys(%op))) . "\n";
                }
            } elsif ($cmd eq 'sleep') {
                sleep $args[0];
                next TASK;
            } elsif ($cmd eq 'stop') {
                close $logfh;
                close $taskfh;
                shift_stop();
            } else {
                $ops{$line} = \%op;
                delete $op{state};
                delete $op{text};
                $op{tar_name} = unescape($op{tar_name}) if ($op{tar_name});
                if ($cmd =~ /^(?:c[hk]attr)/) {
                    # chattr index must be -1 since used with both 1 and 2 args
                    my ($rhost, $rpath) = hostpath(unescape($args[-1]));
                    # record original src for tar validation
                    $op{src} = $args[0] if (scalar(@args) > 1);
                    transport($cmd, $rhost, undef, $rpath, \%op);
                } elsif ($cmd eq 'cksum') {
                    my $rindex = 1;
                    my $local = 1;
                    foreach my $i (0..1) {
                        ($rhost[$i], $rpath[$i]) = hostpath(unescape($args[$i]));
                        if ($rhost[$i] ne 'localhost') {
                            $rindex = $i;
                            $local = 0;
                        }
                    }
                    # record if local or not for i/o throttling
                    $op{local} = $local;
                    # record remote host index to determine offset in tar case
                    $op{rindex} = $rindex;
                    transport($cmd, $rhost[$rindex], undef, $rpath[$rindex], \%op);
                    $rsize += $op{size};
                } elsif ($cmd eq 'cp') {
                    my $rindex = 1;
                    foreach my $i (0..1) {
                        ($rhost[$i], $rpath[$i]) = hostpath(unescape($args[$i]));
                        $rindex = $i if ($rhost[$i] ne 'localhost');
                    }
                    transport($rop[$rindex], $rhost[$rindex], $rpath[0], $rpath[1], \%op);
                    $rsize += $op{size};
                } elsif ($cmd eq 'ln') {
                    my ($rhost, $rpath) = hostpath(unescape($args[1]));
                    transport($cmd, $rhost, unescape($args[0]), $rpath, \%op);
                } elsif ($cmd eq 'mkdir') {
                    my ($rhost, $rpath) = hostpath(unescape($args[0]));
                    transport($cmd, $rhost, undef, $rpath, \%op);
                } elsif ($cmd eq 'sum') {
                    my $rindex = 1;
                    foreach my $i (0..1) {
                        ($rhost[$i], $rpath[$i]) = hostpath(unescape($args[$i]));
                        $rindex = $i if ($rhost[$i] ne 'localhost');
                    }
                    # decrement to reverse remote to local
                    $rindex--;
                    # record local host index to determine offset in tar case
                    $op{lindex} = $rindex;
                    transport($cmd, $rhost[$rindex], $rpath[$rindex], undef, \%op);
                    $rsize += $op{size};
                }
            }
        }
        close $taskfh;
        #TODO: error if no ops?

        $size = transport('end');
        my $time = time - $run;
        my $rate = $rsize / ($time ? $time : 1);
        my $lockfh;
        my %sumfh;
        while (my ($op, $ref) = each %ops) {
            $op =~ s/(?:state|text)=\S+\s?//g;
            $op =~ s/\s+$//;
            my $text = $ref->{text};
            my $tool = $ref->{tool};
            $tool = " tool=$tool" if ($tool);
            if ($text =~ s/\\H/,/g) {
                $text =~ s/^,//;
                print $logfh "$op state=done$tool time=$time rate=$rate hash=$text\n";
                $size += $ref->{size};
                if ($opts{'create-tar'} && $opts{'index-tar'} && $opts{verify}) {
                    if (!$lockfh) {
                        $lockfh = shift_mgr("--lock");
                        my $ok = <$lockfh>;
                        #TODO: do something if not "OK"?
                    }
                    my @args = split(/,/, $ref->{args});
                    my $tar = pop @args;
                    my ($thost, $tpath) = hostpath(unescape($tar));
                    $tpath .= ".sum";
                    if (!$sumfh{$tar}) {
                        if ($thost ne 'localhost') {
                            $sumfh{$tar} = sftp($thost)->open($tpath,
                                SFTP_APPEND | SFTP_CREAT | SFTP_WRITE);
                        } else {
                            open($sumfh{$tar}, '>>', $tpath);
                        }
                    }
                    my $tname = $ref->{tar_name};
                    $tname =~ s/(\n|\\)/$1 eq "\n" ? "\\n" : "\\\\"/eg;
                    print {$sumfh{$tar}} "$text  $tname\n";
                }
            } elsif ($text =~ s/\\E//g) {
                print $logfh "$op state=error$tool text=" . escape($text) . "\n";
            } elsif ($text =~ s/\\W//g) {
                print $logfh "$op state=warn$tool text=" . escape($text) . "\n";
            } else {
                print $logfh "$op state=done$tool time=$time rate=$rate\n";
                # rsync size is already included in total
                $size += $ref->{size} if ($ref->{tool} ne 'rsync' &&
                    ($ref->{local} || $op =~ /(?:^|\s)args=(?:cp|sum)/));
            }
        }
        close $lockfh if ($lockfh);
        close $_ foreach (values %sumfh);
    }
    exit;
}

####################
#### shift_init ####
####################
sub shift_init {
    my ($log, $n0, $n) = @_;
    # keep increasing initialization size to start fast and end efficiently
    $opts{init_size} += 10000;
    print STDERR "\nInitializing file operations $n0 to $n\n" if ($opts{v});
    my $host = fqdn(hostname);
    if ($opts{id}) {
        #TODO: may need to execute some other command here
        #TODO: need to be careful about spawning when using sup as
        #      other systems may not have mesh keys
        #TODO: need to be careful about changing target when using sup as
        #      other systems may not have same meshrc
        my $out = shift_mgr("--id=$opts{id} --host=$host --put", $log,
            undef, 10);
        die "$$out\n" if (ref $out);
    } else {
        $opts{id} = shift_mgr("--host=$host --put", $log);
        die "${$opts{id}}\n" if (ref $opts{id});
        $opts{id} =~ s/\s*\r?\n$//;
    }
    # this will either start a child or do nothing if one already started
    shift_child();
}

####################
#### shift_load ####
####################
sub shift_load {
    my ($load, $size, $rhost, $rpath) = @_;

    # find number of cpus on the first call
    if (!defined $load->{cpus}) {
        if ($^O =~ /^(?:linux|cygwin)$/ && open(FILE, "/proc/stat")) {
            while (my $line = <FILE>) {
                $load->{cpus}++ if ($line =~ s/^cpu\d+\s+//);
            }
            close FILE;
        } elsif ($^O eq 'MSWin32') {
        } elsif ($^O =~ /bsd/) {
            $load->{cpus} = qx(sysctl -n hw.ncpu);
        }
        $load->{cpus} =~ s/^\s+|\s+$//g;
        $load->{cpus} = 1 if (!$load->{cpus});
    }

    # clear previous load
    $load->{$_} = 0 foreach (qw(cpu disk io net));

    # update time
    my $time_t = time;
    $load->{time_t} = $time_t if (!defined $load->{time_t});
    $load->{time} = $time_t - $load->{time_t};
    $load->{time} = 1 if ($load->{time} < 1);
    $load->{time_t} = $time_t;

    # update cpu load
    if ($^O ne 'MSWin32') {
        my $cpu = qx(ps S -o %cpu -p $$);
        $load->{cpu} = $1 if ($cpu =~ /%CPU\s*([\d.]+)/);
        # adjust percentage for number of cpus
        $load->{cpu} /= $load->{cpus};
    }

    # compute process i/o and network load and total disk usage
    #TODO: this is doesn't handle the case when there are multiple
    #      destination file systems as could happen with link
    #      dereferencing since only last op is examined
    if (scalar(@{$rpath}) > 0) {
        # convert size to MBs
        $size /= 1E6;
        $load->{io} = int($size / $load->{time});
        if ($rhost->[0] ne 'localhost' || $rhost->[1] ne 'localhost') {
            # only define net if remote host was accessed
            $load->{net} = int($size / $load->{time});
        } else {
            # double the i/o load if local copy
            $load->{io} *= 2;
        }

        my $ref = {};
        vdf($ref, $rhost->[-1], $rpath->[-1], {-argv => []});
        $load->{disk} = $1 if ($ref->{text} =~ /(\d+)%/);
    }

    return "args=load " .
        join(" ", map {"$_=$load->{$_}"} qw(cpu disk io net time));
}

###################
#### shift_mgr ####
###################
sub shift_mgr {
    my ($cmd, $stdin, $stdout, $retry) = @_;
    my $lock = $cmd eq '--lock' ? 1 : 0;
    $cmd = "$opts{cmgr} $cmd";
    if ($opts{mgr} ne 'none') {
        if ($opts{p} eq $opts{mgr}) {
            $cmd = "$opts{sshmp}$cmd";
        } elsif ($opts{mgr}) {
            my $extra;
            $extra .= " -l " . $opts{"mgr-user"} if ($opts{"mgr-user"});
            $extra .= " -i " . $opts{"mgr-identity"} if ($opts{"mgr-identity"});
            $cmd = "ssh -Aqx -oBatchMode=yes $extra $opts{mgr} $cmd";
        }
    }
    $cmd = "su " . $opts{"mgr-user"} . " -c '$cmd'"
        if ($< == 0 && $opts{"mgr-user"} && !$opts{"mgr-identity"});
    if ($lock) {
        my $fh;
        open($fh, '|-', "$cmd 2>/dev/null");
        return $fh;
    }
    $cmd .= " <$stdin" if ($stdin);
    $cmd .= " >$stdout" if ($stdout);
    my $start = time;
    my $err;
    do {
        my $tmp = sftp_tmp();
        my $out = qx($cmd 2>$tmp);
        my $rc = WEXITSTATUS($?);
        if ($rc) {
            open(ERR, '<', $tmp);
            $err .= $_ while (<ERR>);
            chomp $err;
            close ERR;
        }
        unlink $tmp;
        return $out if (!$rc);
    } while ($retry && time < $start + $retry * 60 && sleep 60);
    #TODO: more error checking to determine correct action
    return \"Unable to execute \"$cmd\": $err";
    #TODO: needs to stop on its own at some point
    #          (e.g. key is expired and can't generate new key)
}

######################
#### shift_mounts ####
######################
sub shift_mounts {
    my $host = shift;
    my %mnt = (
        host => $host,
        args => "mount",
    );
    my $mnts;

    print STDERR "Updating file system information\n" if ($opts{v});

    # gather file system information from mount
    open(FILE, '-|', "mount 2>/dev/null");
    while (<FILE>) {
        $mnt{opts} = /[\(,]ro[\),]/ ? "ro" : "rw";
        $mnt{opts} .= ",dmi" if (/[\(,]dmi[\),]/);
        #TODO: need to escape local and remote?
        (my $dev, $mnt{local}, $mnt{type}) = ($1, $2, $3)
            if (/(\S+)\s+on\s+(\S+)\s+type\s+(\S+)/);
        if ($mnt{local}) {
            # try to avoid NFS hangs by resolving dir but not base
            my ($base, $dir) = fileparse($mnt{local});
            $dir = abs_path($dir);
            $dir =~ s/\/$//;
            $mnt{local} = "$dir/$base";
        }
        if (/server_list=\(([^\)]+)\)/) {
            # cxfs appears as xfs but with server_list set
            $mnt{servers} = join(",", map {$_ = fqdn($_)} split(/,/, $1));
            $mnt{type} = "cxfs";
            $mnt{remote} = $mnt{local};
        } elsif (/^(\S+):(\S+)/) {
            # typical form for nfs
            $mnt{remote} = $2;
            $mnt{servers} = $1;
            $mnt{servers} =~ s/@.*//;
            $mnt{servers} = fqdn($mnt{servers});
        } elsif ($mnt{type} eq 'gpfs') {
            # gpfs servers do not appear in mount output so call mmlsmgr
            my $srv = qx(mmlsmgr $dev);
            # try a default location if not in path
            $srv = qx(/usr/lpp/mmfs/bin/mmlsmgr $dev) if (!$srv);
            next if (!defined $srv);
            # output is file system then server ip address
            if ($srv =~ /^(\w+)\s+(\d+\.\d+\.\d+\.\d+)/m) {
                $mnt{remote} = "/$1";
                $mnt{servers} = fqdn($2);
            }
        } elsif ($mnt{opts} =~ /,dmi/) {
            # always report dmi file systems even if local
            $mnt{servers} = $mnt{host};
            $mnt{remote} = $mnt{local};
        } else {
            # ignore local file systems
            next;
        }
        # store hash in single line with space-separated key=val form
        $mnts .= join(" ", map {"$_=$mnt{$_}"} sort(keys(%mnt))) . "\n";
    }
    close FILE;

    # check if host under PBS control
    my $pbs;
    open(FILE, '-|', "ps -uroot -ocommand 2>/dev/null");
    while (<FILE>) {
        if (/(?:^|\/)pbs_mom(?:\s|$)/) {
            $pbs = 1;
            last;
        }
    }
    close FILE;

    # indicate that system is accessible
    $mnts .= "args=shell host=$host" . ($pbs ? " pbs=1" : "") . "\n";
    return $mnts;
}

####################
#### shift_stop ####
####################
sub shift_stop {
    # crontab not used when cron disabled or extra clients
    exit if (!$opts{cron} || $opts{id} =~ /\D/);
    # remove crontab
    my $tab;
    if (open(TAB, '-|', "crontab -l 2>/dev/null")) {
        while (<TAB>) {
            # ignore garbage added by crontab
            next if (/^#.*(?:edit the master|installed on|Cron version)/);
            $tab .= $_;
        }
        close TAB;
    }
    if (defined $tab && $tab =~ /\Q$opts{abs0}\E[^\r\n]*\s+--id=$opts{id}\s+/) {
        $tab =~ s/\r?\n[^\r\n]+\Q$opts{abs0}\E[^\r\n]*\s+--id=$opts{id}\s+[^\r\n]+\r?\n//s;
        my ($fh, $file) = tempfile();
        print $fh $tab;
        close $fh;
        qx(crontab $file 2>&1);
        unlink $file;
    }
    exit;
}

####################
#### stderr_off ####
####################
# save stderr and redirect to /dev/null
my @stderrs;
sub stderr_off {
    my $fh;
    open($fh, '>&', \*STDERR);
    push(@stderrs, $fh);
    open(STDERR, ">/dev/null");
}

###################
#### stderr_on ####
###################
# restore stderr from saved copy
sub stderr_on {
    my $fh = pop @stderrs;
    return if (!$fh);
    open(STDERR, '>&', $fh);
    close $fh;
}

####################
#### tar_create ####
####################
sub tar_create {
    my ($host, $path, $tsplit_ref, $ifh_ref, $tsize_ref,
        $type, $file, $size, $attrs) = @_;
    my $ifh = $$ifh_ref;
    my $bytes;
    my $ext = $$tsplit_ref ? "-$$tsplit_ref.tar" : "";

    if (defined $type) {
        if ($$tsize_ref == 0 && $opts{'index-tar'}) {
            # open index file
            if ($host ne 'localhost') {
                $ifh = sftp($host)->open("$path$ext.toc",
                    SFTP_WRITE | SFTP_CREAT)
            } else {
                open($ifh, '>', "$path$ext.toc");
            }
            $$ifh_ref = $ifh;
        }

        my @attrs = split(/,/, $attrs);
        my $ln;
        $ln = $1 if ($type =~ /^ln:(.*)/);
        $size = 0 if ($type ne 'cp');
        my $user = unescape($attrs[5]);
        my $group = unescape($attrs[6]);

        if ($ln && length($ln) > 100) {
            die "Link $ln too long for ustar tar format\n";
        } elsif (length($file) > 100) {
            my $pos = index($file, "/", length($file) - 100);
            die "Name $file too long for ustar tar format\n" if ($pos == -1);
        } elsif (length($user) > 32) {
            die "User name $user too long for ustar tar format\n";
        } elsif (length($group) > 32) {
            die "Group name $group too long for ustar tar format\n";
        }

        if ($opts{'index-tar'}) {
            print $ifh sprintf("%1s%9s %7s %7s %9d %12s %s\n",
                $type eq 'mkdir' ? "d" : ($type eq 'cp' ? " " : "l"),
                sftp_ls_mode($attrs[0]), $user, $group, $size,
                strftime("%b %d  %Y", localtime $attrs[4]),
                $ln ? "$file -> $ln" : $file);
        }

        $$tsize_ref += 512;
        $bytes = "$$tsize_ref-";
        $$tsize_ref += $size;
        $bytes .= $$tsize_ref;
        $$tsize_ref += (512 - ($size % 512))
            if ($size > 0 && $size % 512 > 0);
    }

    if (!defined $type ||
            $$tsize_ref > 0 && $$tsize_ref >= $opts{'split-tar'}) {
        # tar has become greater than tar split size
        my $tarfh;
        # attempt to stripe in case file system is lustre
        my $stripes = $opts{stripe} < 1000 ? $opts{stripe} :
            int($$tsize_ref / $opts{stripe}) + 1;
        if ($host ne 'localhost') {
            if ($stripes > 1 || 0 < $opts{stripe} && $opts{stripe} < 1000) {
                # only stripe large files or a specific number of stripes
                open(SIN, '|-',
                    "$opts{ssh} $host $opts{caux} setstripe >/dev/null 2>&1");
                print SIN "$path$ext $stripes\n";
                close SIN;
            }
            $tarfh = sftp($host)->open("$path$ext", SFTP_WRITE | SFTP_CREAT);
        } else {
            if ($stripes > 1 || 0 < $opts{stripe} && $opts{stripe} < 1000) {
                # only stripe large files or a specific number of stripes
                stderr_off();
                open(SOUT, '-|', "lfs", "setstripe", "-c", $stripes, "$path$ext");
                close SOUT;
                stderr_on();
            }
            sysopen($tarfh, "$path$ext", O_WRONLY | O_CREAT);
        }
        if (!$tarfh) {
            die "Unable to open tar file $path$ext\n";
        } else {
            close $tarfh;
        }

        # close index file
        close $ifh if ($opts{'index-tar'});

        # move to next split and reset tar size
        $$tsplit_ref++;
        $$tsize_ref = 0;
    }

    return $bytes;
}

#####################
#### tar_extract ####
#####################
# based on Tar/Archive::Tar 0.07 by Calle Dybedahl (no license specified)
sub tar_extract {
    my ($src, $dst, $logfh_ref, $log, $meter, $nfiles, $ndirs, $n0, $host) = @_;
    my $logfh = $$logfh_ref;

    my $fh;
    my ($shost, $spath) = hostpath($src);
    if ($shost ne 'localhost') {
        $fh = sftp($shost)->open($spath, SFTP_READ);
    } else {
        $fh = undef if (!open($fh, '<', $src));
    }
    if (!$fh) {
        print STDERR "Unable to open tar file $src\n";
        return;
    }

    binmode $fh;
    my %real;
    my $head;
    read($fh, $head, 512);
    while (length($head) == 512) {
        # end of archive is two blocks of 512 but GNU tar uses one sometimes
        return if ($head eq "\0" x 512);

        # uid, gid, and size must be 'a' instead of 'A' for base-256 encoding
        my @attrs = unpack('A100A8a8a8a12A12A8A1A100A6A2A32A32A8A8A155', $head);
        # name mode uid gid size time sum type lnk mgc ver unam gnam dmj dmn pfx
        #  0    1    2   3   4    5    6   7    8   9   10  11   12   13  14  15

        # prepend prefix to name
        if ($attrs[15]) {
            $attrs[0] = $attrs[15] . "/" . $attrs[0];
            $attrs[15] = "";
        }
        # remove last non-standalone slash
        $attrs[0] =~ s/(?!^)\/$//;

        if (!$attrs[0]) {
            print STDERR "Empty file name in tar file $src\n";
            return;
        }
        if ($attrs[9] ne 'ustar') {
            print STDERR "Tar file $src not in supported ustar format\n";
            return;
        }

        # convert octal numeric fields
        $attrs[$_] = oct($attrs[$_]) foreach (1, 5, 6, 13, 14);

        # handle GNU large uid/gid/size extension (two's-complement base-256)
        foreach my $i (2..4) {
            if (substr($attrs[$i], 0, 1) eq "\x80") {
                my $val = ord(substr($attrs[$i], 1, 1)) & 0xff;
                for (2..($i == 4 ? 11 : 7)) {
                    $val <<= 8;
                    $val |= (ord(substr($attrs[$i], $_, 1)) & 0xff);
                }
                $attrs[$i] = $val;
            } else {
                $attrs[$i] = oct $attrs[$i];
            }
        }

        # validate checksum
        substr($head, 148, 8) = "        ";
        if (unpack("%16C*", $head) != $attrs[6]) {
            print STDERR "Invalid tar header checksum for $attrs[0]\n";
            return;
        }

        # handle GNU long names
        if ($attrs[7] =~ /^[LK]$/) {
            do {
                # read next header
                read($fh, $head, 512);
                # remove the extra byte used for \0
                $head = substr($head, 0, $attrs[4] - 1) if ($attrs[4] < 512);
                $real{$attrs[7]} .= $head;
                $attrs[4] -= 512;
            } while ($attrs[4] > 0);
            # read next header
            read($fh, $head, 512);
            next;
        }

        # find next header
        my $offset = tell($fh);
        if (!seek($fh, $attrs[4], 1)) {
            print STDERR "Unable to seek in tar file $src\n";
            return;
        }
        my $diff = $attrs[4] % 512;
        # ignore padding
        if ($diff != 0 && !seek($fh, 512 - $diff, 1)) {
            print STDERR "Unable to ignore padding in tar file $src\n";
            return;
        }

        # read next header
        read($fh, $head, 512);

        if ($real{L}) {
            $attrs[0] = $real{L};
            $real{L} = undef;
        }
        if ($real{K}) {
            $attrs[8] = $real{K};
            $real{K} = undef;
        }

        my $udst = $attrs[0];
        substr($udst, 0, 0) = "/" if ($udst !~ /^\//);
        $udst = escape($dst . $udst);

        # print operation and stat info separated by commas
        if ($attrs[7] eq '2') {
            print $logfh "args=ln,", escape($attrs[8]), ",$udst";
            $$nfiles++;
        } elsif ($attrs[7] eq '5') {
            print $logfh "args=mkdir,$udst";
            $$ndirs++;
        } elsif ($attrs[7] eq '0') {
            print $logfh "args=cp,", escape($src), ",$udst";
            $$nfiles++;
        } else {
            # unsupported file type (e.g. pipes, devices, etc.)
            next;
        }
        print $logfh " host=$host size=$attrs[4] attrs=", join(",",
            @attrs[1,2,3,5,5], escape($attrs[11]), escape($attrs[12]),
            $attrs[4]);
        my $bytes = $offset . "-" . ($offset + $attrs[4]);
        print $logfh " bytes=$bytes tar_bytes=$bytes\n";

        # update meter
        print "\e[" . length($$meter) . "D";
        $$meter = "$$ndirs/$$nfiles";
        print $$meter;
        if ($$ndirs + $$nfiles - $$n0 >= $opts{init_size}) {
            close $logfh;
            shift_init($log, $$n0, $$ndirs + $$nfiles);
#TODO: what about errors after child forked?  Must stop processing
            open($logfh, '>', $log);
            $$n0 = $$ndirs + $$nfiles;
        }
 
    }
    close $fh;
}

####################
#### tar_record ####
####################
# based on Tar/Archive::Tar 0.07 by Calle Dybedahl (no license specified)
# checks for ustar limitations have already been done by this point
sub tar_record {
    my ($fh, $type, $src, $ref) = @_;
    my @attrs = split(/,/, $ref->{attrs});
    my $file = $ref->{tar_name};

    my ($ttype, $size, $ln);
    if ($type eq 'ln') {
        $ln = $src;
        $size = 0;
        $ttype = 2;
    } elsif ($type eq 'mkdir') {
        $file .= "/";
        $size = 0;
        $ttype = 5;
    } else {
        # use attrs value instead of size, which changes with --split
        $size = $attrs[7];
        $ttype = 0;
    }

    my ($head, $prefix, $pos);
    if (length($file) > 100) {
        $pos = index($file, "/", length($file) - 100);
        if ($pos == -1) {
            # should never enter this due to prechecks but just in case
            sftp_error($ref, "File '$file' too long for ustar tar format");
            return;
        }
        $prefix = substr($file, 0, $pos);
        $file = substr($file, $pos + 1);
        substr($prefix, 0, -155) = "" if (length($prefix) > 154);
    }

    # use GNU large uid/gid/size extension (two's-complement base-256)
    my ($uid256, $gid256, $size256);
    if ($attrs[1] > 2097151) {
        my $val = $attrs[1];
        foreach (1..7) {
            $uid256 = chr($val & 0xff) . $uid256;
            $val >>= 8;
        }
        $uid256 = "\x80" . $uid256;
    }
    if ($attrs[2] > 2097151) {
        my $val = $attrs[2];
        foreach (1..7) {
            $gid256 = chr($val & 0xff) . $gid256;
            $val >>= 8;
        }
        $gid256 = "\x80" . $gid256;
    }
    if ($size > 8589934591) {
        my $val = $size;
        foreach (1..11) {
            $size256 = chr($val & 0xff) . $size256;
            $val >>= 8;
        }
        $size256 = "\x80" . $size256;
    }

    my $head = pack("a100a8a8a8a12a12a8a1a100",
        $file,
        sprintf("%07o\0", $attrs[0]),
        $uid256 ? $uid256 : sprintf("%07o\0", $attrs[1]),
        $gid256 ? $gid256 : sprintf("%07o\0", $attrs[2]),
        $size256 ? $size256 : sprintf("%011o\0", $size),
        sprintf("%011o\0", $attrs[4]),
        "        ",
        $ttype,
        $ln,
    );
    $head .= pack("a6", "ustar\0");
    $head .= "00";
    $head .= pack("a32", unescape($attrs[5]));
    $head .= pack("a32", unescape($attrs[6]));
    # no handling for major/minor dev so use zero
    $head .= pack("a8", sprintf("%07o\0", 0));
    $head .= pack("a8", sprintf("%07o\0", 0));
    $head .= pack("a155", $prefix);
    # compute checksum
    substr($head, 148, 6) = sprintf("%06o", unpack("%16C*", $head));
    substr($head, 154, 1) = "\0";
    # add header padding
    $head .= "\0" x (512 - length($head));

    my ($seek, $end) = split(/-/, $ref->{tar_bytes});
    $seek -= 512;
    if (!seek($fh, $seek, 0)) {
        sftp_error($ref, "Unable to seek tar file to header");
        return;
    } elsif (!$fh->print($head)) {
        sftp_error($ref, "Unable to write tar record header");
        return;
    }

    # add file padding if needed
    if ($size > 0 && $size % 512 > 0) {
        if (!seek($fh, $size, 1)) {
            sftp_error($ref, "Unable to seek tar file to padding");
            return;
        } elsif (!$fh->print("\0" x (512 - ($size % 512)))) {
            sftp_error($ref, "Unable to write tar record padding");
            return;
        }
        $end += 512 - ($size % 512);
    }

    if ($ref->{tar_last}) {
        # add two full zero records to end of tar file
        if (!seek($fh, $end, 0)) {
            sftp_error($ref, "Unable to seek tar file to final record");
            return;
        } elsif (!$fh->print("\0" x 1024)) {
            sftp_error($ref, "Unable to write tar final zero records");
            return;
        }
        $end += 1024;
        # pad out final block to full length (multiple of 10k)
        my $zeros = $end % 10240;
        if ($zeros && !$fh->print("\0" x (10240 - $zeros))) {
            sftp_error($ref, "Unable to write tar final zero blocks");
            return;
        }
    }
}

######################
#### tar_validate ####
######################
sub tar_validate {
    my ($fh, $ref) = @_;
    my ($seek, $end) = split(/-/, $ref->{tar_bytes});
    $seek -= 512;
    my $head;
    if (!seek($fh, $seek, 0)) {
        sftp_error($ref, "Unable to seek tar file to header");
        return 0;
    } elsif (!read($fh, $head, 512)) {
        sftp_error($ref, "Unable to read tar record header");
        return 0;
    }

    # uid, gid, and size must be 'a' instead of 'A' for base-256 encoding
    my @attrs = unpack('A100A8a8a8a12A12A8A1A100A6A2A32A32A8A8A155', $head);
    my $sum = oct $attrs[6];

    # validate checksum
    substr($head, 148, 8) = "        ";
    if (unpack("%16C*", $head) != $sum) {
        sftp_error($ref, "Invalid tar header checksum");
        return 0;
    }

    # handle GNU large size extension (two's-complement base-256)
    my $size = $attrs[4];
    if (substr($size, 0, 1) eq "\x80") {
        my $val = ord(substr($size, 0, 1)) & 0xff;
        for (1..11) {
            $val = ($val << 8) + (ord(substr($size, $_, 1)) & 0xff);
        }
        $size = $val;
    } else {
        $size = oct $size;
    }

    # check file padding
    if ($size > 0 && $size % 512 > 0) {
        my $pad;
        if (!seek($fh, $size, 1)) {
            sftp_error($ref, "Unable to seek tar file to padding");
            return 0;
        } elsif (!read($fh, $pad, 512 - ($size % 512))) {
            sftp_error($ref, "Unable to read tar record padding");
            return 0;
        } elsif ($pad ne "\0" x (512 - ($size % 512))) {
            sftp_error($ref, "Invalid tar record padding");
            return 0;
        }
        $end += 512 - ($size % 512);
    }

    # check archive padding
    if ($ref->{tar_last}) {
        my $pad;
        if (!seek($fh, $end, 0)) {
            sftp_error($ref, "Unable to seek tar file to final record");
            return 0;
        } elsif (!read($fh, $pad, 1024)) {
            sftp_error($ref, "Unable to read tar final zero records");
            return 0;
        } elsif ($pad ne "\0" x 1024) {
            sftp_error($ref, "Invalid tar final zero records");
            return 0;
        }
        $end += 1024;
        my $zeros = $end % 10240;
        $zeros = 10240 - $zeros if ($zeros);
        if ($zeros && !read($fh, $pad, $zeros)) {
            sftp_error($ref, "Unable to read tar final zero blocks");
            return 0;
        } elsif ($zeros && $pad ne "\0" x $zeros) {
            sftp_error($ref, "Invalid tar final zero blocks");
            return 0;
        }
    }

    # return true only if checksum and padding are correct
    return 1;
}

###################
#### transport ####
###################
my %tcmds;
sub transport {
    my ($op, $host, $src, $dst, $ref) = @_;
    my $rsize;
    if ($op eq 'end' && !defined $host) {
        my @hosts = keys %tcmds;
        # localhost must be first to create directories
        $rsize += transport($op, 'localhost') if (grep(/^localhost$/, @hosts));
        foreach $host (keys %tcmds) {
            $rsize += transport($op, $host) if ($host ne 'localhost');
        }
        return $rsize;
    } elsif ($op eq 'end') {
        transport_chattr($host, $tcmds{$host});
        transport_dmf($host, $tcmds{$host});
        transport_lustre($host, $tcmds{$host});
        transport_tar($host, $tcmds{$host});
    }
    if ($op eq 'end' && ($host eq 'localhost' && $opts{local} eq 'rsync' ||
            $host ne 'localhost' && $opts{remote} eq 'rsync')) {
        # rsync can do both local and remote copies
        my %errs;
        my ($fh, $tmp) = sftp_tmp();
        my $sep = chr(0);
        my ($shost, $spath, $dhost, $dpath, $args);
        if ($host eq 'localhost') {
            $shost = "";
            $dhost = "";
        } else {
            $args = " -e '$opts{ssh}'";
        }
        my $dmf = 0;
        my @fish;
        foreach my $cmd (@{$tcmds{$host}}) {
            ($op, $src, $dst, $ref) = @{$cmd};
            if ($op !~ /^(?:get|put)$/ || $ref->{bytes}) {
                if ($host ne 'localhost' && $op =~ /^(?:get|put)$/) {
                    push(@fish, $cmd);
                } else {
                    transport_default($host, $cmd);
                }
                next;
            }
            if (!$dmf && $ref->{dmi} =~ /dst/) {
                $dmf = 1;
                # copy whole files to DMF to avoid destination reads/recalls
                $args .= " -W";
            }
            $ref->{tool} = "rsync";
            if (!defined $shost) {
                $shost = $op eq 'get' ? "$host:" : "";
                $dhost = $op eq 'put' ? "$host:" : "";
            }
            # find longest common suffix starting with "/"
            if ("$src$sep$dst" =~ /^.*?(\/.*)$sep.*\1$/) {
                my $lcs = $1;
                if ($spath && $src eq "$spath$lcs" && $dst eq "$dpath$lcs") {
                    print $fh "$lcs\n";
                    push(@{$errs{"$spath$lcs"}}, $ref);
                    push(@{$errs{"$dpath$lcs"}}, $ref);
                    # track temporary dst name for permission errors
                    $errs{dirname("$dpath$lcs") . "/." .
                        basename("$dpath$lcs") . ".XXXXXX"} = $ref;
                    next;
                } elsif ($spath) {
                    # next file has different prefix so process current batch
                    close $fh;
                    $rsize += transport_rsync($args, $tmp,
                        "$shost$spath", "$dhost$dpath", \%errs);
                    %errs = ();
                    open($fh, '>', $tmp);
                }
                print $fh "$lcs\n";
                $spath = $src;
                # escape lcs in case it contains regex characters
                $spath =~ s/\Q$lcs\E$//;
                $dpath = $dst;
                $dpath =~ s/\Q$lcs\E$//;
                push(@{$errs{"$spath$lcs"}}, $ref);
                push(@{$errs{"$dpath$lcs"}}, $ref);
                # track temporary dst name for permission errors
                my $dst_tmp = dirname("$dpath$lcs") . "/." .
                    basename("$dpath$lcs") . ".XXXXXX";
                push(@{$errs{$dst_tmp}}, $ref);
            } else {
                # no common suffix implies single file copy with rename
                # or symlink dereference
                my %errs_tmp;
                # use different hash as other files may already be in there
                $errs_tmp{$src} = [$ref];
                $errs_tmp{$dst} = [$ref];
                # track temporary dst name for permission errors
                my $dst_tmp = dirname($dst) . "/." . basename($dst) . ".XXXXXX";
                $errs{$dst_tmp} = [$ref];
                $rsize += transport_rsync($args, "",
                    "$shost$src", "$dhost$dst", \%errs_tmp);
            }
        }
        close $fh;
        if ($spath) {
            $rsize += transport_rsync($args, $tmp,
                "$shost$spath", "$dhost$dpath", \%errs);
        }
        unlink $tmp;
        transport_fish($host, \@fish) if (scalar(@fish) > 0);
    } elsif ($op eq 'end' && $host eq 'localhost') {
        if ($opts{local} eq 'mcp') {
            my %emap = ("'" => "'", 0 => "\0", a => "\a", b => "\b", f => "\f",
                n => "\n", r => "\r", t => "\t", v => "\v", '\\' => "\\");
            my %errs;
            my ($fh, $tmp) = sftp_tmp();
            my $partial = 0;
            foreach my $cmd (@{$tcmds{$host}}) {
                ($op, $src, $dst, $ref) = @{$cmd};
                if ($op =~ /^(?:get|put)$/) {
                    print $fh escape($src), " ", escape($dst);
                    my $bytes = $ref->{bytes};
                    if ($ref->{bytes}) {
                        my @attrs = split(/,/, $ref->{attrs});
                        my @stat = $opts{'create-tar'} ? () : stat $dst;
                        if ($opts{'create-tar'}) {
                            # copy full src to range of dst
                            my ($t1, $t2) = split(/-/, $ref->{tar_bytes});
                            my $prefix = " ";
                            foreach my $range (split(/,/, $ref->{bytes})) {
                                my ($x1, $x2) = split(/-/, $range);
                                # adjust src by tar start offset
                                $bytes = ($x1 - $t1) . "-" . ($x2 - $t1);
                                print $fh $prefix, $bytes;
                                # prefix is ' ' initially, then ',' for the rest
                                $prefix = ",";
                            }
                            print $fh " $t1";
                        } elsif ($opts{'extract-tar'}) {
                            # copy src range to start of dst
                            my ($t1, $t2) = split(/-/, $ref->{tar_bytes});
                            my $prefix = " ";
                            foreach my $range (split(/,/, $ref->{bytes})) {
                                my ($x1, $x2) = split(/-/, $range);
                                $bytes = "$x1-$x2";
                                print $fh $prefix, $bytes;
                                # prefix is ' ' initially, then ',' for the rest
                                $prefix = ",";
                                if ($x2 - $t1 == $attrs[7] &&
                                        $stat[7] > $attrs[7]) {
                                    # truncate dst if last split
                                    truncate($dst, $attrs[7]);
                                }
                            }
                            # adjust dst by tar start offset
                            print $fh " -$t1";
                        } else {
                            foreach my $range (split(/,/, $ref->{bytes})) {
                                my ($x1, $x2) = split(/-/, $range);
                                if ($x2 == $attrs[7] && $stat[7] > $attrs[7]) {
                                    # truncate dst if last split
                                    truncate($dst, $attrs[7]);
                                }
                            }
                            print $fh " $ref->{bytes}";
                        }
                    }
                    if ($ref->{split}) {
                        # need to track by split instead of file
                        push(@{$errs{"$dst bytes=$bytes"}}, $ref);
                        push(@{$errs{"$src bytes=$bytes"}}, $ref);
                    } else {
                        push(@{$errs{$dst}}, $ref);
                        push(@{$errs{$src}}, $ref);
                    }
                    print $fh "\n";
                    $ref->{tool} = "mcp";
                } else {
                    transport_default($host, $cmd);
                }
            }
            close $fh;
            if (scalar(keys %errs)) {
                my $out_tmp = sftp_tmp();
                my $err_tmp = sftp_tmp();
                my $extra = $opts{"verify-fast"} ?
                    "--print-hash --check-tree" : "";
                my $stripes = $opts{stripe} < 1000 ? $opts{stripe} :
                    ($opts{stripe} / 1E9) . "s";
                if (!$opts{'no-stripe'}) {
                    $stripes = ($opts{stripe} / 1E9) . "l"
                        if ($opts{'extract-tar'} && $opts{stripe} >= 1000);
                    $extra .= " --stripe-count=$stripes";
                }
                $extra .= " --print-src" if ($opts{'create-tar'});
                # must keep write access to handle warnings/corruption
                system("mcp $extra --skip-chmod -P --threads=8 --double-buffer --read-stdin <$tmp >$out_tmp 2>$err_tmp");

                if (open(ERR, '<', $err_tmp)) {
                    while (my $line = <ERR>) {
                        $line =~ s/\r?\n$//;
                        # any number of non-' or odd-\ with ' followed by
                        # non-' and non-\ or even-\ or odd-\ with '
                        while ($line =~ /`((?:[^']|[^'\\](\\\\)*\\')*(?:[^'\\]|[^'\\](\\\\)*|[^'\\](\\\\)*\\'))'/g) {
                            my $file = $1;
                            $file =~ s/\\([abfnrtv'\\])/$emap{$1}/g;
                            my @keys = grep(/^\Q$file\E( bytes=\d+-\d+)?$/,
                                keys(%errs));
                            foreach my $key (@keys) {
                                $_->{text} = "\\E$line" foreach (@{$errs{$key}});
                            }
                        }
                    }
                    close ERR;
                }
                unlink $err_tmp;

                if ($opts{"verify-fast"}) {
                    if (open(OUT, '<', $out_tmp)) {
                        while (<OUT>) {
                            s/\r?\n$//;
                            if (/^(\S+)\s.(.*)/) {
                                my ($hash, $file) = ($1, $2);
                                # eliminate extra \ in files with \\ or \n
                                $file =~ s/\\([\\n])/$1 eq "n" ? "\n" : "\\"/eg
                                    if ($hash =~ /(^|#)\\/);
                                my $ref = $errs{$file}->[0];
                                $ref = $errs{"$file bytes=$1-$2"}->[0]
                                    if (!ref $ref && $hash =~ /^#mutil#(\d+)-(\d+)#/);
                                # skip if ref not found or error already recorded
                                next if (!ref $ref || $ref->{text} =~ /^\\E/);
                                # record hash in error ref
                                $ref->{text} .= "\\H$hash";
                            }
                        }
                        close OUT;
                    }
                }
                unlink $out_tmp;
            }
            unlink $tmp;

            transport_default($host, $_, 1) foreach (@{$tcmds{$host}});
        } else {
            transport_default($host, $_) foreach (@{$tcmds{$host}});
        }
    } elsif ($op eq 'end') {
        if ($opts{remote} eq 'bbftp' && !$opts{encrypt}) {
            # skip bbftp with --encrypt since data channels are unencrypted
            my %errs;
            my ($fh, $tmp) = sftp_tmp();
            # must keep write access to handle warnings/corruption
            print $fh "setoption nokeepmode\n";
            print $fh "setrecvwinsize 4096\n";
            print $fh "setsendwinsize 4096\n";
            print $fh "setbuffersize 4096\n";
            my @fish;
            foreach my $cmd (@{$tcmds{$host}}) {
                ($op, $src, $dst, $ref) = @{$cmd};
                if ($op eq 'rget') {
                    sftp($host)->find($src,
                        follow_links => 1,
                        wanted => sub {
                            if (S_ISDIR($_[1]->{a}->perm)) {
                                my $rdst = $_[1]->{filename};
                                $rdst =~ s/^\Q$src\E\/?//;
                                $rdst = "$dst/$rdst";
                                my $s = "mget $_[1]->{filename}/* $rdst";
                                print $fh "$s\n";
                                $errs{$s} = $ref;
                           }
                           return undef;
                        });
                } elsif ($op eq 'rput') {
                    find({follow_fast => 1, follow_skip => 2, no_chdir => 1,
                        wanted => sub {
                            if (-d $_) {
                                my $rdst = $_;
                                $rdst =~ s/^\Q$src\E\/?//;
                                $rdst = "$dst/$rdst";
                                my $s = "mput $_/* $rdst";
                                print $fh "$s\n";
                                $errs{$s} = $ref;
                            }
                        }}, $src);
                } elsif ($op =~ /^(?:get|put)$/ && !$ref->{bytes} &&
                        "$src$dst" !~ /\s/) {
                    # bbftp cannot handle spaces in file names
                    my $s = "$op $src $dst";
                    print $fh "$s\n";
                    $errs{$s} = $ref;
                    $ref->{tool} = "bbftp";
                } elsif ($op =~ /^(?:get|put)$/) {
                    push(@fish, $cmd);
                } else {
                    transport_default($host, $cmd);
                }
            }
            close $fh;
            transport_fish($host, \@fish) if (scalar(@fish) > 0);
            if (scalar(keys %errs)) {
                my $extra = $opts{p} eq 'none' ? "-p 2" : "-p 8";
                my $out = qx(bbftp $extra -L "$opts{ssh}" -i $tmp $host 2>&1);
                $out =~ s/Child starting\s*//g;
                if (! -f "$tmp.res" && $out =~ /BBFTP-ERROR-(\d+)/) {
                    my $code = $1;
                    my $type = ($code <= 30 || $code > 70 &&
                        $code <= 90 || $code >= 100) ? "\\E" : "\\W";
                    foreach my $op (keys %errs) {
#TODO: this needs work as error may be related to only one file
#      ?? if so, need an example of this...
                        $errs{$op}->{text} = "$type$out";
                    }
                } else {
                    my @lines = split(/\s*\n\s*/, $out);
                    if (open(FILE, '<', "$tmp.res")) {
                        my $i = 0;
                        while (<FILE>) {
                            next if (/Child starting/);
                            if (/(.*)\s+FAILED$/) {
                                my $op = $1;
                                # ignore option failure
                                next if (!$errs{$op});
                                my $type = "\\E";
                                if ($lines[$i] =~ /BBFTP-ERROR-(\d+)/) {
                                    my $code = $1;
                                    $type = "\\W"
                                        if ($code > 30 && $code <= 70 ||
                                            $code > 90 && $code < 100);
                                }
                                $errs{$op}->{text} = "$type$lines[$i]";
                                $i++;
                            } elsif (/(.*)\s+OK$/) {
                                my $op = $1;
                                # ignore option success
                                next if (!$errs{$op});
                                $errs{$op}->{text} = 0;
                            }
                        }
                        close FILE;
                    }
                }
                unlink "$tmp.res";
                foreach my $op (keys %errs) {
                    if (!defined $errs{$op}->{text}) {
                        sftp_error($errs{$op},
                            "bbftp failure: " . substr($out, 0, 256));
                    }
                }
            }
            unlink $tmp;
            transport_default($host, $_, 1) foreach (@{$tcmds{$host}});
        } elsif ($opts{remote} eq 'globus-url-copy') {
            # make sure gridftp-ssh is set up properly
            my $dir = glob("~/.globus");
            mkdir $dir if (! -d $dir);
            my $file = "$dir/gridftp-ssh";
            open(FILE, '>', $file);
            print FILE "#!/bin/sh\n$opts{ssh} \$2 sshftp";
            close FILE;
            chmod(0700, $file);

            my %errs;
            my ($fh, $tmp) = sftp_tmp();
            my @fish;
            foreach my $cmd (@{$tcmds{$host}}) {
                ($op, $src, $dst, $ref) = @{$cmd};
                if ($op =~ /^(r)?(?:get|put)$/ && !defined $ref->{tar_bytes}) {
                    my $slash = $1 ? "/" : "";
                    if ($op =~ /put/) {
                        $errs{"STOR $dst"} = $ref;
                        $src = "file://" . escape($src) . $slash;
                        $dst = "sshftp://$host" . escape($dst);
                    } else {
#TODO: this doesn't work with connection/allocation errors
                        $errs{"RETR $src"} = $ref;
                        $src = "sshftp://$host" . escape($src) . $slash;
                        $dst = "file://" . escape($dst);
                    }
                    if ($ref->{bytes}) {
                        my @ranges = split(/,/, $ref->{bytes});
                        foreach my $range (@ranges) {
                            my ($x1, $x2) = split(/-/, $range);
                            print $fh "$src $dst $x1,", $x2 - $x1, "\n";
                        }
                    } else {
                        print $fh "$src $dst\n";
                    }
                    $ref->{tool} = "globus-url-copy";
                } elsif ($op =~ /^(?:get|put)$/) {
                    push(@fish, $cmd);
                } else {
                    transport_default($host, $cmd);
                }
            }
            close $fh;
            transport_fish($host, \@fish) if (scalar(@fish) > 0);

#TODO: handle this case properly (no errors currently reported)
=for comment
"sshftp://pfe5.nas.nasa.gov/home4/user1/test/shift/testdir/foobar" "file:///Users/user1/test/shift/aa/foobar"
/aa/lfoo"
"sshftp://pfe5.nas.nasa.gov/home4/user1/test/shift/testdir/a.pl" "file:///Users/user1/test/shift/aa/a.pl"
ft/aa/dir/a.pl"
line is debug: starting to get sshftp://pfe5.nas.nasa.gov/home4/user1/test/shift/testdir/foobar
line is debug: connecting to sshftp://pfe5.nas.nasa.gov/home4/user1/test/shift/testdir/foobar
line is debug: fault on connection to sshftp://pfe5.nas.nasa.gov/home4/user1/test/shift/testdir/foobar: an end-of-file was reached
eof=true
line is debug: data callback, error an end-of-file was reached, buffer 0x2c00000, length 0, offset=0, eof=true
eof=true
line is debug: data callback, error an end-of-file was reached, buffer 0x2400000, length 0, offset=0, eof=true
eof=true
line is debug: data callback, error an end-of-file was reached, buffer 0x1c00000, length 0, offset=0, eof=true
eof=true
line is debug: data callback, error an end-of-file was reached, buffer 0x1400000, length 0, offset=0, eof=true
line is
line is error: an end-of-file was reached
line is globus_xio: An end of file occurred
=cut
            # encrypt data channel if specified
            my $extra = $opts{encrypt} ? "-dcpriv" : "";
            if (scalar(keys %errs) &&
#TODO: gridftp hangs with one file and -p 8 and sometimes cannot
#      allocate the buffer size specified
                    #open(OUT, '-|', "globus-url-copy -dbg -cd -p 8 -bs 4M -tcp-bs 4M -r -f $tmp 2>&1"))
                    open(OUT, '-|', "globus-url-copy $extra -dbg -cd -r -f $tmp 2>&1")) {
                my $key;
                my $msg;
                while (my $line = <OUT>) {
                    $line =~ s/\s*\r?\n$//;
                    if ($errs{$line}) {
                        $key = $line;
                    } elsif ($key) {
                        $msg .= "$line\n" if ($line && $line !~ /^debug:/);
                        if ($line =~ /operation complete/) {
                            if ($msg !~ /Transfer Complete/) {
                                sftp_error($errs{$key}, $msg);
                            }
                            $key = undef;
                            $msg = undef;
                        }
                    }
                }
                close OUT;
            } else {
                foreach my $err (values %errs) {
                    sftp_error($err, "Unable to run globus-url-copy");
                }
            }

            transport_default($host, $_, 1) foreach (@{$tcmds{$host}});
        } elsif ($opts{remote} eq 'fish') {
            transport_fish($host, $tcmds{$host});
        } else {
            transport_default($host, $_) foreach (@{$tcmds{$host}});
        }
    } else {
        push(@{$tcmds{$host}}, [$op, $src, $dst, $ref]);
        return;
    }

    # this will only be done during 'end' processing
    verify($host, $tcmds{$host}) if ($opts{verify});

    delete $tcmds{$host};

    # return is only defined during an end when rsync is used
    return $rsize;
}

###########################
#### transport_default ####
###########################
sub transport_default {
    my ($host, $cmd, $rm) = @_;
    my ($op, $src, $dst, $ref) = @{$cmd};
    return if ($op =~ /^(?:sum|cksum)/);
    my @attrs = split(/,/, $ref->{attrs});
    if ($host eq 'localhost') {
        $ref->{tool} = "shiftc" if (!$rm);
        if (!$rm && $op =~ /^(?:get|put)$/ && !$ref->{bytes} &&
                !$opts{"verify-fast"}) {
            # create implicit directories
            eval {mkpath(dirname($dst))};
            copy($src, $dst) or sftp_error($ref, "$!");
        } elsif (!$rm && $op eq 'mkdir' && !$opts{'create-tar'}) {
            # create implicit directories when extracting tar
            eval {mkpath(dirname($dst))} if ($opts{'extract-tar'});
            # ignore if directory exists
            -d $dst or mkdir $dst or sftp_error($ref, "$!");
        } elsif (($rm || !defined $rm) && $op eq 'rm') {
            unlink $src or sftp_error($ref, "$!");
        } elsif (($rm || !defined $rm) && $op eq 'rrm') {
            sftp_error($ref, rmtree($src));
        } elsif (!$rm && $op eq 'ln' && !$opts{'create-tar'}) {
            # create implicit directories
            eval {mkpath(dirname($dst))};
            ($src && readlink($dst) eq $src) or symlink($src, $dst) or
                sftp_error($ref, "$!");
        } elsif (!$rm && $op =~ /^(?:get|put)$/) {
            # create implicit directories
            eval {mkpath(dirname($dst))};
            my @ranges = $ref->{bytes} ? split(/,/, $ref->{bytes}) :
                ("0-" . (stat $src)[7]);
            if (sysopen(SRC, $src, O_RDONLY)) {
                if (sysopen(DST, $dst, O_RDWR | O_CREAT)) {
                    my ($t1, $t2) = split(/-/, $ref->{tar_bytes});
                    foreach my $range (@ranges) {
                        my ($x1, $x2) = split(/-/, $range);
                        my ($sseek, $dseek) = ($x1, $x1);
                        if ($opts{'create-tar'}) {
                            # adjust src by tar start offset
                            $sseek = $x1 - $t1;
                        } elsif ($opts{'extract-tar'}) {
                            # adjust dst by tar start offset
                            $dseek = $x1 - $t1;
                        }
                        sysseek(SRC, $sseek, 0) or sftp_error($ref,
                            "Unable to seek source: $!");
                        sysseek(DST, $dseek, 0) or sftp_error($ref,
                            "Unable to seek destination: $!");
                        my $sopts = !$opts{"verify-fast"} ? 0 :
                            verify_init(check_tree => 1, length => $x2 - $x1);
                        my $size = 4 * 1048576;
                        for (my $x = $x2 - $x1; $x > 0; $x -= $size) {
                            $size = $x if ($x < $size);
                            my $buf;
                            my $n = sysread(SRC, $buf, $size);
                            sftp_error($ref, "Unable to read source: $!")
                                if (!defined $n);
                            defined syswrite(DST, $buf, $n) or
                                sftp_error($ref, "Unable to write destination: $!");
                            verify_buffer($sopts, $buf, $x2 - $x1 - $x + $n)
                                if ($opts{"verify-fast"});
                        }
                        if ($opts{"verify-fast"} && !$ref->{text}) {
                            verify_buffer_end($sopts);
                            my $hash = "#mutil#";
                            $hash .= "$sseek-" . ($sseek + $x2 - $x1)
                                if ($ref->{bytes});
                            $hash .= "#";
                            $hash .= "\\" if ($src =~ /\\|\n/);
                            $hash .= join("",
                                map {unpack("H*", $_)} @{$sopts->{stack}});
                            # record hash in error ref
                            $ref->{text} = "\\H$hash";
                        }
                        if ($ref->{bytes} && !$opts{'create-tar'} &&
                                $dseek + $x2 - $x1 == $attrs[7] &&
                                (stat DST)[7] > $attrs[7]) {
                            # truncate dst if last split
                            DST->truncate($attrs[7]);
                        }
                    }
                    close DST;
                } else {
                    sftp_error($ref, "Unable to open destination: $!");
                }
                close SRC;
            } else {
                sftp_error($ref, "Unable to open source: $!");
            }
        } elsif (!$rm && $op eq 'chattr' && $ref->{tar_mv}) {
            my $src = $dst;
            $dst =~ s/-1\.tar//;
            rename($src, $dst) or sftp_error($ref, "$!");
            if ($opts{'index-tar'}) {
                rename("$src.toc", "$dst.toc") or sftp_error($ref, "$!");
                if ($opts{verify}) {
                    rename("$src.sum", "$dst.sum") or sftp_error($ref, "$!");
                }
            }
        } elsif (!$rm && $opts{preserve} && $op eq 'chattr' && $ref->{ln} &&
                !$opts{'create-tar'}) {
            # hack since perl does not support symlink chown
            system("chown", "-h", "$attrs[1]:$attrs[2]", $dst);
        } elsif (!$rm && $opts{preserve} && $op eq 'chattr' && !$ref->{ln} &&
                !$opts{'create-tar'}) {
            # don't return error for chown since unlikely to succeed
            chown($attrs[1], $attrs[2], $dst);
            chmod($attrs[0], $dst) or sftp_error($ref, "$!") and return;
            utime($attrs[3], $attrs[4], $dst) or
                sftp_error($ref, "$!") and return;
        }
        if (!$rm && $opts{check} && $op =~ /^c[hk]attr/ && !$ref->{ln} &&
                !$opts{'create-tar'}) {
            my @dattrs = stat $dst;
            if (!@dattrs || $dattrs[7] == 0 && $op ne 'chattr') {
                # record as error, which will trigger copy
                sftp_error($ref, "No such file or directory");
            } elsif ($op eq 'chattr' && !$ref->{src}) {
                # ignore ln/mkdir during chattr size check
            } elsif ($op eq 'ckattr0' || ($attrs[7] != $dattrs[7] ||
                    $op ne 'chattr' && $attrs[4] != $dattrs[9])) {
                if ($op eq 'chattr') {
                    sftp_error($ref, "Source/destination file sizes differ");
                } else {
                    # record as warning, which will trigger sum
                    sftp_warning($ref, "File attributes ignored or differ");
                }
            }
            # ckattr done state will trigger chattr
        }
    } else {
        $ref->{tool} = "sftp" if (!$rm);
        # must keep write access to handle warnings/corruption
        my %extra = (copy_perm => 0);
        if (!$rm && $op eq 'get' && !$ref->{bytes}) {
            # create implicit directories
            eval {mkpath(dirname($dst))};
            sftp($host)->get($src, $dst, %extra) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'mkdir' && !$opts{'create-tar'}) {
            # create implicit directories when extracting tar
            sftp($host)->mkpath(dirname($dst)) if ($opts{'extract-tar'});
            my $attrs = sftp($host)->stat($dst);
            if ($attrs && !S_ISDIR($attrs->perm)) {
                sftp_error($ref, "File exists");
            } elsif (!$attrs && !sftp($host)->mkdir($dst)) {
                sftp_error($ref, "Permission denied");
            }
        } elsif (!$rm && $op eq 'put' && !$ref->{bytes} &&
                !$opts{"verify-fast"}) {
            # create implicit directories
            sftp($host)->mkpath(dirname($dst));
            sftp($host)->put($src, $dst, %extra) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'rget') {
            sftp($host)->rget($src, $dst) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (($rm || !defined $rm) && $op eq 'rm') {
            sftp($host)->remove($src) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'rput') {
            sftp($host)->rput($src, $dst) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (($rm || !defined $rm) && $op eq 'rrm') {
            sftp($host)->rremove($src) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'ln' && !$opts{'create-tar'}) {
            # create implicit directories
            sftp($host)->mkpath(dirname($dst));
            # src and dst are reversed in sftp symlink
            ($src && sftp($host)->readlink($dst) eq $src) or
                sftp($host)->symlink($dst, $src) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        } elsif (!$rm && $op eq 'get' && $ref->{bytes}) {
            my @ranges = split(/,/, $ref->{bytes});
            my $src_fh = sftp($host)->open($src, SFTP_READ);
            if ($src_fh) {
                # create implicit directories
                eval {mkpath(dirname($dst))};
                if (sysopen(DST, $dst, O_RDWR | O_CREAT)) {
                    my ($t1, $t2) = split(/-/, $ref->{tar_bytes});
                    foreach my $range (@ranges) {
                        my ($x1, $x2) = split(/-/, $range);
                        my ($sseek, $dseek) = ($x1, $x1);
                        if ($opts{'create-tar'}) {
                            # adjust src by tar start offset
                            $sseek = $x1 - $t1;
                        } elsif ($opts{'extract-tar'}) {
                            # adjust dst by tar start offset
                            $dseek = $x1 - $t1;
                        }
                        sftp($host)->seek($src_fh, $sseek, 0) or
                            sftp_error($ref, "Unable to seek source: " .
                                sftp($host, 1)->error);
                        sysseek(DST, $dseek, 0) or sftp_error($ref,
                            "Unable to seek destination: $!");
                        my $size = 4 * 1048576;
                        for (my $x = $x2 - $x1; $x > 0; $x -= $size) {
                            $size = $x if ($x < $size);
                            my $buf = sftp($host)->read($src_fh, $size);
                            sftp_error($ref, "Unable to read source: " .
                                sftp($host, 1)->error) if (!defined $buf);
                            defined syswrite(DST, $buf, length($buf)) or
                                sftp_error($ref, "Unable to write destination: $!");
                        }
                        if (!$opts{'create-tar'} &&
                                $dseek + $x2 - $x1 == $attrs[7] &&
                                (stat DST)[7] > $attrs[7]) {
                            # truncate dst if last split
                            DST->truncate($attrs[7]);
                        }
                    }
                    close DST;
                } else {
                    sftp_error($ref, "Unable to open destination: $!");
                }
                sftp($host)->close($src_fh);
            } else {
                sftp_error($ref, "Unable to open source: " .
                    sftp($host, 1)->error);
            }
        } elsif (!$rm && $op eq 'put') {
            my @ranges = $ref->{bytes} ? split(/,/, $ref->{bytes}) :
                ("0-" . (stat $src)[7]);
            my @ranges = split(/,/, $ref->{bytes});
            if (sysopen(SRC, $src, O_RDONLY)) {
                # create implicit directories
                sftp($host)->mkpath(dirname($dst));
                my $dst_fh = sftp($host)->open($dst, SFTP_WRITE | SFTP_CREAT);
                if ($dst_fh) {
                    my ($t1, $t2) = split(/-/, $ref->{tar_bytes});
                    foreach my $range (@ranges) {
                        my ($x1, $x2) = split(/-/, $range);
                        my ($sseek, $dseek) = ($x1, $x1);
                        if ($opts{'create-tar'}) {
                            # adjust src by tar start offset
                            $sseek = $x1 - $t1;
                        } elsif ($opts{'extract-tar'}) {
                            # adjust dst by tar start offset
                            $dseek = $x1 - $t1;
                        }
                        sysseek(SRC, $sseek, 0) or
                            sftp_error($ref, "Unable to seek source: $!");
                        sftp($host)->seek($dst_fh, $dseek, 0) or
                            sftp_error($ref, "Unable to seek destination: " .
                                sftp($host, 1)->error);
                        my $sopts = !$opts{"verify-fast"} ? 0 :
                            verify_init(check_tree => 1, length => $x2 - $x1);
                        my $size = 4 * 1048576;
                        for (my $x = $x2 - $x1; $x > 0; $x -= $size) {
                            $size = $x if ($x < $size);
                            my $buf;
                            my $n = sysread(SRC, $buf, $size);
                            sftp_error($ref, "Unable to read source: $!")
                                if (!defined $n);
                            defined sftp($host)->write($dst_fh, $buf) or
                                sftp_error($ref, "Unable to write destination: " .
                                    sftp($host, 1)->error);
                            verify_buffer($sopts, $buf, $x2 - $x1 - $x + $n)
                                if ($opts{"verify-fast"});
                        }
                        if ($opts{"verify-fast"} && !$ref->{text}) {
                            verify_buffer_end($sopts);
                            my $hash = "#mutil#";
                            $hash .= "$sseek-" . ($sseek + $x2 - $x1)
                                if ($ref->{bytes});
                            $hash .= "#";
                            $hash .= "\\" if ($src =~ /\\|\n/);
                            $hash .= join("",
                                map {unpack("H*", $_)} @{$sopts->{stack}});
                            # record hash in error ref
                            $ref->{text} = "\\H$hash";
                        }
                        if (!$opts{'create-tar'} && $ref->{bytes} &&
                                $dseek + $x2 - $x1 == $attrs[7]) {
                            my $dattrs = sftp($host)->stat($dst);
                            if (defined $dattrs && $dattrs->size > $attrs[7]) {
                                # truncate dst if last split
                                sftp($host)->truncate($dst, $attrs[7]);
                            }
                        }
                    }
                    sftp($host)->close($dst_fh);
                } else {
                    sftp_error($ref, "Unable to open destination: " .
                        sftp($host, 1)->error);
                }
                close SRC;
            } else {
                sftp_error($ref, "Unable to open source: $!");
            }
        } elsif (!$rm && $op eq 'chattr' && $ref->{tar_mv}) {
            my $src = $dst;
            $dst =~ s/-1\.tar//;
            sftp($host)->rename($src, $dst, overwrite => 1) or
                sftp_error($ref, "" . sftp($host, 1)->error);
            if ($opts{'index-tar'}) {
                sftp($host)->rename("$src.toc", "$dst.toc", overwrite => 1) or
                    sftp_error($ref, "" . sftp($host, 1)->error);
                if ($opts{verify}) {
                    sftp($host)->rename("$src.sum", "$dst.sum", overwrite => 1) or
                        sftp_error($ref, "" . sftp($host, 1)->error);
                }
            }
        } elsif (!$rm && $opts{preserve} && $op eq 'chattr' && !$ref->{ln} &&
                !$opts{'create-tar'}) {
            my @attrs = split(/,/, $ref->{attrs});
            # don't return error for chown/chgrp since unlikely to succeed
            my $sattrs = Net::SFTP::Foreign::Attributes->new;
            $sattrs->set_ugid($attrs[1], $attrs[2]);
            sftp($host)->setstat($dst, $sattrs);

            $sattrs = Net::SFTP::Foreign::Attributes->new;
            $sattrs->set_perm($attrs[0]);
            $sattrs->set_amtime($attrs[3], $attrs[4]);
            sftp($host)->setstat($dst, $sattrs) or
                sftp_error($ref, "" . sftp($host, 1)->error);
        }
        if (!$rm && $opts{check} && $op =~ /^c[hk]attr/ && !$ref->{ln} &&
                !$opts{'create-tar'}) {
            my @attrs = split(/,/, $ref->{attrs});
            my $dattrs = sftp($host)->stat($dst);
            if (!defined $dattrs || $dattrs->size == 0 && $op ne 'chattr') {
                # record as error, which will trigger copy
                sftp_error($ref, "No such file or directory");
            } elsif ($op eq 'chattr' && !$ref->{src}) {
                # ignore ln/mkdir during chattr size check
            } elsif ($op eq 'ckattr0' || ($attrs[7] != $dattrs->size ||
                    $op ne 'chattr' && $attrs[4] != $dattrs->mtime)) {
                if ($op eq 'chattr') {
                    sftp_error($ref, "Source/destination file sizes differ");
                } else {
                    # record as warning, which will trigger sum
                    sftp_warning($ref, "File attributes ignored or differ");
                }
            }
            # ckattr done state will trigger chattr
        }
    }
}

##########################
#### transport_chattr ####
##########################
sub transport_chattr {
    my ($host, $tcmds) = @_;
    my ($fh, $tmp);
    foreach my $cmd (@{$tcmds}) {
        my ($op, $src, $dst, $ref) = @{$cmd};
        next if ($op ne 'chattr' || !$ref->{acls});
        if ($host eq 'localhost') {
            # chattr local files immediately
            #TODO: other operating systems may use something different
            if (open(SOUT, '|-', "setfacl", "-M-", $dst)) {
                my $acls = unescape($ref->{acls});
                $acls =~ s/,/\n/g;
                print SOUT $acls;
                close SOUT;
            }
            # ignore errors since systems may have different command/users
        } else {
            # chattr remote files in batch
            ($fh, $tmp) = sftp_tmp() if (!$tmp);
            print $fh "$dst $ref->{acls}\n";
        }
    }
    if ($tmp) {
        close $fh;
        open(SOUT, '-|',
            "$opts{ssh} $host $opts{caux} setfacl <$tmp >/dev/null 2>&1");
        close SOUT;
        unlink $tmp;
        # ignore errors since systems may have different command/users
    }
}

#######################
#### transport_dmf ####
#######################
sub transport_dmf {
    my ($host, $tcmds) = @_;

    # dmget processing
    my (%fh, %tmp);
    foreach my $cmd (@{$tcmds}) {
        my ($op, $src, $dst, $ref) = @{$cmd};
        next if ($op !~ /^(?:get|put)$/ || !$ref->{dmi} || $ref->{dmi} !~ /src/);
        ($fh{$op}, $tmp{$op}) = sftp_tmp() if (!$tmp{$op});
        print {$fh{$op}} $src, "\n";
    }
    foreach my $op (keys %tmp) {
        close $fh{$op};
        my $ssh = $op eq 'get' && $host ne 'localhost' ? "$opts{ssh} $host" : "";
        # ignore errors since files will be automatically retrieved anyway
        system("$ssh dmget -q <$tmp{$op} >/dev/null 2>/dev/null");
        unlink $tmp{$op};
        delete $tmp{$op};
    }

    # dmput processing
    return if (!$opts{offline});
    foreach my $cmd (@{$tcmds}) {
        my ($op, $src, $dst, $ref) = @{$cmd};
        next if ($op ne 'chattr' || !$ref->{dmi} || !$ref->{src});
        if ($ref->{dmi} =~ /src/) {
            my ($shost, $spath) = hostpath(unescape($ref->{src}));
            ($fh{$shost}, $tmp{$shost}) = sftp_tmp() if (!$tmp{$shost});
            print {$fh{$shost}} $spath, "\n";
        }
        if ($ref->{dmi} =~ /dst/) {
            ($fh{$host}, $tmp{$host}) = sftp_tmp() if (!$tmp{$host});
            print {$fh{$host}} $dst, "\n";
        }
    }
    foreach my $rhost (keys %tmp) {
        close $fh{$rhost};
        my $ssh = $rhost ne 'localhost' ? "$opts{ssh} $rhost" : "";
        # ignore errors since files will be automatically migrated anyway
        system("$ssh dmput -n -r <$tmp{$rhost} >/dev/null 2>/dev/null");
        unlink $tmp{$rhost};
    }
}

########################
#### transport_fish ####
########################
sub transport_fish {
    my ($host, $tcmds) = @_;

    my ($out, $in);
    my $pid = open2($in, $out,
        "$opts{ssh} $host $opts{caux} fish 2>/dev/null");
    $out->autoflush(1);

    my $rc0 = transport_fish_return($in);

    foreach my $cmd (@{$tcmds}) {
        my ($op, $src, $dst, $ref) = @{$cmd};
        if ($op !~ /^(?:get|put)$/) {
            transport_default($host, $cmd);
            next;
        }
        $ref->{tool} = "fish";
        if (ref $rc0) {
            sftp_error($ref, $rc0->{error});
            next;
        }
        my @attrs = split(/,/, $ref->{attrs});

        # create implicit directories
        eval {mkpath(dirname($dst))};

        my ($t1, $t2) = split(/-/, $ref->{tar_bytes});
        my @ranges = split(/,/, $ref->{bytes});
        push(@ranges, "-") if (scalar(@ranges) == 0);
        foreach my $range (@ranges) {
            my @args = ($op, $src, $dst);
            my ($x1, $x2) = split(/-/, $range);
            my ($loff, $roff) = ($x1, $x1);
            if ($x2) {
                push(@args, $x2 - $x1);
                if ($opts{'create-tar'}) {
                    $loff = $op eq 'get' ? $x1 : $x1 - $t1;
                    $roff = $op eq 'get' ? $x1 - $t1 : $x1;
                } elsif ($opts{'extract-tar'}) {
                    $loff = $op eq 'get' ? $x1 - $t1 : $x1;
                    $roff = $op eq 'get' ? $x1 : $x1 - $t1;
                }
                push(@args, $roff);
            }
            $out->write("#" . join(" ", map {escape($_)} @args) . "\n");
            # change last argument to local offset if needed
            splice(@args, -1, 1, $loff) if ($x2);
            my $rc = transport_fish_io($in, $out, @args);
            if (ref $rc && defined $rc->{hash}) {
                my $hash = "#mutil#";
                $hash .= "$loff-" . ($loff + $x2 - $x1) if ($x2);
                $hash .= "#";
                $hash .= "\\" if ($src =~ /\\|\n/);
                $hash .= $rc->{hash};
                # record hash in error ref
                $ref->{text} = "\\H$hash";
            } else {
                sftp_error($ref, $rc->{error}) if (ref $rc);
            }
            if ($x2 && !$opts{'create-tar'} && $ref->{bytes}) {
                if ($op eq 'get' && $loff + $x2 - $x1 == $attrs[7] &&
                        (stat $dst)[7] > $attrs[7]) {
                    # truncate dst if last split
                    truncate($dst, $attrs[7]);
                } elsif ($op eq 'put' && $roff + $x2 - $x1 == $attrs[7]) {
                    my $dattrs = sftp($host)->stat($dst);
                    if (defined $dattrs && $dattrs->size > $attrs[7]) {
                        # truncate dst if last split
                        sftp($host)->truncate($dst, $attrs[7]);
                    }
                }
            }
        }
    }
    $out->write("#exit\n") if (!ref $rc0);
    close $out;
    close $in;
    waitpid($pid, 0);
}

###########################
#### transport_fish_io ####
###########################
sub transport_fish_io {
    my ($in, $out, $cmd, $src, $dst, $len, $off) = @_;
    my $file = $cmd eq 'get' ? $dst : $src;
    $len = (stat $file)[7] if (!defined $len && $cmd eq 'put');

    my $flags = $cmd eq 'put' ? O_RDONLY : O_WRONLY | O_CREAT;
    $flags |= O_TRUNC if (!defined $off && $cmd eq 'get');
    my $fh = IO::File->new($file, $flags);
    my $err;
    if (!defined $fh) {
        $err = {error => "Error opening: $!"};
        $out->write("### 500 $err->{error}: $!\n");
    } elsif (defined $off && !$fh->seek($off, 0)) {
        $fh->close;
        $err = {error => "Error seeking: $!"};
        $out->write("### 500 $err->{error}: $!\n");
    } else {
        $out->write("$len\n") if ($cmd eq 'put');
        $out->write("### 100\n");
    }
    my $rc = transport_fish_return($in);
    return (ref $err ? $err : $rc) if (ref $err || ref $rc);
    $len = $rc if ($cmd eq 'get');
    $rc = undef;

    my $sopts = !$opts{"verify-fast"} || $cmd ne 'put' ? 0 :
        verify_init(check_tree => 1, length => $len);
    my $size = 4 * 1048576;
    while ($len > 0) {
        $size = $len if ($len < $size);
        if ($cmd eq 'get') {
            $rc = transport_fish_return($in);
            if (ref $rc) {
                $fh->close;
                return $rc;
            }
        }
        my $buf;
        my $n = $cmd eq 'get' ?
            $in->read($buf, $size) : $fh->sysread($buf, $size);
        last if ($n < $size);
        $out->write("### 200\n") if ($cmd eq 'put');
        $cmd eq 'get' ? $fh->syswrite($buf) : $out->write($buf);
        $len -= $n;
        verify_buffer($sopts, $buf, $sopts->{length} - $len)
            if ($opts{"verify-fast"} && $cmd eq 'put');
    }
    $fh->close;

    if ($len > 0) {
        $rc = {error => "Error reading: $!"};
        $out->write("### 500 $rc->{error}\n");
        transport_fish_return($in);
    } else {
        $out->write("### 200\n");
        $rc = transport_fish_return($in);
        if (!ref $rc && $opts{"verify-fast"} && $cmd eq 'put') {
            verify_buffer_end($sopts);
            my $hash = join("", map {unpack("H*", $_)} @{$sopts->{stack}});
            $rc = {hash => $hash};
        }
    }
    return $rc;
}

###############################
#### transport_fish_return ####
###############################
sub transport_fish_return {
    my $in = shift;
    my $text;
    while (defined($_ = $in->getline)) {
        if (/^###\s+(\d+)(.*)/) {
            if ($1 != 200 && $1 != 100) {
                return {error => $2};
            } else {
                $text =~ s/\s+$//;
                return $text;
            }
        } else {
            $text .= $_;
        }
    }
    return {error => "Invalid protocol return"};
}

##########################
#### transport_lustre ####
##########################
sub transport_lustre {
    my ($host, $tcmds) = @_;
    my ($fh, $tmp);
    foreach my $cmd (@{$tcmds}) {
        my ($op, $src, $dst, $ref) = @{$cmd};
        next if ($op !~ /^(?:get|mkdir|put)$/ || !$ref->{lustre} ||
                $ref->{lustre} !~ /dst/ || $opts{'create-tar'} ||
                $opts{stripe} == 0);
        my @attrs = split(/,/, $ref->{attrs});
        # set striping
        my ($scount, $ssize) = (0, 0);
        if ($opts{'no-stripe'} && $ref->{lustre_attrs}) {
            # preserve existing striping
            ($scount, $ssize) = split(/,/, $ref->{lustre_attrs});
        }
        # don't preserve if stripe count is default (1)
        if ($scount < 2 && $opts{stripe} < 1000) {
            $scount = $opts{stripe};
        } elsif ($op ne 'mkdir' && $scount < 2) {
            $scount = int($attrs[7] / $opts{stripe});
        }
        if ($host eq 'localhost' || $op eq 'get') {
            # stripe local files immediately
            my $dir = $op eq 'mkdir' ? $dst : dirname($dst);
            eval {mkpath($dir)};
            open(SOUT, '-|', "lfs", "setstripe",
                "-c", $scount, "-s", $ssize, $dst);
            close SOUT;
            # ignore errors since files will be automatically striped anyway
        } else {
            # stripe remote files in batch
            ($fh, $tmp) = sftp_tmp() if (!$tmp);
            print $fh $dst, $op eq 'mkdir' ? "/" : "", " $scount $ssize\n";
        }
    }
    if ($tmp) {
        close $fh;
        open(SOUT, '-|',
            "$opts{ssh} $host $opts{caux} setstripe <$tmp >/dev/null 2>&1");
        close SOUT;
        unlink $tmp;
        # ignore errors since files will be automatically striped anyway
    }
}

#########################
#### transport_rsync ####
#########################
sub transport_rsync {
    my ($args, $from, $src, $dst, $errs) = @_;
    my ($code, $code_text, $pid, $in, $out, $size);
    $from = " --files-from $from" if ($from);
    # copy inplace to avoid writing dot files in home directory
    # do not do this when whole files used for DMF
    $args .= " --inplace" if ($args !~ /-W/);
    eval {
        local $SIG{__WARN__} = sub {die};
        # escape remote src/dst metacharacters since interpreted by remote shell
        my ($esrc, $edst) = ($src, $dst);
        $esrc =~ s/([^A-Za-z0-9\-_.:+\/])/\\$1/g if ($esrc =~ /^[^\/]/);
        $edst =~ s/([^A-Za-z0-9\-_.:+\/])/\\$1/g if ($edst =~ /^[^\/]/);
        # use open3 to avoid executing a shell command based on the name
        # of a file being copied (which may contain metacharacters, etc.)
        # must keep write access to handle warnings/corruption
        $pid = open3($in, $out, $out,
            # make sure quotewords string does not end in space
            quotewords('\s+', 0, "rsync -l --chmod=u+rwX --stats$args$from"),
            $esrc, $edst);
    };
    if ($@) {
        $code = 1;
        $code_text = "Unable to run rsync";
    } else {
        while (my $line = <$out>) {
            $line =~ s/\s*\r?\n$//;
            if ($line =~ /"([^"]+)"/) {
                my $file = $1;
                foreach my $key (grep(/^\Q$file\E$/, keys(%{$errs}))) {
                    sftp_error($_, $line) foreach(@{$errs->{$key}});
                }
            } elsif ($line =~ /\(code\s+(\d+)\)/) {
                $code = $1;
                $code_text = $line;
            } elsif ($line =~ /Total bytes sent:\s*(\d+)/) {
                $size += $1;
            } elsif ($line =~ /Total bytes received:\s*(\d+)/) {
                $size += $1;
            }
        }
    }
    close $in;
    close $out;
    waitpid($pid, 0) if ($pid);

    if (defined $code && $code != 23) {
        # set error/warning on all failures except partial transfers (code 23)
        my $type = $code <= 5 || $code == 255 ? "\\E" : "\\W";
        foreach my $refs (values %{$errs}) {
            foreach my $ref (@{$refs}) {
                $ref->{text} = "$type$code_text" if (!$ref->{text});
            }
        }
    }
    return $size;
}

#######################
#### transport_tar ####
#######################
sub transport_tar {
    my ($host, $tcmds) = @_;
    if ($opts{'create-tar'}) {
        # insert header and padding for each source file
        my ($tar, $tarfh);
        foreach my $cmd (@{$tcmds}) {
            my ($op, $src, $dst, $ref) = @{$cmd};
            next if ($op !~ /^(?:chattr|get|ln|mkdir|put)/);
            next if ($op ne 'chattr' && $ref->{bytes} ne $ref->{tar_bytes} &&
                    # write header during first split
                    $ref->{split} !~ /:0$/);
            next if ($ref->{tar_mv});
            if (!$tar || $tar ne $dst) {
                close $tarfh if ($tar);
                $tar = $dst;
                if ($host ne 'localhost' && $op ne 'get') {
                    $tarfh = sftp($host)->open($tar,
                        SFTP_WRITE | SFTP_CREAT | SFTP_READ);
                    sftp_error($ref, "Unable to open tar file") if (!$tarfh);;
                } else {
                    sysopen($tarfh, $tar, O_RDWR | O_CREAT) or
                        sftp_error($ref, "Unable to open tar file");;
                }
            }
            if ($op eq 'chattr' && !tar_validate($tarfh, $ref)) {
                if ($ref->{ln}) {
                    $op = "ln";
                    $src = $ref->{src};
                } elsif ($ref->{src}) {
                    $op = "cp";
                    $src = $ref->{src};
                } else {
                    $op = "mkdir";
                }
            }
            tar_record($tarfh, $op, $src, $ref) if ($op ne 'chattr');
        }
        close $tarfh if ($tar);
    }
}

################
#### verify ####
################
sub verify {
    my ($host, $tcmds) = @_;

    # check for msum
    my $msum = 0;
    foreach my $path (split(/:/, $ENV{PATH})) {
        if (-x "$path/msum") {
            $msum = 1;
            last;
        }
    }
  
    my %emap = ("'" => "'", 0 => "\0", a => "\a", b => "\b", f => "\f",
        n => "\n", r => "\r", t => "\t", v => "\v", '\\' => "\\");
    my %errs;
    my ($fh, $tmp) = sftp_tmp();

    foreach my $cmd (@{$tcmds}) {
        my ($op, $src, $dst, $ref) = @{$cmd};
        if ($op eq 'sum') {
            my $bytes = $ref->{bytes};
            if (defined $ref->{tar_bytes}) {
                my @bytes;
                my ($t1, $t2) = split(/-/, $ref->{tar_bytes});
                my @ranges = split(/,/, $ref->{bytes});
                foreach my $range (@ranges) {
                    my ($x1, $x2) = split(/-/, $range);
                    my $loff;
                    if ($opts{'create-tar'}) {
                        $loff = $ref->{lindex} ? $x1 : $x1 - $t1;
                    } elsif ($opts{'extract-tar'}) {
                        $loff = $ref->{lindex} ? $x1 - $t1 : $x1;
                    }
                    push(@bytes, $loff . "-" . ($loff + ($x2 - $x1)));
                }
                $bytes = join(",", @bytes);
                # need to track by bytes instead of file
                $errs{"$src bytes=$bytes"} = $ref;
            } elsif (defined $ref->{split}) {
                # need to track by split instead of file
                $errs{"$src bytes=$bytes"} = $ref;
            } else {
                $errs{$src} = $ref;
            }

            if ($msum) {
                print $fh escape($src);
                print $fh " $bytes" if ($bytes);
                print $fh "\n";
                $ref->{tool} = "msum";
            } else {
                my %bytes;
                $bytes{bytes} = $bytes if ($bytes);
                my $hash = verify_default($src, check_tree => 1, %bytes);
                $ref->{text} = $hash;
                $ref->{tool} = "shiftc";
            }
        }
    }

    if ($msum && scalar(keys(%errs)) > 0) {
        close $fh;
        my $out_tmp = sftp_tmp();
        my $err_tmp = sftp_tmp();
        system("msum --threads=8 --double-buffer --check-tree --read-stdin <$tmp >$out_tmp 2>$err_tmp");

        if (open(ERR, '<', $err_tmp)) {
            while (my $line = <ERR>) {
                $line =~ s/\r?\n$//;
                # any number of non-' or odd-\ with ' followed by
                # non-' and non-\ or even-\ or odd-\ with '
                while ($line =~ /`((?:[^']|[^'\\](\\\\)*\\')*(?:[^'\\]|[^'\\](\\\\)*|[^'\\](\\\\)*\\'))'/g) {
                    my $file = $1;
                    $file =~ s/\\([abfnrtv'\\])/$emap{$1}/g;
                    my @keys = grep(/^\Q$file\E( bytes=\d+-\d+)?$/,
                        keys(%errs));
                    $errs{$_}->{text} = "\\E$line" foreach (@keys);
                }
            }
            close ERR;
        }
        unlink $err_tmp;

        if (open(OUT, '<', $out_tmp)) {
            while (<OUT>) {
                s/\r?\n$//;
                if (/^(\S+)\s.(.*)/) {
                    my ($hash, $file) = ($1, $2);
                    # eliminate extra \ in files with \\ or \n
                    $file =~ s/\\([\\n])/$emap{$1}/g if ($hash =~ /(^|#)\\/);
                    my $ref = $errs{$file};
                    $ref = $errs{"$file bytes=$1-$2"}
                        if (!ref $ref && $hash =~ /^#mutil#(\d+)-(\d+)#/);
                    # skip if ref not found or error already recorded
                    next if ($ref->{text} =~ /^\\E/);
                    # record hash in error ref
                    $ref->{text} .= "\\H$hash";
                }
            }
            close OUT;
        }
        unlink $out_tmp;

        open($fh, '>', $tmp);
    }

    foreach my $ref (values(%errs)) {
        $ref->{text} = "\\EUnable to compute source hash"
            if ($ref->{text} !~ /^\\[EHW]/);
    }
    %errs = ();

    foreach my $cmd (@{$tcmds}) {
        my ($op, $src, $dst, $ref) = @{$cmd};
        if ($op eq 'cksum') {
            foreach my $hash (split(/,/, $ref->{hash})) {
                # build checksum file for -c (two spaces required before file)
                my $file = $dst;
                # strip out \ from hash since src and dst names may differ
                $hash =~ s/\\//;
                if ($file =~ s/(\n|\\)/$1 eq "\n" ? "\\n" : "\\\\"/eg) {
                    # prepend \ to hash value if dst has \ or \n in name
                    substr($hash, rindex($hash, "#") + 1, 0) = "\\";
                }
                if (defined $ref->{tar_bytes}) {
                    my ($x1, $x2) = (0, $ref->{size});
                    ($x1, $x2) = ($1, $2) if ($hash =~ /#(\d+)-(\d+)#/);
                    my ($t1, $t2) = split(/-/, $ref->{tar_bytes});
                    my $roff;
                    if ($opts{'create-tar'}) {
                        $roff = $ref->{rindex} ? $x1 + $t1 : $x1 - $t1;
                    } elsif ($opts{'extract-tar'}) {
                        $roff = $ref->{rindex} ? $x1 - $t1 : $x1 + $t1;
                    }
                    my $bytes = $roff . "-" . ($roff + ($x2 - $x1));
                    # eliminate original mutil prefix (if any)
                    $hash =~ s/^#mutil#(\d+-\d+)?#//;
                    # shift hash to new range
                    $hash = "#mutil#$bytes#$hash";
                    # need to track by bytes instead of file
                    $errs{"$dst bytes=$bytes"} = $ref;
                } elsif (defined $ref->{split}) {
                    # need to track by split instead of file
                    $errs{"$dst bytes=$ref->{bytes}"} = $ref;
                } else {
                    $errs{$dst} = $ref;
                }
                print $fh "$hash  $file\n";
            }
        }
    }

    close $fh;
    if (scalar(keys(%errs) > 0)) {
        foreach my $prog ("msum", $opts{caux}) {
            my $cmd;
            $cmd .= "$opts{ssh} $host " if ($host ne 'localhost');
            $cmd .= $prog;
            $cmd .= " sum" if ($prog eq $opts{caux});
            $cmd .= " -c --check-tree";
            $cmd .= " --double-buffer --threads=8" if ($prog eq 'msum');
            my $run;
            my $out_tmp = sftp_tmp();
            my $err_tmp = sftp_tmp();
            system("$cmd <$tmp >$out_tmp 2>$err_tmp");

            if (open(ERR, '<', $err_tmp)) {
                while (my $line = <ERR>) {
                    $line =~ s/\r?\n$//;
                    #TODO: ' and \\ are escaped in return name
                    if ($line =~ /`(.*)'/) {
                        my $file = $1;
                        my @keys = grep(/^\Q$file\E( bytes=\d+-\d+)?$/,
                            keys(%errs));
                        $errs{$_}->{text} = "\\E$line" foreach (@keys);
                    }
                }
                close ERR;
            }
            unlink $err_tmp;

            if (open(OUT, '<', $out_tmp)) {
                my $buf;
                while (my $line = <OUT>) {
                    $line = $buf . $line if (defined $buf);
                    $buf = undef;
                    # use /s modifier as \n in file names are expanded
                    if ($line =~ /^(.+):\s*(OK|FAILED)(,\S*\d)?$/s) {
                        my ($file, $ok, $bytes) = ($1, $2, $3);
                        my $ref = $errs{$file};
                        $ref = $errs{"$file bytes=" . substr($bytes, 1)}
                            if (!ref $ref && $bytes);
                        my ($x1, $x2) = split(/-/, substr($bytes, 1));
                        if (!ref $ref && $bytes) {
                            # subset of split/tar range
                            ERR: foreach my $err (values(%errs)) {
                                next if (!defined $err->{split} &&
                                        !defined $err->{tar_bytes});
                                my @ranges = split(/,/, $err->{bytes});
                                foreach my $range (@ranges) {
                                    my ($min, $max) = split(/-/, $range);
                                    if ($min <= $x1 && $x2 <= $max) {
                                        $ref = $err;
                                        last ERR;
                                    }
                                }
                            }
                        }
                        # skip if ref not found or error already recorded
                        next if (!ref $ref || $ref->{text} =~ /^\\E/);
                        if ($ok eq 'OK') {
                            $ref->{text} = "" if ($ref->{text} !~ /Corruption/);
                        } else {
                            $ref->{text} = "\\WCorruption"
                                if ($ref->{text} !~ /Corruption/);
                            if (defined $ref->{tar_bytes} && defined $x2) {
                                # adjust bytes to range within tar
                                my ($t1, $t2) = split(/-/, $ref->{tar_bytes});
                                my $roff;
                                if ($opts{'create-tar'}) {
                                    $roff = $ref->{rindex} ? $x1 : $x1 + $t1;
                                } elsif ($opts{'extract-tar'}) {
                                    $roff = $ref->{rindex} ? $x1 + $t1 : $x1;
                                }
                                $bytes = $roff . "-" . ($roff + ($x2 - $x1));
                            }
                            $bytes =~ s/^([^,])/,$1/;
                            $ref->{text} .= $bytes if ($bytes);
                        }
                        $run = 1;
                    } else {
                        # output for files with \n in name spans multiple lines
                        $buf = $line;
                    }
                }
                close OUT;
            }
            unlink $out_tmp;

            $_->{tool} = $prog foreach (values(%errs));

            # stop after the first program that runs
            last if ($run);
        }
    }
    unlink $tmp;

    foreach my $ref (values(%errs)) {
        $ref->{text} = "\\EUnable to compute destination hash"
            if (!defined $ref->{text});
    }
}

#######################
#### verify_buffer ####
#######################
sub verify_buffer {
    my ($sopts, $buf, $n_read_total) = @_;
    my $n_hash = 0;
    while ($sopts->{n_hash_total} + $sopts->{hash_leaf_size} <= $n_read_total) {
        verify_buffer_leaf($sopts, substr($buf, $n_hash,
            $sopts->{hash_leaf_size} - $sopts->{hash_ctx_len}));
        $n_hash += $sopts->{hash_leaf_size} - $sopts->{hash_ctx_len};
        $sopts->{hash_ctx_len} = 0;
        $sopts->{n_hash_total} += $sopts->{hash_leaf_size};
    }
    if ($n_read_total >= $sopts->{length}) {
        # last iteration
        if ($n_read_total > $sopts->{n_hash_total}) {
            verify_buffer_leaf($sopts, substr($buf, $n_hash,
                $n_read_total - $sopts->{n_hash_total} - $sopts->{hash_ctx_len}));
        }
    } else {
        # store in hash for next iteration
        if ($n_read_total - $sopts->{n_hash_total} > 0) {
            $sopts->{hash_ctx}->add(substr($buf, $n_hash,
                $n_read_total - $sopts->{n_hash_total} - $sopts->{hash_ctx_len}));
        }
        $sopts->{hash_ctx_len} = $n_read_total - $sopts->{n_hash_total};
    }
}

###########################
#### verify_buffer_end ####
###########################
sub verify_buffer_end {
    my $sopts = shift;
    # push empty hash onto stack if stack empty
    push(@{$sopts->{stack}}, $sopts->{hash_ctx}->digest)
        if (scalar(@{$sopts->{stack}}) == 0);
}

############################
#### verify_buffer_leaf ####
############################
sub verify_buffer_leaf {
    my ($sopts, $buf) = @_;
    my $buf_len = length $buf;
    if ($sopts->{hash_ctx_len} + $buf_len > 0 ||
            $sopts->{n_hash_total} == 0) {
        # something to hash or zero-length buffer
        # compute hash of block [start, end)
        $sopts->{hash_ctx}->add($buf) if ($buf_len > 0);
        # store hash on stack
        push(@{$sopts->{stack}}, $sopts->{hash_ctx}->digest);
    }
    return if ($sopts->{check_tree});

    my $total = $sopts->{n_hash_total} + $sopts->{hash_ctx_len} + $buf_len;
    my $total_pow2 = $total;

    # for final partial leaf node, compute hash subtree as if it were full
    if ($sopts->{hash_ctx_len} + $buf_len < $sopts->{hash_leaf_size}) {
        my $n = 1;
        my $leafs = $total / $sopts->{hash_leaf_size};
        $n <<= 1 while ($n < $leafs);
        $total_pow2 = $n * $sopts->{hash_leaf_size};
    }

    # compute hash subtree from bottom up
    my $i = 1;
    while (scalar(@{$sopts->{stack}}) >= 2 && $total_pow2 != 0 &&
            $total_pow2 / ($i * $sopts->{hash_leaf_size}) % 2 == 0) {
        if ($total_pow2 - $i * $sopts->{hash_leaf_size} < $total) {
            # compute/store hash of last two hashes on stack
            push(@{$sopts->{stack}}, md5(splice(@{$sopts->{stack}}, -2, 2)));
        }
        $i *= 2;
    }
}

########################
#### verify_default ####
########################
sub verify_default {
    my $file = shift;

    my $sopts = verify_init(@_);

    my $bytes = $sopts->{bytes};
    $bytes = "0-" . (stat($file))[7] if (!defined $bytes);
    my @ranges = split(/,/, $bytes);
    my $return;
    foreach my $range (@ranges) {
        my ($start, $stop) = split(/-/, $range);
        $sopts->{nsplits} = int(($stop - $start) / $sopts->{split_size}) + 1;
        my $hash;
        my $fh;
        if (open($fh, '<', $file)) {
            if ($sopts->{nsplits} > 1 || $sopts->{bytes}) {
                $hash .= "#mutil#";
                $hash .= "$start-$stop" if ($sopts->{bytes});
                $hash .= "#";
            }
            $hash = "\\" if ($file =~ /\\|\n/);
            if ($start == $stop) {
                $hash .= unpack("H*", md5(""));
            } elsif ($sopts->{check_tree}) {
                foreach my $split (0..$sopts->{nsplits} - 1) {
                    my $x1 = $start + $split * $sopts->{split_size};
                    my $x2 = $start + ($split + 1) * $sopts->{split_size};
                    $x2 = $stop if ($x2 > $stop);
                    my $tree = verify_hash_tree($fh, $sopts, $x1, $x2);
                    $hash .= unpack("H*", $tree);
                }
            } else {
                my $tree = verify_hash_tree($fh, $sopts, $start, $stop);
                $hash .= unpack("H*", $tree);
            }
            close $fh;
            $return .= "\\H$hash";
        } else {
            $return .= "\\E$!";
        }
    }
    return $return;
}

##########################
#### verify_hash_tree ####
##########################
# return hash tree of given file handle between given start and stop
sub verify_hash_tree {
    my ($fh, $sopts, $start, $stop) = @_;
    if ($stop - $start == 0) {
        return "";
    } elsif ($sopts->{nsplits} == 1 ||
            $stop - $start <= $sopts->{hash_leaf_size}) {
        sysseek($fh, $start, 0);
        my $buf;
        my $total = 0;
        while ($total < $stop - $start) {
            my $len = $stop - $start - $total;
            $len = $sopts->{buffer_size} if ($sopts->{buffer_size} < $len);
            my $n = sysread($fh, $buf, $len);
            last if (!defined $n);
            $sopts->{hash_ctx}->add($buf);
            $total += $n;
        }
        return $sopts->{hash_ctx}->digest;
    } else {
        # multiple splits so compute hash tree
        my $leafs = ($stop - $start) / $sopts->{hash_leaf_size};
        # compute midpoint that is power of 2
        my $n = 1;
        $n <<= 1 while ($n < $leafs);
        $n >>= 1;
        my $mid = $start + $n * $sopts->{hash_leaf_size};
        # recursively compute left subtree hash
        my $left = verify_hash_tree($fh, $sopts, $start, $mid);
        # recursively compute right subtree hash
        my $right = verify_hash_tree($fh, $sopts, $mid, $stop);
        # return just left subhash if right subhash is empty
        return $left if (!$right);
        # return hash of left subhash concatenated with right subhash
        return md5($left, $right);
    }
}

#####################
#### verify_init ####
#####################
sub verify_init {
    my %sopts = (
        buffer_size => 4,
        check_tree => 0,
        hash_ctx => Digest::MD5->new,
        hash_leaf_size => 1024 * 1024,
        split_size => 1024,
        stack => [],
        @_,
    );

    # adjust sizes to powers of 2
    foreach my $key (qw(buffer_size hash_leaf_size split_size)) {
        $sopts{$key} = 1 if ($sopts{$key} < 0);
        my $tmp = $sopts{$key};
        my $new = 1;
        $new <<= 1 while ($tmp >>= 1);
        $sopts{$key} = $new;
    }

    # scale sizes appropriately
    $sopts{buffer_size} <<= 20;
    $sopts{hash_leaf_size} <<= 10;
    $sopts{split_size} <<= 20;
    $sopts{split_size} = $sopts{buffer_size}
        if ($sopts{split_size} < $sopts{buffer_size});
    $sopts{hash_leaf_size} = $sopts{split_size}
        if ($sopts{hash_leaf_size} > $sopts{split_size});

    return \%sopts;
}

=for mesh

#############
#### vcd ####
#############
sub vcd {
    my ($ref, $host, $path, $copts) = @_;
    my $attrs = sftp($host)->stat($path);
    #TODO: pushd/popd?, set OLDPWD?
    $path =~ s/\/*$//;
    if (!$attrs) {
        sftp_echo($ref, "echo " . hostpath($host, $path) .
            ": No such file or directory");
    } elsif (!S_ISDIR($attrs->perm)) {
        sftp_echo($ref, "echo " . hostpath($host, $path) .
            ": Not a directory");
    } else {
        my $dir = dirname($sftp_sock) . "/empty";
        sftp_echo($ref, "builtin cd $dir; export PWD=" .
            hostpath($host, $path));
    }
}

################
#### vchgrp ####
################
sub vchgrp {
    return vchown(@_, 1);
}

################
#### vchmod ####
################
sub vchmod {
    my ($ref, $host, $path, $copts) = @_;
    #TODO: handle options/links/etc., ago+rwx syntax
    my $attrs = Net::SFTP::Foreign::Attributes->new;
    $attrs->set_perm(oct $copts->{-arg1});
    if (!sftp($host)->setstat($path, $attrs)) {
        sftp_error($ref, sftp($host, 1)->error);
    }
}

################
#### vchown ####
################
sub vchown {
    my ($ref, $host, $path, $copts, $chgrp) = @_;
    #TODO: handle options/links/etc.
    if (!defined $copts->{-user} && !defined $copts->{-group}) {
        my ($user, $group);
        if ($chgrp) {
            $group = $copts->{-arg1};
        } else {
            if ($copts->{-arg1} =~ /(\w+)?:(\w+)/) {
                ($user, $group) = ($1, $2);
            } else {
                $user = $copts->{-arg1};
            }
        }
        if (defined $group) {
            if ($group !~ /^\d+$/) {
                # find remote group name in remote /etc/group
                my $fh = sftp($host)->open("/etc/group");
                while (<$fh>) {
                    if (/^\Q$group\E:[^:]*:(\d+)/) {
                        $copts->{-group} = $1;
                        last;
                    }
                }
                close $fh;
                sftp_error($ref, "Invalid argument")
                    if (!defined $copts->{-group});
            } else {
                $copts->{-group} = $group;
            }
        }
        if (defined $user) {
            if ($user !~ /^\d+$/) {
                # find remote user name in remote /etc/group
                my $fh = sftp($host)->open("/etc/passwd");
                while (<$fh>) {
                    if (/^\Q$user\E:[^:]*:(\d+)/) {
                        $copts->{-user} = $1;
                        last;
                    }
                }
                close $fh;
                sftp_error($ref, "Invalid argument")
                    if (!defined $copts->{-user});
            } else {
                $copts->{-user} = $user;
            }
        }
    }
    my $attrs = sftp($host)->stat($path);
    if (!$attrs) {
        sftp_error($ref, "No such file or directory");
    } else {
        my ($user, $group) = ($attrs->uid, $attrs->gid);
        $user = $copts->{-user} if (defined $copts->{-user});
        $group = $copts->{-group} if (defined $copts->{-group});
        $attrs->set_ugid($user, $group);
        sftp_error($ref, "Operation not permitted")
            if (!sftp($host)->setstat($path, $attrs));
    }
}

###################
#### vcomplete ####
###################
sub vcomplete {
    my ($ref, $host, $path, $copts) = @_;
    my ($tmp_fh, $tmp) = sftp_tmp();
    $path .= "/" if ($copts->{-arg} =~ /\/$/);
    my @link;
    my @glob = sftp($host)->glob("$path*", follow_links => 1,
        on_error => sub {push(@link, $_[1])});
    push(@glob, @link);
    foreach (@glob) {
        print $tmp_fh $copts->{-arg};
        print $tmp_fh substr($_->{filename}, length $path);
        print $tmp_fh "/" if (S_ISDIR($_->{a}->perm));
        print $tmp_fh "\n";
    }
    close $tmp_fh;
    sftp_cmd($ref, "sort", $tmp);
}

#############
#### vcp ####
#############
sub vcp {
    vmv(@_, 1);
}

=cut mesh

#############
#### vdf ####
#############
sub vdf {
    my ($ref, $host, $path, $copts) = @_;
    if ($host eq 'localhost') {
        return if ($^O eq 'MSWin32');
        # collect disk space
        my ($pid, $in, $out);
        eval {
            local $SIG{__WARN__} = sub {die};
            # use 2s alarm in case df stalls
            local $SIG{ALRM} = sub {die};
            alarm 2;
            # use open3 to avoid executing a shell command based on the name
            # of a file being copied (which may contain metacharacters, etc.)
            alarm 0;
            $pid = open3($in, $out, $out, 'df', '-Pk', $path);
        };
        if (!$@) {
            <$out> if (scalar(@{$copts->{-argv}}) != 1);
            while (my $line = <$out>) {
                $line =~ s/\s*\r?\n$//;
                sftp_echo($ref, $line);
            }
        }
        close $in;
        close $out;
        waitpid($pid, 0) if ($pid);
    } else {
        my $df = sftp($host)->statvfs($path);
        if (defined $df && $copts->{i}) {
            sftp_echo($ref, "Filesystem\tInodes\t\tIUsed\tIFree\t\tIUse%  Mounted on")
                if (scalar(@{$copts->{-argv}}) == 1);
            sftp_echo($ref, "?\t\t$df->{files}\t" . ($df->{files} - $df->{ffree}) .
                "\t$df->{ffree}\t" . int(100 * ($df->{files} - $df->{ffree}) /
                $df->{files}) . "%\t$path");
        } elsif (defined $df) {
            sftp_echo($ref, "Filesystem\t1K-blocks\tUsed\t\tAvailable\tUse%  Mounted on")
                if (scalar(@{$copts->{-argv}}) == 1);
            my $s = $df->{bsize} / 1024.0;
            sftp_echo($ref, "?\t\t" . int($s * $df->{blocks}) . "\t" .
                int($s * ($df->{blocks} - $df->{bfree})) . "\t" .
                int($s * $df->{bfree}) . "\t" .
                int(100 * ($df->{blocks} - $df->{bfree}) /
                    $df->{blocks}) . "%\t$path");
        } else {
            sftp_error($ref, "Statvfs is not supported by the target sftp server");
        }
    }
}

=for mesh

#############
#### vdu ####
#############
sub vdu {
    my ($ref, $host, $path, $copts) = @_;
    my ($dcurr, $dmin, $dprev) = (0, $path =~ tr/\///, 0);
    my @dirs = ($path);
    my @sizes = (0);
    my %follow;
    $follow{follow_links} = 1 if ($copts->{L});
    sftp($host)->find($path,
        %follow,
        ordered => 1,
        wanted => sub {
            my $name = $_[1]->{filename};
            my $perm = $_[1]->{a}->perm;
            my $size = $_[1]->{a}->size;
            if (!$copts->{b}) {
                $size = int(($size + 1023) / 1024);
                if (S_ISDIR($perm)) {
                    $size = 4 * int($size / 4);
                } else {
                    $size = 4 * int(($size + 3) / 4);
                }
            }
            $dcurr = ($name =~ tr/\///) - $dmin;
            if (!$copts->{s}) {
                for (my $i = $dprev - 1; $i >= $dcurr; $i--) {
                    sftp_echo($ref, "$sizes[$i]\t$dirs[$i]");
                }
            }
            if (S_ISDIR($perm)) {
                $dirs[$dcurr] = $name;
                $sizes[$dcurr] = 0;
            } elsif ($copts->{a}) {
                sftp_echo($ref, "$size\t$name")
            }
            $sizes[$_] += $size for (0..$dcurr);
            $dprev = $dcurr;
            return undef;
        });
        sftp_echo($ref, "$sizes[0]\t$dirs[0]");
}

###############
#### vhead ####
###############
sub vhead {
    my ($ref, $host, $path, $copts) = @_;
    my $n = (grep(/^\d+$/, keys %{$copts}))[0];
    $n = 10 if (!defined $n);
    my $fh = sftp($host)->open($path);
    if ($fh) {
        my ($tmp_fh, $tmp) = sftp_tmp();
        while (<$fh>) {
            last if ($n-- <= 0);
            print $tmp_fh $_;
        }
        close $tmp_fh;
        close $fh;
        sftp_cmd($ref, "cat", $tmp);
    } else {
        sftp_error($ref, sftp($host, 1)->error);
    }
}

#############
#### vln ####
#############
sub vln {
    my ($ref, $copts) = @_;
    #TODO: handle opts, -f, etc.
    # do not run original spliced command
    $copts->{-argc} = 0;
    my $dpath0 = pop @{$copts->{-argv}};
    (my $dhost, $dpath0) = hostpath($dpath0);
    if ($dhost ne 'localhost') {
        my $attrs = sftp($dhost)->stat($dpath0);
        foreach my $spath0 (@{$copts->{-argv}}) {
            my $dpath = $dpath0;
            $dpath .= "/" . basename($spath0) 
                if ($attrs && S_ISDIR($attrs->perm));
            my ($shost, $spath) = hostpath($spath0);
            if ($shost ne 'localhost') {
                # link remote to remote
                if ($shost eq $dhost) {
                    sftp($dhost)->symlink($dpath, $spath);
                } else {
                    sftp($dhost)->symlink($dpath, $spath0);
                }
            } else {
                # link remote to local
                sftp_error($ref, "Cannot link remote file to local file");
            }
        }
    } else {
        # link local to remote
        foreach my $spath (@{$copts->{-argv}}) {
            next if (!hostpath($spath));
            my $dpath = $dpath0;
            $dpath .= "/" . basename($spath) if (-d $dpath0);
            symlink($spath, $dpath);
        }
    }
}

#############
#### vls ####
#############
sub vls {
    my ($ref, $host, $path, $copts) = @_;
    my @glob;
    if ($copts->{d}) {
        @glob = sftp($host)->glob($path);
    } else {
        my @link;
        @glob = sftp($host)->glob($path, follow_links => 1,
            on_error => sub {push(@link, $_[1])});
        push(@glob, @link);
    }
    my $globc = scalar(@glob);
    if (!$globc) {
        sftp_error($ref, "/$host$path: No such file or directory");
    } elsif ($copts->{-vargc}) {
        #TODO: this is wrong when path is a file and not dir
        #      probably need to do ls all at once like cp/mv
        sftp_echo($ref, "");
        sftp_echo($ref, "/$host$path:");
    } elsif ($copts->{-argc} || $copts->{-argsleft} > 0) {
        #TODO: this is wrong when path is a file and not dir
        #      probably need to do ls all at once like cp/mv
        sftp_echo($ref, "/$host$path:");
    }
    $copts->{-vargc}++;
    my $cmd = (!$copts->{l} && !$copts->{1} ? "column" : "cat");
    my $tmp = sftp_tmp();
    if ($globc) {
        open(TMP, '|-', "sort -k 9 -o $tmp");
        foreach (@glob) {
            next if (!$copts->{d} && S_ISDIR($_->{a}->perm));
            $_->{link} = sftp($host)->readlink($_->{filename})
                if ($copts->{l} && S_ISLNK($_->{a}->perm));
            print TMP sftp_ls($_, 0, $copts->{l}) . "\n";
        }
        close TMP;
        sftp_cmd($ref, $cmd, $tmp);
        $tmp = sftp_tmp();
    }
    open(TMP, '|-', "sort -k 9 -o $tmp");
    if ($globc && !$copts->{d}) {
        @glob = sftp($host)->glob("$path/*");
        #TODO: empty directories do not show up
        my $dir;
        for (my $j = 0; $j < scalar(@glob); $j++) {
            my $tdir = dirname($glob[$j]->{filename});
            if ($tdir ne $dir) {
                $dir = $tdir;
                if ($j > 0) {
                    close TMP;
                    sftp_cmd($ref, $cmd, $tmp);
                    $tmp = sftp_tmp();
                    open(TMP, '|-', "sort -k 9 -o $tmp");
                }
                if ($globc > 1) {
                    #TODO: this is wrong when path is a file and not dir
                    #      probably need to do ls all at once like cp/mv
                    sftp_echo($ref, "");
                    sftp_echo($ref, "$dir:");
                }
            }
            if ($copts->{l} && S_ISLNK($glob[$j]->{a}->perm)) {
                $glob[$j]->{link} = sftp($host)->readlink($glob[$j]->{filename});
            }
            print TMP sftp_ls($glob[$j], 1, $copts->{l}) . "\n";
        }
    }
    close TMP;
    sftp_cmd($ref, $cmd, $tmp);
}

################
#### vmkdir ####
################
sub vmkdir {
    my ($ref, $host, $path) = @_;
    my $attrs = sftp($host)->stat($path);
    if ($attrs && !S_ISDIR($attrs->perm)) {
        sftp_error($ref, "File exists");
    } elsif (!$attrs && !sftp($host)->mkdir($path)) {
        sftp_error($ref, "Permission denied");
    }
}

#############
#### vmv ####
#############
sub vmv {
    my ($ref, $copts, $cp) = @_;
    if (scalar(@{$copts->{-argv}}) == 1) {
        sftp_error($ref, "usage: " . ($cp ? "cp" : "mv") . " src ... dst");
        next;
    }
    my %shosts;
    my $dpath0 = pop @{$copts->{-argv}};
    (my $dhost, $dpath0) = hostpath($dpath0);
    if ($dhost ne 'localhost') {
        # do not run original spliced command
        $copts->{-argc} = 0;
        my $dattrs = sftp($dhost)->stat($dpath0);
        foreach my $spath (@{$copts->{-argv}}) {
            my $dpath = $dpath0;
            $dpath .= "/" . basename($spath) 
                if ($dattrs && S_ISDIR($dattrs->perm));
            (my $shost, $spath) = hostpath($spath);
            if ($shost ne 'localhost') {
                # copy remote to remote
                if ($shost eq $dhost) {
                    #TODO: check is src/dst host are the same
                    #so rename instead
                } else {
                    $shosts{$shost} = 1;
                }
                my $tmp = sftp_tmp();
                my $sattrs = sftp($shost)->stat($spath);
    #TODO: need a check about copying multiple files to a file, etc.
                if (!$sattrs) {
                    sftp_error($ref, "$spath: No such file or directory");
                    next;
                } elsif (S_ISDIR($sattrs->perm)) {
                    if (!$copts->{r} && !$copts->{R} && $cp) {
                        sftp_error($ref, "$spath is a directory");
                        next;
                    } else {
                        transport('rget', $shost, $spath, $tmp, {});
                        transport('rput', $dhost, $tmp, $dpath, {});
                        #TODO: do error checking before rm
                        transport('rrm', $shost, $spath, undef, {}) if (!$cp);
                        transport('rrm', 'localhost', $tmp, undef, {});
                    }
                } elsif (S_ISREG($sattrs->perm) || S_ISLNK($sattrs->perm)) {
                    transport('get', $shost, $spath, $tmp, {});
                    transport('put', $dhost, $tmp, $dpath, {});
                    #TODO: do error checking before rm
                    transport('rm', $shost, $spath, undef, {}) if (!$cp);
                    transport('rm', 'localhost', $tmp, undef, {});
                } else {
                    sftp_error($ref, "$spath: Not a regular file");
                    next;
                }
                #TODO: warn on non-{dir|reg|lnk}
            } else {
                # copy local to remote
                if (! -e $spath) {
                    sftp_error($ref, "$spath: No such file or directory");
                    next;
                } elsif (-d $spath) {
                    if (!$copts->{r} && !$copts->{R} && $cp) {
                        sftp_error($ref, "$spath is a directory");
                        next;
                    } else {
                        transport('rput', $dhost, $spath, $dpath, {});
                        #TODO: do error checking before rm
                        transport('rrm', 'localhost', $spath, undef, {})
                            if (!$cp);
                    }
                } elsif (-f $spath || -l $spath) {
                    transport('put', $dhost, $spath, $dpath, {});
                    transport('rm', 'localhost', $spath, undef, {}) if (!$cp);
                } else {
                    sftp_error($ref, "$spath: Not a regular file");
                    next;
                }
            }
        }
        #TODO: warn if only one arg for general case?
    } else {
        # original spliced command needs at least two args
        $copts->{-argc} = 0 if ($copts->{-argc} == 1);
        foreach my $spath (@{$copts->{-argv}}) {
            my $dpath = $dpath0;
            $dpath .= "/" . basename($spath) if (-d $dpath0);
            (my $shost, $spath) = hostpath($spath);
            if ($shost ne 'localhost') {
                # copy remote to local
                $shosts{$shost} = 1;
                my $sattrs = sftp($shost)->stat($spath);
                if (!$sattrs) {
                    sftp_error($ref, "$spath: No such file or directory");
                    next;
                } elsif (S_ISDIR($sattrs->perm)) {
                    if (!$copts->{r} && !$copts->{R} && $cp) {
                        sftp_error($ref, "$spath is a directory");
                        next;
                    } else {
                        transport('rget', $shost, $spath, $dpath, {});
                        #TODO: do error checking before rm
                        transport('rrm', $shost, $spath, undef, {}) if (!$cp);
                    }
                } elsif (S_ISREG($sattrs->perm) || S_ISLNK($sattrs->perm)) {
                    transport('get', $shost, $spath, $dpath, {});
                    #TODO: do error checking before rm
                    transport('rm', $shost, $spath, undef, {}) if (!$cp);
                } else {
                    sftp_error($ref, "$spath: Not a regular file");
                    next;
                }
            } else {
                # copy local to local
                if (! -e $spath) {
                    sftp_error($ref, "$spath: No such file or directory");
                    next;
                } elsif (-d $spath) {
                    if (!$copts->{r} && !$copts->{R} && $cp) {
                        sftp_error($ref, "$spath is a directory");
                        next;
                    } else {
                        transport('rput', 'localhost', $spath, $dpath, {});
                        #TODO: do error checking before rm
                        transport('rrm', 'localhost', $spath, undef, {})
                            if (!$cp);
                    }
                } elsif (-f $spath || -l $spath) {
                    transport('put', 'localhost', $spath, $dpath, {});
                    transport('rm', 'localhost', $spath, undef, {})
                        if (!$cp);
                } else {
                    sftp_error($ref, "$spath: Not a regular file");
                    next;
                }
            }
        }
    }
    transport('end', 'localhost');
    transport('end', $_) foreach (keys %shosts);
    transport('end', $dhost);
#TODO: this is a problem because mkdir needs to be executed first on
#      localhost but rm's needs to be last ... probably need 2 stages
# FIXED BUT NOT TESTED
    transport('end', 'localhost', 1);
}

#############
#### vrm ####
#############
sub vrm {
    my ($ref, $host, $path, $copts) = @_;
    if ($copts->{r}) {
        sftp_error($ref, sftp($host, 1)->error)
            if (!sftp($host)->rremove($path));
    } else {
        sftp_error($ref, sftp($host, 1)->error)
            if (!sftp($host)->remove($path));
    }
}

################
#### vrmdir ####
################
sub vrmdir {
    my ($ref, $host, $path, $copts) = @_;
    #TODO: directory does not exist
    sftp_error($ref, "Directory not empty or permission denied")
        if (!sftp($host)->rmdir($path));
}

###############
#### vtail ####
###############
sub vtail {
    my ($ref, $host, $path, $copts) = @_;
    my $n = (grep(/^\d+$/, keys %{$copts}))[0];
    $n = 10 if (!defined $n);
    my $fh = sftp($host)->open($path);
    if ($fh) {
        my $attrs = sftp($host)->stat($path);
        my ($seek, $block, $nl, $i, $line) = ($attrs->size, $n * 80, 0, 1);
        do {
            $seek -= $block * $i++;
            $seek = 0 if ($seek < 0);
            seek($fh, $seek, 0);
            read($fh, $line, $block);
            $nl++ while ($line =~ /\n/gs);
            my $index = 0;
            while ($nl > $n) {
                $index = index($line, "\n", $index) + 1;
                $nl--;
            }
            $seek += $index;
        } while ($seek > 0 && $nl < $n);
        my ($tmp_fh, $tmp) = sftp_tmp();
        seek($fh, $seek, 0);
        print $tmp_fh $_ while (<$fh>);
        close $tmp_fh;
        close $fh;
        sftp_cmd($ref, "cat", $tmp);
    } else {
        sftp_error($ref, sftp($host, 1)->error);
    }
}

##############
#### vtee ####
##############
sub vtee {
    my ($ref, $copts) = @_;
    # do not run original spliced command
    $copts->{-argc} = 0;
    my @fhs;
    my $append = ($copts->{a} ? ">" : "");
    my $flags = SFTP_WRITE | SFTP_CREAT;
    $flags |= SFTP_TRUNC if (!$copts->{a});
    foreach (@{$copts->{-argv}}) {
        my $fh;
        my ($host, $path) = hostpath($_);
        if ($host ne 'localhost') {
            $fh = sftp($host)->open($path, $flags);
            seek($fh, 0, 2) if ($copts->{a});
        } else {
            open($fh, "$append>", $_);
        }
        push(@fhs, $fh);
    }
#TODO: tee hangs to remote file if input from another vfs command
    while (my $line = <$ref>) {
        print $_ $line foreach (@fhs);
    }
    close $_ foreach (@fhs);
}

###############
#### vtest ####
###############
sub vtest {
    my ($ref, $host, $path, $copts) = @_;
    my $true = 0;
    my $attrs = sftp($host)->stat($path);
    # can't implement -x, -G, or -O w/o effective uid/gid
    if ($attrs && (
            $copts->{b} && S_ISBLK($attrs->perm) ||
            $copts->{c} && S_ISCHR($attrs->perm) ||
            $copts->{d} && S_ISDIR($attrs->perm) ||
            $copts->{e} ||
            $copts->{f} && S_ISREG($attrs->perm) ||
            $copts->{g} && (S_ISGID & $attrs->perm) ||
            $copts->{h} && S_ISLNK($attrs->perm) ||
            $copts->{k} && (S_ISVTX & $attrs->perm) || 
            $copts->{p} && S_ISFIFO($attrs->perm) && !S_ISSOCK($attrs->perm) ||
            $copts->{s} && $attrs->size > 0 ||
            $copts->{u} && (S_ISUID & $attrs->perm) ||
#TODO: this (maybe others) wrong because stat will never return a symlink
            $copts->{L} && S_ISLNK($attrs->perm) ||
            $copts->{S} && S_ISSOCK($attrs->perm))) {
        $true = 1;
    } elsif ($attrs && $copts->{r}) {
        my $fh = sftp($host)->open($path);
        if ($fh) {
            close $fh;
            $true = 1;
        }
    } elsif ($attrs && $copts->{w}) {
        my $fh = sftp($host)->open($path, SFTP_WRITE);
        if ($fh) {
            close $fh;
            $true = 1;
        }
    }
    sftp_cmd($ref, $true ? "true" : "false");
}

=cut mesh

################
#### vtouch ####
################
sub vtouch {
    my ($ref, $host, $path, $copts) = @_;
    my $attrs = sftp($host)->stat($path);
    if (!$attrs) {
        my $fh = sftp($host)->open($path, SFTP_CREAT | SFTP_WRITE);
        if (!$fh) {
            sftp_error($ref, "Permission denied");
        } else {
            close $fh;
        }
    } else {
        my $time = time;
        my $atime = ($copts->{a} || !$copts->{m} ? $time : $attrs->atime);
        my $mtime = ($copts->{m} || !$copts->{a} ? $time : $attrs->mtime);
        $attrs->set_amtime($atime, $mtime);
        sftp_error($ref, "Permission denied")
            if (!sftp($host)->setstat($path, $attrs));
    }
}

=for mesh

##########################
#### File::Spec::Link ####
##########################
# Copyright 2003, 2005, 2006, 2007 by Robin Barker (Robin.Barker@npl.co.uk)
# License: Perl Artistic License
package File::Spec::Link;

use strict;
use warnings;

use File::Spec ();
use base q(File::Spec); 

our $VERSION = 0.072;

# over-ridden class method - just a debugging wrapper
# 
sub canonpath { 
    my($spec, $path) = @_;
    return $spec->SUPER::canonpath($path) if $path;
    require Carp;
    Carp::cluck( "canonpath: ", 
		defined $path ? "empty path" : "path undefined"  
    );
    return $path;
}
sub catdir { my $spec = shift; return @_ ? $spec->SUPER::catdir(@_) : $spec->curdir }

# new class methods - implemented via objects
# 
sub linked { 
    my $self = shift -> new(@_); 
    return unless $self -> follow; 
    return $self -> path; 
}
sub resolve { 
    my $self = shift -> new(@_); 
    return unless $self -> resolved; 
    return $self -> path; 
}
sub resolve_all { 
    my $self = shift -> new(@_); 
    # PZK 5/07/09: return original if url
    return $_[0] if ($_[0] =~ /^(?:file:|[a-z]+:\/\/)/);
    return unless $self -> resolvedir; 
    # PZK 2/12/09: add trailing /, if originally given, for completion
    return $self -> path . (($_[0] =~ /\/$/) ? "/" : "");
#    return $self -> path; 
}
sub relative_to_file { 
    my($spec, $path) = splice @_, 0, 2;
    my $self = $spec -> new(@_); 
    return unless $self -> relative($path);
    return $self -> path;
}
sub chopfile {
    my $self = shift -> new(@_);
    return $self -> path if length($self -> chop); 
    return
}

# other new class methods - implemented via Cwd
# 
sub full_resolve {
    my($spec, $file) = @_;
    my $path = $spec->resolve_path($file);
    return defined $path ? $path : $spec->resolve_all($file);
}

sub resolve_path {
    my($spec, $file) = @_;
    my $path = do {
	local $SIG{__WARN__} = sub { 
	    if ($_[0] =~ /^opendir\b/			and
		$_[0] =~ /\bNot\s+a\s+directory\b/	and
	    	$Cwd::VERSION < 2.18		 	and
		not -d $file)
	    {
		warn <<WARN;
Cwd::abs_path() only works on directories, not: $file
Use Cwd v2.18 or later
WARN
	    }
	    else {
		warn $_[0]
	    }
	};
	eval { require Cwd } && Cwd::abs_path($file) 
    };
    return unless $path; 
    return $spec->file_name_is_absolute($file)
	    ? $path : $spec->abs2rel($path);
} 

# old class method - not needed
# 
sub splitlast { 
    my $self = shift -> new(@_);
    my $last_path = $self -> chop;
    return ($self -> path, $last_path);
}

# object methods: 
# 	constructor methods	new
# 	access methods		path, canonical, vol, dir 
# 	updating methods	add, pop, push, split, chop
# 				relative, follow, resolved, resolvedir  

sub new { 
    my $self = bless { }, shift; 
    $self -> split(shift) if @_; 
    return $self; 
}
sub path { 
    my $self = shift; 
    return $self -> catpath( $self->vol, $self->dir, q{} ); 
}
sub canonical { my $self = shift; return $self -> canonpath( $self -> path ); }
sub vol { my $vol = shift->{vol}; return defined $vol ? $vol : q{} } 
sub dir { my $self = shift; return $self -> catdir( $self -> dirs ); }
sub dirs { my $dirs = shift->{dirs}; return $dirs ? @{$dirs} : () }
	
sub add {
    my($self, $file) = @_;
    if( $file eq $self -> curdir ) { }
    elsif( $file eq $self -> updir ) { $self -> pop }
    else { $self -> push($file); }
    return;
}
sub pop {
    my $self = shift;
    my @dirs = $self -> dirs;
    if( not @dirs or $dirs[-1] eq $self -> updir ) {
	push @{$self->{dirs}}, $self -> updir;
    }
    elsif( length $dirs[-1] and $dirs[-1] ne $self -> curdir) {
	CORE::pop @{$self->{dirs}}
    }	
    else {
	require Carp;
	Carp::cluck( "Can't go up from ", 
			length $dirs[-1] ? $dirs[-1]: "empty dir"
	);
    }
    return;
}

sub push {
    my $self = shift;
    my $file = shift;
    CORE::push @{$self->{dirs}}, $file if length $file;
    return;
}
sub split {
    my($self, $path) = @_;
    my($vol, $dir, $file) = $self->splitpath($path, 1);
    $self->{vol} = $vol;
    $self->{dirs} = [ $self->splitdir($dir) ];
    $self->push($file);
    return;
}
sub chop {
    my $self = shift;
    my $dirs = $self->{dirs};
    my $file = '';
    while( @$dirs ) {
	last if @$dirs == 1 and not length $dirs->[0];	# path = '/'
	last if length($file = CORE::pop @$dirs);
    }
    return $file;    
}    
    
sub follow {
    my $self = shift;
    my $path = $self -> path;
    my $link = readlink $self->path;
    return $self->relative($link) if defined $link;
    require Carp;
    Carp::confess(
	"Can't readlink ", $self->path, 
    	" : ", 
	(-l $self->path ? "but it is" : "not"), 
	" a link"
    );
}
 
sub relative {
    my($self, $path) = @_;
    unless( $self->file_name_is_absolute($path) ) {
	return unless length($self->chop);
	$path = $self->catdir($self->path, $path);
    }
    # what we want to do here is just set $self->{path}
    # to be read by $self->path; but would need to 
    # unset $self->{path} whenever it becomes invalid
    $self->split($path);
    return 1;
}

sub resolved {
    my $self = shift;
    my $seen = @_ ? shift : {};
    while( -l $self->path ) {
	return if $seen->{$self->canonical}++;
	return unless $self->follow;
    }
    return 1;
}

sub resolvedir {
    my $self = shift;
    my $seen = @_ ? shift : {};
    my @path;
    while( 1 ) {
	return unless $self->resolved($seen);
	my $last = $self->chop;
	last unless length $last;
	unshift @path, $last;
    }
    $self->add($_) for @path;    
    return 1;
}

1;

package main;

=cut mesh

############################
#### Net::SFTP::Foreign ####
############################
# Copyright (c) 2005-2013 Salvador Fandin~o (sfandino@yahoo.com).
# Copyright (c) 2001 Benjamin Trott, Copyright (c) 2003 David Rolsky.
# _glob_to_regex method based on code (c) 2002 Richard Clamp.
# License: Perl Artistic License

sub sftp_require {
    my $dir = shift;
    # remember to always strip out Encode portions (search Encode)
    # delete from here to end and insert sftpinc.pl output
    mkdir "$dir/Net";
    mkdir "$dir/Net/SFTP";
    open(FILE, ">$dir/Net/SFTP/Foreign.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign;

our $VERSION = '1.77';

use strict;
use warnings;
use warnings::register;

use Carp qw(carp croak);

use Symbol ();
use Errno ();
use Fcntl;

# we make $Net::SFTP::Foreign::Helpers::debug an alias for
# $Net::SFTP::Foreign::debug so that the user can set it without
# knowing anything about the Helpers package!
our $debug;
BEGIN { *Net::SFTP::Foreign::Helpers::debug = \$debug };
use Net::SFTP::Foreign::Helpers qw(_is_reg _is_lnk _is_dir _debug
                                   _sort_entries _gen_wanted
                                   _gen_converter _hexdump
                                   _ensure_list _catch_tainted_args
                                   _file_part _umask_save_and_set);
use Net::SFTP::Foreign::Constants qw( :fxp :flags :att
				      :status :error
				      SSH2_FILEXFER_VERSION );
use Net::SFTP::Foreign::Attributes;
use Net::SFTP::Foreign::Buffer;
require Net::SFTP::Foreign::Common;
our @ISA = qw(Net::SFTP::Foreign::Common);

our $dirty_cleanup;
my $windows;

BEGIN {
    $windows = $^O =~ /Win(?:32|64)/;

    if ($^O =~ /solaris/i) {
	$dirty_cleanup = 1 unless defined $dirty_cleanup;
    }
}

sub _deprecated {
    if (warnings::enabled('deprecated') and warnings::enabled(__PACKAGE__)) {
        Carp::carp(join('', @_));
    }
}

sub _next_msg_id { shift->{_msg_id}++ }

use constant _empty_attributes => Net::SFTP::Foreign::Attributes->new;

sub _queue_new_msg {
    my $sftp = shift;
    my $code = shift;
    my $id = $sftp->_next_msg_id;
    my $msg = Net::SFTP::Foreign::Buffer->new(int8 => $code, int32 => $id, @_);
    $sftp->_queue_msg($msg);
    return $id;
}

sub _queue_msg {
    my ($sftp, $buf) = @_;

    my $bytes = $buf->bytes;
    my $len = length $bytes;

    if ($debug and $debug & 1) {
	$sftp->{_queued}++;
	_debug(sprintf("queueing msg len: %i, code:%i, id:%i ... [$sftp->{_queued}]",
		       $len, unpack(CN => $bytes)));

        $debug & 16 and _hexdump(pack('N', length($bytes)) . $bytes);
    }

    $sftp->{_bout} .= pack('N', length($bytes));
    $sftp->{_bout} .= $bytes;
}


sub _do_io { $_[0]->{_backend}->_do_io(@_) }

sub _conn_lost {
    my ($sftp, $status, $err, @str) = @_;

    $debug and $debug & 32 and _debug("_conn_lost");

    $sftp->{_status} or
	$sftp->_set_status(defined $status ? $status : SSH2_FX_CONNECTION_LOST);

    $sftp->{_error} or
	$sftp->_set_error((defined $err ? $err : SFTP_ERR_CONNECTION_BROKEN),
			  (@str ? @str : "Connection to remote server is broken"));

    undef $sftp->{_connected};
}

sub _conn_failed {
    my $sftp = shift;
    $sftp->_conn_lost(SSH2_FX_NO_CONNECTION,
                      SFTP_ERR_CONNECTION_BROKEN,
                      @_)
	unless $sftp->{_error};
}

sub _get_msg {
    my $sftp = shift;

    $debug and $debug & 1 and _debug("waiting for message... [$sftp->{_queued}]");

    unless ($sftp->_do_io($sftp->{_timeout})) {
	$sftp->_conn_lost(undef, undef, "Connection to remote server stalled");
	return undef;
    }

    my $bin = \$sftp->{_bin};
    my $len = unpack N => substr($$bin, 0, 4, '');
    my $msg = Net::SFTP::Foreign::Buffer->make(substr($$bin, 0, $len, ''));

    if ($debug and $debug & 1) {
	$sftp->{_queued}--;
        my ($code, $id, $status) = unpack( CNN => $$msg);
	$id = '-' if $code == SSH2_FXP_VERSION;
        $status = '-' unless $code == SSH2_FXP_STATUS;
	_debug(sprintf("got it!, len:%i, code:%i, id:%s, status: %s",
                       $len, $code, $id, $status));
        $debug & 8 and _hexdump($$msg);
    }

    return $msg;
}

sub _croak_bad_options {
    if (@_) {
        my $s = (@_ > 1 ? 's' : '');
        croak "Invalid option$s '" . CORE::join("', '", @_) . "' or bad combination of options";
    }
}

sub _fs_encode {
    my ($sftp, $path) = @_;
    $path;
}

sub _fs_decode {
    my ($sftp, $path) = @_;
    $path;
}

sub new {
    ${^TAINT} and &_catch_tainted_args;

    my $class = shift;
    unshift @_, 'host' if @_ & 1;
    my %opts = @_;

    my $sftp = { _msg_id    => 0,
		 _bout      => '',
		 _bin       => '',
		 _connected => 1,
		 _queued    => 0,
                 _error     => 0,
                 _status    => 0 };

    bless $sftp, $class;

    if ($debug) {
        _debug "This is Net::SFTP::Foreign $Net::SFTP::Foreign::VERSION";
        _debug "Loaded from $INC{'Net/SFTP/Foreign.pm'}";
        _debug "Running on Perl $^V for $^O";
        _debug "debug set to $debug";
        _debug "~0 is " . ~0;
    }

    $sftp->_clear_error_and_status;

    my $backend = delete $opts{backend};
    unless (ref $backend) {
	$backend = ($windows ? 'Windows' : 'Unix')
	    unless (defined $backend);
	$backend =~ /^\w+$/
	    or croak "Bad backend name $backend";
	my $backend_class = "Net::SFTP::Foreign::Backend::$backend";
	eval "require $backend_class; 1"
	    or croak "Unable to load backend $backend: $@";
	$backend = $backend_class->_new($sftp, \%opts);
    }
    $sftp->{_backend} = $backend;

    if ($debug) {
        my $class = ref($backend) || $backend;
        no strict 'refs';
        my $version = ${$class .'::VERSION'} || 0;
        _debug "Using backend $class $version";
    }

    my %defs = $backend->_defaults;

    $sftp->{_autodie} = delete $opts{autodie};
    $sftp->{_block_size} = delete $opts{block_size} || $defs{block_size} || 32*1024;
    $sftp->{_queue_size} = delete $opts{queue_size} || $defs{queue_size} || 32;
    $sftp->{_read_ahead} = $defs{read_ahead} || $sftp->{_block_size} * 4;
    $sftp->{_write_delay} = $defs{write_delay} || $sftp->{_block_size} * 8;
    $sftp->{_autoflush} = delete $opts{autoflush};
    $sftp->{_late_set_perm} = delete $opts{late_set_perm};
    $sftp->{_dirty_cleanup} = delete $opts{dirty_cleanup};

    $sftp->{_timeout} = delete $opts{timeout};
    defined $sftp->{_timeout} and $sftp->{_timeout} <= 0 and croak "invalid timeout";

    $sftp->{_fs_encoding} = delete $opts{fs_encoding};
    if (defined $sftp->{_fs_encoding}) {
        $] < 5.008
            and carp "fs_encoding feature is not supported in this perl version $]";
    }
    else {
        $sftp->{_fs_encoding} = 'utf8';
    }

    $sftp->autodisconnect(delete $opts{autodisconnect});

    $backend->_init_transport($sftp, \%opts);
    %opts and _croak_bad_options(keys %opts);

    $sftp->_init unless $sftp->{_error};
    $backend->_after_init($sftp);
    $sftp
}

sub autodisconnect {
    my ($sftp, $ad) = @_;
    if (defined $ad and $ad != 1) {
        if ($ad == 0) {
            $sftp->{_disconnect_by_pid} = -1;
        }
        elsif ($ad == 2) {
            $sftp->{_disconnect_by_pid} = $$;
        }
        else {
            croak "bad value '$ad' for autodisconnect";
        }
    }
    1;
}

sub disconnect {
    my $sftp = shift;
    my $pid = delete $sftp->{pid};

    $debug and $debug & 4 and _debug("$sftp->disconnect called (ssh pid: ".($pid||'').")");

    local $sftp->{_autodie};
    $sftp->_conn_lost;

    if (defined $pid) {
        close $sftp->{ssh_out} if (defined $sftp->{ssh_out} and not $sftp->{_ssh_out_is_not_dupped});
        close $sftp->{ssh_in} if defined $sftp->{ssh_in};
        if ($windows) {
	    kill KILL => $pid
                and waitpid($pid, 0);
            $debug and $debug & 4 and _debug "process $pid reaped";
        }
        else {
	    my $dirty = ( defined $sftp->{_dirty_cleanup}
			  ? $sftp->{_dirty_cleanup}
			  : $dirty_cleanup );

	    if ($dirty or not defined $dirty) {
                $debug and $debug & 4 and _debug("starting dirty cleanup of process $pid");
		for my $sig (($dirty ? () : 0), qw(TERM TERM KILL KILL)) {
                    $debug and $debug & 4 and _debug("killing process $pid with signal $sig");
		    $sig and kill $sig, $pid;

                    local ($@, $SIG{__DIE__}, $SIG{__WARN__});
                    my $wpr;
                    eval {
                        local $SIG{ALRM} = sub { die "timeout\n" };
                        alarm 8;
                        $wpr = waitpid($pid, 0);
                        alarm 0;
                    };
                    $debug and $debug & 4 and _debug("waitpid returned " . (defined $wpr ? $wpr : '<undef>'));
                    if ($wpr) {
                        # $wpr > 0 ==> the process has ben reaped
                        # $wpr < 0 ==> some error happened, retry unless ECHILD
                        last if $wpr > 0 or $! == Errno::ECHILD();
                    }
		}
	    }
	    else {
		while (1) {
		    last if waitpid($pid, 0) > 0;
		    if ($! != Errno::EINTR) {
			warn "internal error: unexpected error in waitpid($pid): $!"
			    if $! != Errno::ECHILD;
			last;
		    }
		}
	    }
            $debug and $debug & 4 and _debug "process $pid reaped";
        }
    }
    close $sftp->{_pty} if defined $sftp->{_pty};
    1
}

sub DESTROY {
    local ($?, $!, $@);

    my $sftp = shift;
    my $dbpid = $sftp->{_disconnect_by_pid};

    $debug and $debug & 4 and _debug("$sftp->DESTROY called (current pid: $$, disconnect_by_pid: ".($dbpid||'').")");

    $sftp->disconnect if (!defined $dbpid or $dbpid == $$);
}

sub _init {
    my $sftp = shift;
    $sftp->_queue_msg( Net::SFTP::Foreign::Buffer->new(int8 => SSH2_FXP_INIT,
						       int32 => SSH2_FILEXFER_VERSION));

    if (my $msg = $sftp->_get_msg) {
	my $type = $msg->get_int8;
	if ($type == SSH2_FXP_VERSION) {
	    my $version = $msg->get_int32;

	    $sftp->{server_version} = $version;
            $sftp->{server_extensions} = {};
            while (length $$msg) {
                my $key = $msg->get_str;
                my $value = $msg->get_str;
                $sftp->{server_extensions}{$key} = $value;

                if ($key eq 'vendor-id') {
                    my $vid = Net::SFTP::Foreign::Buffer->make("$value");
                    $sftp->{_ext__vendor_id} = [ $vid->get_str,
                                                 $vid->get_str,
                                                 $vid->get_str,
                                                 $vid->get_int64 ];
                }
                elsif ($key eq 'supported2') {
                    my $s2 = Net::SFTP::Foreign::Buffer->make("$value");
                    $sftp->{_ext__supported2} = [ $s2->get_int32,
                                                  $s2->get_int32,
                                                  $s2->get_int32,
                                                  $s2->get_int32,
                                                  $s2->get_int32,
                                                  $s2->get_int16,
                                                  $s2->get_int16,
                                                  [$s2->get_str_list],
                                                  [$s2->get_str_list] ];
                }
            }

	    return $version;
	}

	$sftp->_conn_lost(SSH2_FX_BAD_MESSAGE,
			  SFTP_ERR_REMOTE_BAD_MESSAGE,
			  "bad packet type, expecting SSH2_FXP_VERSION, got $type");
    }
    elsif ($sftp->{_status} == SSH2_FX_CONNECTION_LOST
	   and $sftp->{_password_authentication}
	   and $sftp->{_password_sent}) {
	$sftp->_set_error(SFTP_ERR_PASSWORD_AUTHENTICATION_FAILED,
			  "Password authentication failed or connection lost");
    }
    return undef;
}

sub server_extensions { %{shift->{server_extensions}} }

sub _check_extension {
    my ($sftp, $name, $version, $error, $errstr) = @_;
    my $ext = $sftp->{server_extensions}{$name};
    return 1 if (defined $ext and $ext == $version);

    $sftp->_set_status(SSH2_FX_OP_UNSUPPORTED);
    $sftp->_set_error($error, "$errstr: extended operation not supported by server");
    return undef;
}

# helper methods:
sub _get_msg_and_check {
    my ($sftp, $etype, $eid, $err, $errstr) = @_;
    my $msg = $sftp->_get_msg;
    if ($msg) {
	my $type = $msg->get_int8;
	my $id = $msg->get_int32;

	$sftp->_clear_error_and_status;

	if ($id != $eid) {
	    $sftp->_conn_lost(SSH2_FX_BAD_MESSAGE,
			      SFTP_ERR_REMOTE_BAD_MESSAGE,
			      $errstr, "bad packet sequence, expected $eid, got $id");
	    return undef;
	}

	if ($type != $etype) {
	    if ($type == SSH2_FXP_STATUS) {
                my $code = $msg->get_int32;
                my $str = $msg->get_str;
		my $status = $sftp->_set_status($code, (defined $str ? $str : ()));
		$sftp->_set_error($err, $errstr, $status);
	    }
	    else {
		$sftp->_conn_lost(SSH2_FX_BAD_MESSAGE,
				  SFTP_ERR_REMOTE_BAD_MESSAGE,
				  $errstr, "bad packet type, expected $etype packet, got $type");
	    }
	    return undef;
	}
    }
    $msg;
}

# reads SSH2_FXP_HANDLE packet and returns handle, or undef on failure
sub _get_handle {
    my ($sftp, $eid, $error, $errstr) = @_;
    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_HANDLE, $eid,
					    $error, $errstr)) {
	return $msg->get_str;
    }
    return undef;
}

sub _rid {
    my ($sftp, $rfh) = @_;
    my $rid = $rfh->_rid;
    unless (defined $rid) {
	$sftp->_set_error(SFTP_ERR_REMOTE_ACCESING_CLOSED_FILE,
			  "Couldn't access a file that has been previosly closed");
    }
    $rid
}

sub _rfid {
    $_[1]->_check_is_file;
    &_rid;
}

sub _rdid {
    $_[1]->_check_is_dir;
    &_rid;
}

sub _queue_rid_request {
    my ($sftp, $code, $fh, $attrs) = @_;
    my $rid = $sftp->_rid($fh);
    return undef unless defined $rid;

    $sftp->_queue_new_msg($code, str => $rid,
			 (defined $attrs ? (attr => $attrs) : ()));
}

sub _queue_rfid_request {
    $_[2]->_check_is_file;
    &_queue_rid_request;
}

sub _queue_rdid_request {
    $_[2]->_check_is_dir;
    &_queue_rid_request;
}

sub _queue_str_request {
    my($sftp, $code, $str, $attrs) = @_;
    $sftp->_queue_new_msg($code, str => $str,
			 (defined $attrs ? (attr => $attrs) : ()));
}

sub _check_status_ok {
    my ($sftp, $eid, $error, $errstr) = @_;
    if (defined $eid) {
        if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_STATUS, $eid,
                                                $error, $errstr)) {
            my $status = $sftp->_set_status($msg->get_int32, $msg->get_str);
            return 1 if $status == SSH2_FX_OK;

            $sftp->_set_error($error, $errstr, $status);
        }
    }
    return undef;
}

sub setcwd {
    @_ <= 2 or croak 'Usage: $sftp->setcwd($path)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $cwd) = @_;
    $sftp->_clear_error_and_status;

    if (defined $cwd) {
        $cwd = $sftp->realpath($cwd);
        return undef unless defined $cwd;
	my $a = $sftp->stat($cwd)
	    or return undef;
	if (_is_dir($a->perm)) {
	    return $sftp->{cwd} = $cwd;
	}
	else {
	    $sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
			      "Remote object '$cwd' is not a directory");
	    return undef;
	}
    }
    else {
        delete $sftp->{cwd};
        return $sftp->cwd if defined wantarray;
    }
}

sub cwd {
    @_ == 1 or croak 'Usage: $sftp->cwd()';

    my $sftp = shift;
    return defined $sftp->{cwd} ? $sftp->{cwd} : $sftp->realpath('');
}

## SSH2_FXP_OPEN (3)
# returns handle on success, undef on failure
sub open {
    (@_ >= 2 and @_ <= 4)
	or croak 'Usage: $sftp->open($path [, $flags [, $attrs]])';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $path, $flags, $a) = @_;
    $path = $sftp->_rel2abs($path);
    defined $flags or $flags = SSH2_FXF_READ;
    defined $a or $a = Net::SFTP::Foreign::Attributes->new;
    my $id = $sftp->_queue_new_msg(SSH2_FXP_OPEN,
                                   str => $sftp->_fs_encode($path),
                                   int32 => $flags, attr => $a);

    my $rid = $sftp->_get_handle($id,
				SFTP_ERR_REMOTE_OPEN_FAILED,
				"Couldn't open remote file '$path'");

    if ($debug and $debug & 2) {
        if (defined $rid) {
            _debug("new remote file '$path' open, rid:");
            _hexdump($rid);
        }
        else {
            _debug("open failed: $sftp->{_status}");
        }
    }

    defined $rid or return undef;

    my $fh = Net::SFTP::Foreign::FileHandle->_new_from_rid($sftp, $rid);
    $fh->_flag(append => 1) if ($flags & SSH2_FXF_APPEND);

    $fh;
}

## SSH2_FXP_OPENDIR (11)
sub opendir {
    @_ == 2 or croak 'Usage: $sftp->opendir($path)';
    ${^TAINT} and &_catch_tainted_args;

    my $sftp = shift;
    my $path = shift;
    $path = $sftp->_rel2abs($path);
    my $id = $sftp->_queue_str_request(SSH2_FXP_OPENDIR, $sftp->_fs_encode($path), @_);
    my $rid = $sftp->_get_handle($id, SFTP_ERR_REMOTE_OPENDIR_FAILED,
				 "Couldn't open remote dir '$path'");

    if ($debug and $debug & 2) {
        _debug("new remote dir '$path' open, rid:");
        _hexdump($rid);
    }

    defined $rid
	or return undef;

    Net::SFTP::Foreign::DirHandle->_new_from_rid($sftp, $rid, 0)
}

## SSH2_FXP_READ (4)
# returns data on success undef on failure
sub sftpread {
    (@_ >= 3 and @_ <= 4)
	or croak 'Usage: $sftp->sftpread($fh, $offset [, $size])';

    my ($sftp, $rfh, $offset, $size) = @_;

    unless ($size) {
	return '' if defined $size;
	$size = $sftp->{_block_size};
    }

    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or return undef;

    my $id = $sftp->_queue_new_msg(SSH2_FXP_READ, str=> $rfid,
				  int64 => $offset, int32 => $size);

    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_DATA, $id,
					    SFTP_ERR_REMOTE_READ_FAILED,
					    "Couldn't read from remote file")) {
	return $msg->get_str;
    }
    return undef;
}

## SSH2_FXP_WRITE (6)
# returns true on success, undef on failure
sub sftpwrite {
    @_ == 4 or croak 'Usage: $sftp->sftpwrite($fh, $offset, $data)';

    my ($sftp, $rfh, $offset) = @_;
    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or return undef;
    utf8::downgrade($_[3], 1) or croak "wide characters found in data";

    my $id = $sftp->_queue_new_msg(SSH2_FXP_WRITE, str => $rfid,
				  int64 => $offset, str => $_[3]);

    if ($sftp->_check_status_ok($id,
				SFTP_ERR_REMOTE_WRITE_FAILED,
				"Couldn't write to remote file")) {
	return 1;
    }
    return undef;
}

sub seek {
    (@_ >= 3 and @_ <= 4)
	or croak 'Usage: $sftp->seek($fh, $pos [, $whence])';

    my ($sftp, $rfh, $pos, $whence) = @_;
    $sftp->flush($rfh) or return undef;

    if (!$whence) {
        $rfh->_pos($pos)
    }
    elsif ($whence == 1) {
        $rfh->_inc_pos($pos)
    }
    elsif ($whence == 2) {
	my $a = $sftp->stat($rfh) or return undef;
        $rfh->_pos($pos + $a->size);
    }
    else {
	croak "invalid value for whence argument ('$whence')";
    }
    1;
}

sub tell {
    @_ == 2 or croak 'Usage: $sftp->tell($fh)';

    my ($sftp, $rfh) = @_;
    return $rfh->_pos + length ${$rfh->_bout};
}

sub eof {
    @_ == 2 or croak 'Usage: $sftp->eof($fh)';

    my ($sftp, $rfh) = @_;
    $sftp->_fill_read_cache($rfh, 1);
    return length(${$rfh->_bin}) == 0
}

sub _write {
    my ($sftp, $rfh, $off, $cb) = @_;

    $sftp->_clear_error_and_status;

    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or return undef;

    my $qsize = $sftp->{_queue_size};

    my @msgid;
    my @written;
    my $written = 0;
    my $end;

    while (!$end or @msgid) {
	while (!$end and @msgid < $qsize) {
	    my $data = $cb->();
	    if (defined $data and length $data) {
		my $id = $sftp->_queue_new_msg(SSH2_FXP_WRITE, str => $rfid,
					      int64 => $off + $written, str => $data);
		push @written, $written;
		$written += length $data;
		push @msgid, $id;
	    }
	    else {
		$end = 1;
	    }
	}

	my $eid = shift @msgid;
	my $last = shift @written;
	unless ($sftp->_check_status_ok($eid,
					SFTP_ERR_REMOTE_WRITE_FAILED,
					"Couldn't write to remote file")) {

	    # discard responses to queued requests:
	    $sftp->_get_msg for @msgid;
	    return $last;
	}
    }

    return $written;
}

sub write {
    @_ == 3 or croak 'Usage: $sftp->write($fh, $data)';

    my ($sftp, $rfh) = @_;
    $sftp->flush($rfh, 'in') or return undef;
    utf8::downgrade($_[2], 1) or croak "wide characters found in data";
    my $datalen = length $_[2];
    my $bout = $rfh->_bout;
    $$bout .= $_[2];
    my $len = length $$bout;

    $sftp->flush($rfh, 'out')
	if ($len >= $sftp->{_write_delay} or ($len and $sftp->{_autoflush} ));

    return $datalen;
}

sub flush {
    (@_ >= 2 and @_ <= 3)
	or croak 'Usage: $sftp->flush($fh [, $direction])';

    my ($sftp, $rfh, $dir) = @_;
    $dir ||= '';

    if ($dir ne 'out') { # flush in!
	${$rfh->_bin} = '';
    }

    if ($dir ne 'in') { # flush out!
	my $bout = $rfh->_bout;
	my $len = length $$bout;
	if ($len) {
	    my $start;
	    my $append = $rfh->_flag('append');
	    if ($append) {
		my $attr = $sftp->stat($rfh)
		    or return undef;
		$start = $attr->size;
	    }
	    else {
		$start = $rfh->_pos;
		${$rfh->_bin} = '';
	    }
	    my $off = 0;
	    my $written = $sftp->_write($rfh, $start,
					sub {
					    my $data = substr($$bout, $off, $sftp->{_block_size});
					    $off += length $data;
					    $data;
					} );
	    $rfh->_inc_pos($written)
		unless $append;

	    substr($$bout, 0, $written, '');
	    $written == $len or return undef;
	}
    }
    1;
}

sub _fill_read_cache {
    my ($sftp, $rfh, $len) = @_;

    $sftp->_clear_error_and_status;

    $sftp->flush($rfh, 'out')
	or return undef;

    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or return undef;

    my $bin = $rfh->_bin;

    if (defined $len) {
	return 1 if ($len < length $$bin);

	my $read_ahead = $sftp->{_read_ahead};
	$len = length($$bin) + $read_ahead
	    if $len - length($$bin) < $read_ahead;
    }

    my $pos = $rfh->_pos;

    my $qsize = $sftp->{_queue_size};
    my $bsize = $sftp->{_block_size};

    my @msgid;
    my $askoff = length $$bin;
    my $eof;

    while (!defined $len or length $$bin < $len) {
	while ((!defined $len or $askoff < $len) and @msgid < $qsize) {
	    my $id = $sftp->_queue_new_msg(SSH2_FXP_READ, str=> $rfid,
					  int64 => $pos + $askoff, int32 => $bsize);
	    push @msgid, $id;
	    $askoff += $bsize;
	}

	my $eid = shift @msgid;
	my $msg = $sftp->_get_msg_and_check(SSH2_FXP_DATA, $eid,
					    SFTP_ERR_REMOTE_READ_FAILED,
					    "Couldn't read from remote file")
	    or last;

	my $data = $msg->get_str;
	$$bin .= $data;
	if (length $data < $bsize) {
	    unless (defined $len) {
		$eof = $sftp->_queue_new_msg(SSH2_FXP_READ, str=> $rfid,
					     int64 => $pos + length $$bin, int32 => 1);
	    }
	    last;
	}

    }

    $sftp->_get_msg for @msgid;

    if ($eof) {
	$sftp->_get_msg_and_check(SSH2_FXP_DATA, $eof,
				  SFTP_ERR_REMOTE_BLOCK_TOO_SMALL,
				  "received block was too small")
    }

    if ($sftp->{_status} == SSH2_FX_EOF and length $$bin) {
	$sftp->_clear_error_and_status;
    }

    return $sftp->{_error} ? undef : length $$bin;
}

sub read {
    @_ == 3 or croak 'Usage: $sftp->read($fh, $len)';

    my ($sftp, $rfh, $len) = @_;
    if ($sftp->_fill_read_cache($rfh, $len)) {
	my $bin = $rfh->_bin;
	my $data = substr($$bin, 0, $len, '');
	$rfh->_inc_pos(length $data);
	return $data;
    }
    return undef;
}

sub _readline {
    my ($sftp, $rfh, $sep) = @_;

    $sep = "\n" if @_ < 3;

    my $sl = length $sep;

    my $bin = $rfh->_bin;
    my $last = 0;

    while(1) {
	my $ix = index $$bin, $sep, $last + 1 - $sl ;
	if ($ix >= 0) {
	    $ix += $sl;
	    $rfh->_inc_pos($ix);
	    return substr($$bin, 0, $ix, '');
	}

	$last = length $$bin;
	$sftp->_fill_read_cache($rfh, length($$bin) + 1);

	unless (length $$bin > $last) {
	    $sftp->{_error}
		and return undef;

	    my $line = $$bin;
	    $rfh->_inc_pos(length $line);
	    $$bin = '';
	    return $line;
	}
    }
}

sub readline {
    (@_ >= 2 and @_ <= 3)
	or croak 'Usage: $sftp->readline($fh [, $sep])';

    my ($sftp, $rfh, $sep) = @_;
    $sep = "\n" if @_ < 3;
    if (!defined $sep or $sep eq '') {
	$sftp->_fill_read_cache($rfh);
	$sftp->{_error}
	    and return undef;
	my $bin = $rfh->_bin;
	my $line = $$bin;
	$rfh->_inc_pos(length $line);
	$$bin = '';
	return $line;
    }
    if (wantarray) {
	my @lines;
	while (defined (my $line = $sftp->_readline($rfh, $sep))) {
	    push @lines, $line;
	}
	return @lines;
    }
    return $sftp->_readline($rfh, $sep);
}

sub getc {
    @_ == 2 or croak 'Usage: $sftp->getc($fh)';

    my ($sftp, $rfh) = @_;

    $sftp->_fill_read_cache($rfh, 1);
    my $bin = $rfh->_bin;
    if (length $bin) {
	$rfh->_inc_pos(1);
	return substr $$bin, 0, 1, '';
    }
    return undef;
}

## SSH2_FXP_LSTAT (7), SSH2_FXP_FSTAT (8), SSH2_FXP_STAT (17)
# these all return a Net::SFTP::Foreign::Attributes object on success, undef on failure

sub lstat {
    @_ <= 2 or croak 'Usage: $sftp->lstat($path)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $path) = @_;
    $path = '.' unless defined $path;
    $path = $sftp->_rel2abs($path);
    my $id = $sftp->_queue_str_request(SSH2_FXP_LSTAT, $sftp->_fs_encode($path));
    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_ATTRS, $id,
                                            SFTP_ERR_REMOTE_LSTAT_FAILED, "Couldn't stat remote link")) {
        return $msg->get_attributes;
    }
    return undef;
}

sub stat {
    @_ <= 2 or croak 'Usage: $sftp->stat($path_or_fh)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $pofh) = @_;
    $pofh = '.' unless defined $pofh;
    my $id = $sftp->_queue_new_msg( (ref $pofh and UNIVERSAL::isa($pofh, 'Net::SFTP::Foreign::FileHandle'))
                                    ? ( SSH2_FXP_FSTAT, str => $sftp->_rid($pofh))
                                    : ( SSH2_FXP_STAT,  str => $sftp->_fs_encode($sftp->_rel2abs($pofh))) );
    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_ATTRS, $id,
                                            SFTP_ERR_REMOTE_STAT_FAILED, "Couldn't stat remote file")) {
        return $msg->get_attributes;
    }
    return undef;
}

sub fstat {
    _deprecated "fstat is deprecated and will be removed on the upcomming 2.xx series, "
        . "stat method accepts now both file handlers and paths";
    goto &stat;
}

## SSH2_FXP_RMDIR (15), SSH2_FXP_REMOVE (13)
# these return true on success, undef on failure

sub _gen_remove_method {
    my($name, $code, $error, $errstr) = @_;
    my $sub = sub {
	@_ == 2 or croak "Usage: \$sftp->$name(\$path)";
        ${^TAINT} and &_catch_tainted_args;

        my ($sftp, $path) = @_;
        $path = $sftp->_rel2abs($path);
        my $id = $sftp->_queue_str_request($code, $sftp->_fs_encode($path));
        return $sftp->_check_status_ok($id, $error, $errstr);
    };
    no strict 'refs';
    *$name = $sub;
}

_gen_remove_method(remove => SSH2_FXP_REMOVE,
                   SFTP_ERR_REMOTE_REMOVE_FAILED, "Couldn't delete remote file");
_gen_remove_method(rmdir => SSH2_FXP_RMDIR,
                   SFTP_ERR_REMOTE_RMDIR_FAILED, "Couldn't remove remote directory");

## SSH2_FXP_MKDIR (14), SSH2_FXP_SETSTAT (9)
# these return true on success, undef on failure

sub mkdir {
    (@_ >= 2 and @_ <= 3)
        or croak 'Usage: $sftp->mkdir($path [, $attrs])';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $path, $attrs) = @_;
    $attrs = _empty_attributes unless defined $attrs;
    $path = $sftp->_rel2abs($path);
    my $id = $sftp->_queue_str_request(SSH2_FXP_MKDIR,
                                       $sftp->_fs_encode($path),
                                       $attrs);
    return $sftp->_check_status_ok($id,
                                   SFTP_ERR_REMOTE_MKDIR_FAILED,
                                   "Couldn't create remote directory");
}

sub join {
    my $sftp = shift;
    my $a = '.';
    while (@_) {
	my $b = shift;
	if (defined $b) {
	    $b =~ s|^(?:\./+)+||;
	    if (length $b and $b ne '.') {
		if ($b !~ m|^/| and $a ne '.' ) {
		    $a = ($a =~ m|/$| ? "$a$b" : "$a/$b");
		}
		else {
		    $a = $b
		}
		$a =~ s|(?:/+\.)+/?$|/|;
		$a =~ s|(?<=[^/])/+$||;
		$a = '.' unless length $a;
	    }
	}
    }
    $a;
}

sub _rel2abs {
    my ($sftp, $path) = @_;
    my $old = $path;
    my $cwd = $sftp->{cwd};
    $path = $sftp->join($sftp->{cwd}, $path);
    $debug and $debug & 4096 and _debug("'$old' --> '$path'");
    return $path
}

sub mkpath {
    (@_ >= 2 and @_ <= 3)
        or croak 'Usage: $sftp->mkpath($path [, $attrs])';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $path, $attrs) = @_;
    $sftp->_clear_error_and_status;

    $path =~ s{^(/*)}{};
    my $start = $1;
    my @path;
    while (1) {
	my $p = "$start$path";
	$debug and $debug & 8192 and _debug "checking $p";
	if ($sftp->test_d($p)) {
	    $debug and $debug & 8192 and _debug "$p is a dir";
	    last;
	}
	unless (length $path) {
	    $sftp->_set_error(SFTP_ERR_REMOTE_MKDIR_FAILED,
                              "Unable to make path, bad root");
	    return undef;
	}
	unshift @path, $p;
	$path =~ s{/*[^/]*$}{};
    }
    for my $p (@path) {
	$debug and $debug & 8192 and _debug "mkdir $p";
	if ($p =~ m{^(?:.*/)?\.{1,2}$} or $p =~ m{/$}) {
	    $debug and $debug & 8192 and _debug "$p is a symbolic dir, skipping";
	    unless ($sftp->test_d($p)) {
		$debug and $debug & 8192 and _debug "symbolic dir $p can not be checked";
		$sftp->{_error} or
		    $sftp->_set_error(SFTP_ERR_REMOTE_MKDIR_FAILED,
				      "Unable to make path, bad name");
		return undef;
	    }
	}
	else {
	    $sftp->mkdir($p, $attrs)
                or return undef;
	}
    }
    1;
}


sub setstat {
    @_ == 3 or croak 'Usage: $sftp->setstat($path_or_fh, $attrs)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $pofh, $attrs) = @_;
    my $id = $sftp->_queue_new_msg( ( (ref $pofh and UNIVERSAL::isa($pofh, 'Net::SFTP::Foreign::FileHandle') )
                                      ? ( SSH2_FXP_FSETSTAT, str => $sftp->_rid($pofh) )
                                      : ( SSH2_FXP_SETSTAT,  str => $sftp->_fs_encode($sftp->_rel2abs($pofh)) ) ),
                                    attr => $attrs );
    return $sftp->_check_status_ok($id,
                                   SFTP_ERR_REMOTE_SETSTAT_FAILED,
                                   "Couldn't setstat remote file");
}

## SSH2_FXP_CLOSE (4), SSH2_FXP_FSETSTAT (10)
# these return true on success, undef on failure

sub fsetstat {
    _deprecated "fsetstat is deprecated and will be removed on the upcomming 2.xx series, "
        . "setstat method accepts now both file handlers and paths";
    goto &setstat;
}

sub _gen_setstat_shortcut {
    my ($name, $rid_type, $attrs_flag, @arg_types) = @_;
    my $nargs = 2 + @arg_types;
    my $usage = ("\$sftp->$name("
                 . CORE::join(', ', '$path_or_fh', map "arg$_", 1..@arg_types)
                 . ')');
    my $rid_method = ($rid_type eq 'file' ? '_rfid' :
                      $rid_type eq 'dir'  ? '_rdid' :
                      $rid_type eq 'any'  ? '_rid'  :
                      croak "bad rid type $rid_type");
    my $sub = sub {
        @_ == $nargs or croak $usage;
        my $sftp = shift;
        my $pofh = shift;
        my $id = $sftp->_queue_new_msg( ( (ref $pofh and UNIVERSAL::isa($pofh, 'Net::SFTP::Foreign::FileHandle') )
                                          ? ( SSH2_FXP_FSETSTAT, str => $sftp->$rid_method($pofh) )
                                          : ( SSH2_FXP_SETSTAT,  str => $sftp->_fs_encode($sftp->_rel2abs($pofh)) ) ),
                                        int32 => $attrs_flag,
                                        map { $arg_types[$_] => $_[$_] } 0..$#arg_types );
        $sftp->_check_status_ok($id,
                                SFTP_ERR_REMOTE_SETSTAT_FAILED,
                                "Couldn't setstat remote file ($name)");
    };
    no strict 'refs';
    *$name = $sub;
}

_gen_setstat_shortcut(truncate => 'file', SSH2_FILEXFER_ATTR_SIZE,        'int64');
_gen_setstat_shortcut(chown    => 'any' , SSH2_FILEXFER_ATTR_UIDGID,      'int32', 'int32');
_gen_setstat_shortcut(chmod    => 'any' , SSH2_FILEXFER_ATTR_PERMISSIONS, 'int32');
_gen_setstat_shortcut(utime    => 'any' , SSH2_FILEXFER_ATTR_ACMODTIME,   'int32', 'int32');

sub _close {
    @_ == 2 or croak 'Usage: $sftp->close($fh, $attrs)';

    my $sftp = shift;
    my $id = $sftp->_queue_rid_request(SSH2_FXP_CLOSE, @_);
    defined $id or return undef;

    my $ok = $sftp->_check_status_ok($id,
                                     SFTP_ERR_REMOTE_CLOSE_FAILED,
                                     "Couldn't close remote file");

    if ($debug and $debug & 2) {
        _debug sprintf("closing file handle, return: %s, rid:", (defined $ok ? $ok : '-'));
        _hexdump($sftp->_rid($_[0]));
    }

    return $ok;
}

sub close {
    @_ == 2 or croak 'Usage: $sftp->close($fh)';

    my ($sftp, $rfh) = @_;
    $rfh->_check_is_file;
    $sftp->flush($rfh)
	or return undef;

    if ($sftp->_close($rfh)) {
	$rfh->_close;
	return 1
    }
    undef
}

sub closedir {
    @_ == 2 or croak 'Usage: $sftp->closedir($dh)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $rdh) = @_;
    $rdh->_check_is_dir;

    if ($sftp->_close($rdh)) {
	$rdh->_close;
	return 1;
    }
    undef
}

sub readdir {
    @_ == 2 or croak 'Usage: $sftp->readdir($dh)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $rdh) = @_;

    my $rdid = $sftp->_rdid($rdh);
    defined $rdid or return undef;

    my $cache = $rdh->_cache;

    while (!@$cache or wantarray) {
	my $id = $sftp->_queue_str_request(SSH2_FXP_READDIR, $rdid);
	if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_NAME, $id,
						SFTP_ERR_REMOTE_READDIR_FAILED,
						"Couldn't read remote directory" )) {
	    my $count = $msg->get_int32 or last;

	    for (1..$count) {
		push @$cache, { filename => $sftp->_fs_decode($msg->get_str),
				longname => $sftp->_fs_decode($msg->get_str),
				a => $msg->get_attributes };
	    }
	}
	else {
	    $sftp->_set_error if $sftp->{_status} == SSH2_FX_EOF;
	    last;
	}
    }

    if (wantarray) {
	my $old = $cache;
	$cache = [];
	return @$old;
    }
    shift @$cache;
}

sub _readdir {
    my ($sftp, $rdh);
    if (wantarray) {
	my $line = $sftp->readdir($rdh);
	if (defined $line) {
	    return $line->{filename};
	}
    }
    else {
	return map { $_->{filename} } $sftp->readdir($rdh);
    }
}

sub _gen_getpath_method {
    my ($code, $error, $name) = @_;
    return sub {
	@_ == 2 or croak 'Usage: $sftp->some_method($path)';
        ${^TAINT} and &_catch_tainted_args;

	my ($sftp, $path) = @_;
	$path = $sftp->_rel2abs($path);
	my $id = $sftp->_queue_str_request($code, $sftp->_fs_encode($path));

	if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_NAME, $id,
						$error,
						"Couldn't get $name for remote '$path'")) {
	    $msg->get_int32 > 0
		and return $sftp->_fs_decode($msg->get_str);

	    $sftp->_set_error($error,
			      "Couldn't get $name for remote '$path', no names on reply")
	}
	return undef;
    };
}

## SSH2_FXP_REALPATH (16)
## SSH2_FXP_READLINK (19)
# return path on success, undef on failure
*realpath = _gen_getpath_method(SSH2_FXP_REALPATH,
				SFTP_ERR_REMOTE_REALPATH_FAILED,
				"realpath");
*readlink = _gen_getpath_method(SSH2_FXP_READLINK,
				SFTP_ERR_REMOTE_READLINK_FAILED,
				"link target");

## SSH2_FXP_RENAME (18)
# true on success, undef on failure

sub _rename {
    my ($sftp, $old, $new) = @_;

    $old = $sftp->_rel2abs($old);
    $new = $sftp->_rel2abs($new);

    my $id = $sftp->_queue_new_msg(SSH2_FXP_RENAME,
                                   str => $sftp->_fs_encode($old),
                                   str => $sftp->_fs_encode($new));

    $sftp->_check_status_ok($id, SFTP_ERR_REMOTE_RENAME_FAILED,
                            "Couldn't rename remote file '$old' to '$new'");
}

sub rename {
    (@_ & 1) or croak 'Usage: $sftp->rename($old, $new, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $old, $new, %opts) = @_;

    my $overwrite = delete $opts{overwrite};
    my $numbered = delete $opts{numbered};
    croak "'overwrite' and 'numbered' options can not be used together"
        if ($overwrite and $numbered);
    %opts and _croak_bad_options(keys %opts);

    if ($overwrite) {
        $sftp->atomic_rename($old, $new) and return 1;
        $sftp->{_status} != SSH2_FX_OP_UNSUPPORTED and return undef;
    }

    for (1) {
        local $sftp->{_autodie};
        # we are optimistic here and try to rename it without testing
        # if a file of the same name already exists first
        if (!$sftp->_rename($old, $new) and
            $sftp->{_status} == SSH2_FX_FAILURE) {
            if ($numbered and $sftp->test_e($new)) {
                _inc_numbered($new);
                redo;
            }
            elsif ($overwrite) {
                my $rp_old = $sftp->realpath($old);
                my $rp_new = $sftp->realpath($new);
                if (defined $rp_old and defined $rp_new and $rp_old eq $rp_new) {
                    $sftp->_clear_error_and_status;
                }
                elsif ($sftp->remove($new)) {
                    $overwrite = 0;
                    redo;
                }
            }
        }
    }
    $sftp->_ok_or_autodie;
}

sub atomic_rename {
    @_ == 3 or croak 'Usage: $sftp->atomic_rename($old, $new)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $old, $new) = @_;

    $sftp->_check_extension('posix-rename@openssh.com' => 1,
                             SFTP_ERR_REMOTE_RENAME_FAILED,
                            "atomic rename failed")
        or return undef;

    $old = $sftp->_rel2abs($old);
    $new = $sftp->_rel2abs($new);

    my $id = $sftp->_queue_new_msg(SSH2_FXP_EXTENDED,
                                   str => 'posix-rename@openssh.com',
                                   str => $sftp->_fs_encode($old),
                                   str => $sftp->_fs_encode($new));

    $sftp->_check_status_ok($id, SFTP_ERR_REMOTE_RENAME_FAILED,
                            "Couldn't rename remote file '$old' to '$new'");
}

## SSH2_FXP_SYMLINK (20)
# true on success, undef on failure
sub symlink {
    @_ == 3 or croak 'Usage: $sftp->symlink($sl, $target)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $sl, $target) = @_;
    $sl = $sftp->_rel2abs($sl);
    my $id = $sftp->_queue_new_msg(SSH2_FXP_SYMLINK,
                                   str => $sftp->_fs_encode($target),
                                   str => $sftp->_fs_encode($sl));

    $sftp->_check_status_ok($id, SFTP_ERR_REMOTE_SYMLINK_FAILED,
                            "Couldn't create symlink '$sl' pointing to '$target'");
}

sub hardlink {
    @_ == 3 or croak 'Usage: $sftp->hardlink($hl, $target)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $hl, $target) = @_;

    $sftp->_check_extension('hardlink@openssh.com' => 1,
                            SFTP_ERR_REMOTE_HARDLINK_FAILED,
                            "hardlink failed")
        or return undef;
    $hl = $sftp->_rel2abs($hl);
    $target = $sftp->_rel2abs($target);

    my $id = $sftp->_queue_new_msg(SSH2_FXP_EXTENDED,
                                   str => 'hardlink@openssh.com',
                                   str => $sftp->_fs_encode($target),
                                   str => $sftp->_fs_encode($hl));
    $sftp->_check_status_ok($id, SFTP_ERR_REMOTE_HARDLINK_FAILED,
                            "Couldn't create hardlink '$hl' pointing to '$target'");
}

sub _gen_save_status_method {
    my $method = shift;
    sub {
	my $sftp = shift;
        local ($sftp->{_error}, $sftp->{_status}) if $sftp->{_error};
	$sftp->$method(@_);
    }
}


*_close_save_status = _gen_save_status_method('close');
*_closedir_save_status = _gen_save_status_method('closedir');
*_remove_save_status = _gen_save_status_method('remove');

sub _inc_numbered {
    $_[0] =~ s{^(.*)\((\d+)\)((?:\.[^\.]*)?)$}{"$1(" . ($2+1) . ")$3"}e or
    $_[0] =~ s{((?:\.[^\.]*)?)$}{(1)$1};
    $debug and $debug & 128 and _debug("numbering to: $_[0]");
}

## High-level client -> server methods.

sub abort {
    my $sftp = shift;
    $sftp->_set_error(SFTP_ERR_ABORTED, ($@ ? $_[0] : "Aborted"));
}

# returns true on success, undef on failure
sub get {
    @_ >= 2 or croak 'Usage: $sftp->get($remote, $local, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $remote, $local, %opts) = @_;
    defined $remote or croak "remote file path is undefined";

    $sftp->_clear_error_and_status;

    $remote = $sftp->_rel2abs($remote);
    $local = _file_part($remote) unless defined $local;
    my $local_is_fh = (ref $local and $local->isa('GLOB'));

    my $cb = delete $opts{callback};
    my $umask = delete $opts{umask};
    my $perm = delete $opts{perm};
    my $copy_perm = delete $opts{exists $opts{copy_perm} ? 'copy_perm' : 'copy_perms'};
    my $copy_time = delete $opts{copy_time};
    my $overwrite = delete $opts{overwrite};
    my $resume = delete $opts{resume};
    my $append = delete $opts{append};
    my $block_size = delete $opts{block_size} || $sftp->{_block_size};
    my $queue_size = delete $opts{queue_size} || $sftp->{_queue_size};
    my $dont_save = delete $opts{dont_save};
    my $conversion = delete $opts{conversion};
    my $numbered = delete $opts{numbered};
    my $cleanup = delete $opts{cleanup};
    my $atomic = delete $opts{atomic};
    my $best_effort = delete $opts{best_effort};

    croak "'perm' and 'copy_perm' options can not be used simultaneously"
	if (defined $perm and defined $copy_perm);
    croak "'resume' and 'append' options can not be used simultaneously"
	if ($resume and $append);
    croak "'numbered' can not be used with 'overwrite', 'resume' or 'append'"
	if ($numbered and ($overwrite or $resume or $append));
    croak "'atomic' can not be used with 'resume' or 'append'"
        if ($atomic and ($resume or $append));
    if ($local_is_fh) {
	my $append = 'option can not be used when target is a file handle';
	$resume and croak "'resume' $append";
	$overwrite and croak "'overwrite' $append";
	$numbered and croak "'numbered' $append";
	$dont_save and croak "'dont_save' $append";
        $atomic and croak "'croak' $append";
    }
    %opts and _croak_bad_options(keys %opts);

    if ($resume and $conversion) {
        carp "resume option is useless when data conversion has also been requested";
        undef $resume;
    }

    $overwrite = 1 unless (defined $overwrite or $local_is_fh or $numbered);
    $copy_perm = 1 unless (defined $perm or defined $copy_perm or $local_is_fh);
    $copy_time = 1 unless (defined $copy_time or $local_is_fh);
    $cleanup = ($atomic || $numbered) unless defined $cleanup;

    my $a = do {
        local $sftp->{_autodie};
        $sftp->stat($remote);
    };
    my ($rperm, $size, $atime, $mtime) = ($a ? ($a->perm, $a->size, $a->atime, $a->mtime) : ());
    $size = -1 unless defined $size;

    if ($copy_time and not defined $atime) {
        if ($best_effort) {
            undef $copy_time;
        }
        else {
            $sftp->_ok_or_autodie and $sftp->_set_error(SFTP_ERR_REMOTE_STAT_FAILED,
                                                        "Not enough information on stat, amtime not included");
            return undef;
        }
    }

    $umask = (defined $perm ? 0 : umask) unless defined $umask;
    if ($copy_perm) {
        if (defined $rperm) {
            $perm = $rperm;
        }
        elsif ($best_effort) {
            undef $copy_perm
        }
        else {
            $sftp->_ok_or_autodie and $sftp->_set_error(SFTP_ERR_REMOTE_STAT_FAILED,
                                                        "Not enough information on stat, mode not included");
            return undef
        }
    }
    $perm &= ~$umask if defined $perm;

    $sftp->_clear_error_and_status;

    if ($resume and $resume eq 'auto') {
        undef $resume;
        if (defined $mtime) {
            if (my @lstat = CORE::stat $local) {
                $resume = ($mtime <= $lstat[9]);
            }
        }
    }

    my ($atomic_numbered, $atomic_local, $atomic_cleanup);

    my ($rfh, $fh);
    my $askoff = 0;
    my $lstart = 0;

    if ($dont_save) {
        $rfh = $sftp->open($remote, SSH2_FXF_READ);
        defined $rfh or return undef;
    }
    else {
        unless ($local_is_fh or $overwrite or $append or $resume or $numbered) {
	    if (-e $local) {
                $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
                                  "local file $local already exists");
                return undef
	    }
        }

        if ($atomic) {
            $atomic_local = $local;
            $local .= sprintf("(%d).tmp", rand(10000));
            $atomic_numbered = $numbered;
            $numbered = 1;
            $debug and $debug & 128 and _debug("temporal local file name: $local");
        }

        if ($resume) {
            if (CORE::open $fh, '+<', $local) {
                binmode $fh;
		CORE::seek($fh, 0, 2);
                $askoff = CORE::tell $fh;
                if ($askoff < 0) {
                    # something is going really wrong here, fall
                    # back to non-resuming mode...
                    $askoff = 0;
                    undef $fh;
                }
                else {
                    if ($size >=0 and $askoff > $size) {
                        $sftp->_set_error(SFTP_ERR_LOCAL_BIGGER_THAN_REMOTE,
                                          "Couldn't resume transfer, local file is bigger than remote");
                        return undef;
                    }
                    $size == $askoff and return 1;
                }
            }
        }

        # we open the remote file so late in order to skip it when
        # resuming an already completed transfer:
        $rfh = $sftp->open($remote, SSH2_FXF_READ);
        defined $rfh or return undef;

	unless (defined $fh) {
	    if ($local_is_fh) {
		$fh = $local;
		local ($@, $SIG{__DIE__}, $SIG{__WARN__});
		eval { $lstart = CORE::tell($fh) };
		$lstart = 0 unless ($lstart and $lstart > 0);
	    }
	    else {
                my $flags = Fcntl::O_CREAT|Fcntl::O_WRONLY;
                $flags |= Fcntl::O_APPEND if $append;
                $flags |= Fcntl::O_EXCL if ($numbered or (!$overwrite and !$append));
                unlink $local if $overwrite;
                while (1) {
                    my $open_perm = (defined $perm ? $perm : 0666);
                    my $save = _umask_save_and_set($umask);
                    sysopen ($fh, $local, $flags, $open_perm) and last;
                    unless ($numbered and -e $local) {
                        $sftp->_set_error(SFTP_ERR_LOCAL_OPEN_FAILED,
                                          "Can't open $local", $!);
                        return undef;
                    }
                    _inc_numbered($local);
                }
                $$numbered = $local if ref $numbered;
		binmode $fh;
		$lstart = sysseek($fh, 0, 1) if $append;
	    }
	}

	if (defined $perm) {
            my $error;
	    do {
                local ($@, $SIG{__DIE__}, $SIG{__WARN__});
                unless (eval { CORE::chmod($perm, $local) > 0 }) {
                    $error = ($@ ? $@ : $!);
                }
            };
	    if ($error and !$best_effort) {
                unlink $local unless $resume or $append;
		$sftp->_set_error(SFTP_ERR_LOCAL_CHMOD_FAILED,
				  "Can't chmod $local", $error);
		return undef
	    }
	}
    }

    my $converter = _gen_converter $conversion;

    my $rfid = $sftp->_rfid($rfh);
    defined $rfid or die "internal error: rfid not defined";

    my @msgid;
    my @askoff;
    my $loff = $askoff;
    my $adjustment = 0;
    my $n = 0;
    local $\;

    my $slow_start = ($size == -1 ? $queue_size - 1 : 0);

    do {
        # Disable autodie here in order to do not leave unhandled
        # responses queued on the connection in case of failure.
        local $sftp->{_autodie};

        # Again, once this point is reached, all code paths should end
        # through the CLEANUP block.

        while (1) {
            # request a new block if queue is not full
            while (!@msgid or ( ($size == -1 or $size > $askoff)   and
                                @msgid < $queue_size - $slow_start and
                                $n != 1 ) ) {
                my $id = $sftp->_queue_new_msg(SSH2_FXP_READ, str=> $rfid,
                                               int64 => $askoff, int32 => $block_size);
                push @msgid, $id;
                push @askoff, $askoff;
                $askoff += $block_size;
                $n++;
            }

            $slow_start-- if $slow_start;

            my $eid = shift @msgid;
            my $roff = shift @askoff;

            my $msg = $sftp->_get_msg_and_check(SSH2_FXP_DATA, $eid,
                                                SFTP_ERR_REMOTE_READ_FAILED,
                                                "Couldn't read from remote file");

            unless ($msg) {
                if ($sftp->{_status} == SSH2_FX_EOF) {
                    $sftp->_set_error;
                    $roff != $loff and next;
                }
                last;
            }

            my $data = $msg->get_str;
            my $len = length $data;

            if ($roff != $loff or !$len) {
                $sftp->_set_error(SFTP_ERR_REMOTE_BLOCK_TOO_SMALL,
                                  "remote packet received is too small" );
                last;
            }

            $loff += $len;
            if ($len < $block_size) {
                $block_size = $len < 2048 ? 2048 : $len;
                $askoff = $loff;
            }

            my $adjustment_before = $adjustment;
            $adjustment += $converter->($data) if $converter;

            if (length($data) and defined $cb) {
                # $size = $loff if ($loff > $size and $size != -1);
                local $\;
                $cb->($sftp, $data,
                      $lstart + $roff + $adjustment_before,
                      $lstart + $size + $adjustment);

                last if $sftp->{_error};
            }

            if (length($data) and !$dont_save) {
                unless (print $fh $data) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_WRITE_FAILED,
                                      "unable to write data to local file $local", $!);
                    last;
                }
            }
        }

        $sftp->_get_msg for (@msgid);

        goto CLEANUP if $sftp->{_error};

        # if a converter is in place, and aditional call has to be
        # performed in order to flush any pending buffered data
        if ($converter) {
            my $data = '';
            my $adjustment_before = $adjustment;
            $adjustment += $converter->($data);

            if (length($data) and defined $cb) {
                # $size = $loff if ($loff > $size and $size != -1);
                local $\;
                $cb->($sftp, $data, $askoff + $adjustment_before, $size + $adjustment);
                goto CLEANUP if $sftp->{_error};
            }

            if (length($data) and !$dont_save) {
                unless (print $fh $data) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_WRITE_FAILED,
                                      "unable to write data to local file $local", $!);
                    goto CLEANUP;
                }
            }
        }

        # we call the callback one last time with an empty string;
        if (defined $cb) {
            my $data = '';
            do {
                local $\;
                $cb->($sftp, $data, $askoff + $adjustment, $size + $adjustment);
            };
            return undef if $sftp->{_error};
            if (length($data) and !$dont_save) {
                unless (print $fh $data) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_WRITE_FAILED,
                                      "unable to write data to local file $local", $!);
                    goto CLEANUP;
                }
            }
        }

        unless ($dont_save) {
            unless ($local_is_fh or CORE::close $fh) {
                $sftp->_set_error(SFTP_ERR_LOCAL_WRITE_FAILED,
                                  "unable to write data to local file $local", $!);
                goto CLEANUP;
            }

            # we can be running on taint mode, so some checks are
            # performed to untaint data from the remote side.

            if ($copy_time) {
                unless (utime($atime, $mtime, $local) or $best_effort) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_UTIME_FAILED,
                                      "Can't utime $local", $!);
                    goto CLEANUP;
                }
            }

            if ($atomic) {
                if (!$overwrite) {
                    while (1) {
                        # performing a non-overwriting atomic rename is
                        # quite burdensome: first, link is tried, if that
                        # fails, non-overwriting is favoured over
                        # atomicity and an empty file is used to lock the
                        # path before atempting an overwriting rename.
                        if (link $local, $atomic_local) {
                            unlink $local;
                            last;
                        }
                        my $err = $!;
                        unless (-e $atomic_local) {
                            if (sysopen my $lock, $atomic_local,
                                Fcntl::O_CREAT|Fcntl::O_EXCL|Fcntl::O_WRONLY,
                                0600) {
                                $atomic_cleanup = 1;
                                goto OVERWRITE;
                            }
                            $err = $!;
                            unless (-e $atomic_local) {
                                $sftp->_set_error(SFTP_ERR_LOCAL_OPEN_FAILED,
                                                  "Can't open $local", $err);
                                goto CLEANUP;
                            }
                        }
                        unless ($numbered) {
                            $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
                                              "local file $atomic_local already exists");
                            goto CLEANUP;
                        }
                        _inc_numbered($atomic_local);
                    }
                }
                else {
                OVERWRITE:
                    unless (CORE::rename $local, $atomic_local) {
                        $sftp->_set_error(SFTP_ERR_LOCAL_RENAME_FAILED,
                                          "Unable to rename temporal file to its final position '$atomic_local'", $!);
                        goto CLEANUP;
                    }
                }
                $$atomic_numbered = $local if ref $atomic_numbered;
            }
        }
    CLEANUP:
        if ($cleanup and $sftp->{_error}) {
            unlink $local;
            unlink $atomic_local if $atomic_cleanup;
        }
    }; # autodie flag is restored here!

    $sftp->_ok_or_autodie;
}

# return file contents on success, undef on failure
sub get_content {
    @_ == 2 or croak 'Usage: $sftp->get_content($remote)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $name) = @_;
    $name = $sftp->_rel2abs($name);
    my @data;

    my $rfh = $sftp->open($name)
	or return undef;

    scalar $sftp->readline($rfh, undef);
}

sub put {
    @_ >= 2 or croak 'Usage: $sftp->put($local, $remote, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $local, $remote, %opts) = @_;
    defined $local or croak "local file path is undefined";

    $sftp->_clear_error_and_status;

    my $local_is_fh = (ref $local and $local->isa('GLOB'));
    unless (defined $remote) {
        $local_is_fh and croak "unable to infer remote file name when a file handler is passed as local";
        $remote = (File::Spec->splitpath($local))[2];
    }
    $remote = $sftp->_rel2abs($remote);

    my $cb = delete $opts{callback};
    my $umask = delete $opts{umask};
    my $perm = delete $opts{perm};
    my $copy_perm = delete $opts{copy_perm};
    $copy_perm = delete $opts{copy_perms} unless defined $copy_perm;
    my $copy_time = delete $opts{copy_time};
    my $overwrite = delete $opts{overwrite};
    my $resume = delete $opts{resume};
    my $append = delete $opts{append};
    my $block_size = delete $opts{block_size} || $sftp->{_block_size};
    my $queue_size = delete $opts{queue_size} || $sftp->{_queue_size};
    my $conversion = delete $opts{conversion};
    my $late_set_perm = delete $opts{late_set_perm};
    my $numbered = delete $opts{numbered};
    my $atomic = delete $opts{atomic};
    my $cleanup = delete $opts{cleanup};
    my $best_effort = delete $opts{best_effort};
    my $sparse = delete $opts{sparse};

    croak "'perm' and 'umask' options can not be used simultaneously"
	if (defined $perm and defined $umask);
    croak "'perm' and 'copy_perm' options can not be used simultaneously"
	if (defined $perm and $copy_perm);
    croak "'resume' and 'append' options can not be used simultaneously"
	if ($resume and $append);
    croak "'resume' and 'overwrite' options can not be used simultaneously"
	if ($resume and $overwrite);
    croak "'numbered' can not be used with 'overwrite', 'resume' or 'append'"
	if ($numbered and ($overwrite or $resume or $append));
    croak "'atomic' can not be used with 'resume' or 'append'"
        if ($atomic and ($resume or $append));

    %opts and _croak_bad_options(keys %opts);

    $overwrite = 1 unless (defined $overwrite or $numbered);
    $copy_perm = 1 unless (defined $perm or defined $copy_perm or $local_is_fh);
    $copy_time = 1 unless (defined $copy_time or $local_is_fh);
    $late_set_perm = $sftp->{_late_set_perm} unless defined $late_set_perm;
    $cleanup = ($atomic || $numbered) unless defined $cleanup;

    my $neg_umask;
    if (defined $perm) {
	$neg_umask = $perm;
    }
    else {
	$umask = umask unless defined $umask;
	$neg_umask = 0777 & ~$umask;
    }

    my ($fh, $lmode, $lsize, $latime, $lmtime);
    if ($local_is_fh) {
	$fh = $local;
	# we don't set binmode for the passed file handle on purpose
    }
    else {
	unless (CORE::open $fh, '<', $local) {
	    $sftp->_set_error(SFTP_ERR_LOCAL_OPEN_FAILED,
			      "Unable to open local file '$local'", $!);
	    return undef;
	}
	binmode $fh;
    }

    {
	# as $fh can come from the outside, it may be a tied object
	# lacking support for some methods, so we call them wrapped
	# inside eval blocks
	local ($@, $SIG{__DIE__}, $SIG{__WARN__});
	if ((undef, undef, $lmode, undef, undef,
	     undef, undef, $lsize, $latime, $lmtime) =
	    eval {
		no warnings; # Calling stat on a tied handler
                             # generates a warning because the op is
                             # not supported by the tie API.
		CORE::stat $fh;
	    }
	   ) {
            $debug and $debug & 16384 and _debug "local file size is " . (defined $lsize ? $lsize : '<undef>');

	    # $fh can point at some place inside the file, not just at the
	    # begining
	    if ($local_is_fh and defined $lsize) {
		my $tell = eval { CORE::tell $fh };
		$lsize -= $tell if $tell and $tell > 0;
	    }
	}
	elsif ($copy_perm or $copy_time) {
	    $sftp->_set_error(SFTP_ERR_LOCAL_STAT_FAILED,
			      "Couldn't stat local file '$local'", $!);
	    return undef;
	}
	elsif ($resume and $resume eq 'auto') {
            $debug and $debug & 16384 and _debug "not resuming because stat'ing the local file failed";
	    undef $resume
	}
    }

    $perm = $lmode & $neg_umask if $copy_perm;
    my $attrs = Net::SFTP::Foreign::Attributes->new;
    $attrs->set_perm($perm) if defined $perm;

    my $rfh;
    my $writeoff = 0;
    my $converter = _gen_converter $conversion;
    my $converted_input = '';
    my $rattrs;

    if ($resume or $append) {
	$rattrs = do {
            local $sftp->{_autodie};
            $sftp->stat($remote);
        };
	if ($rattrs) {
	    if ($resume and $resume eq 'auto' and $rattrs->mtime >= $lmtime) {
                $debug and $debug & 16384 and
                    _debug "not resuming because local file is newer, r: ".$rattrs->mtime." l: $lmtime";
		undef $resume;
	    }
	    else {
		$writeoff = $rattrs->size;
		$debug and $debug & 16384 and _debug "resuming from $writeoff";
	    }
	}
        else {
            if ($append) {
                $sftp->{_status} == SSH2_FX_NO_SUCH_FILE
                    or $sftp->_ok_or_autodie or return undef;
                # no such file, no append
                undef $append;
            }
            $sftp->_clear_error_and_status;
        }
    }

    my ($atomic_numbered, $atomic_remote);
    if ($writeoff) {
        # one of $resume or $append is set
        if ($resume) {
            $debug and $debug & 16384 and _debug "resuming file transfer from $writeoff";
            if ($converter) {
                # as size could change, we have to read and convert
                # data until we reach the given position on the local
                # file:
                my $off = 0;
                my $eof_t;
                while (1) {
                    my $len = length $converted_input;
                    my $delta = $writeoff - $off;
                    if ($delta <= $len) {
                        $debug and $debug & 16384 and _debug "discarding $delta converted bytes";
                        substr $converted_input, 0, $delta, '';
                        last;
                    }
                    else {
                        $off += $len;
                        if ($eof_t) {
                            $sftp->_set_error(SFTP_ERR_REMOTE_BIGGER_THAN_LOCAL,
                                              "Couldn't resume transfer, remote file is bigger than local");
                            return undef;
                        }
                        my $read = CORE::read($fh, $converted_input, $block_size * 4);
                        unless (defined $read) {
                            $sftp->_set_error(SFTP_ERR_LOCAL_READ_ERROR,
                                              "Couldn't read from local file '$local' to the resume point $writeoff", $!);
                            return undef;
                        }
                        $lsize += $converter->($converted_input) if defined $lsize;
                        utf8::downgrade($converted_input, 1)
                                or croak "converter introduced wide characters in data";
                        $read or $eof_t = 1;
                    }
                }
            }
            elsif ($local_is_fh) {
                # as some PerlIO layer could be installed on the $fh,
                # just seeking to the resume position will not be
                # enough. We have to read and discard data until the
                # desired offset is reached
                my $off = $writeoff;
                while ($off) {
                    my $read = CORE::read($fh, my($buf), ($off < 16384 ? $off : 16384));
                    if ($read) {
                        $debug and $debug & 16384 and _debug "discarding $read bytes";
                        $off -= $read;
                    }
                    else {
                        $sftp->_set_error(defined $read
                                          ? ( SFTP_ERR_REMOTE_BIGGER_THAN_LOCAL,
                                              "Couldn't resume transfer, remote file is bigger than local")
                                          : ( SFTP_ERR_LOCAL_READ_ERROR,
                                              "Couldn't read from local file handler '$local' to the resume point $writeoff", $!));
                    }
                }
            }
            else {
                if (defined $lsize and $writeoff > $lsize) {
                    $sftp->_set_error(SFTP_ERR_REMOTE_BIGGER_THAN_LOCAL,
                                      "Couldn't resume transfer, remote file is bigger than local");
                    return undef;
                }
                unless (CORE::seek($fh, $writeoff, 0)) {
                    $sftp->_set_error(SFTP_ERR_LOCAL_SEEK_FAILED,
                                      "seek operation on local file failed: $!");
                    return undef;
                }
            }
            if (defined $lsize and $writeoff == $lsize) {
                if (defined $perm and $rattrs->perm != $perm) {
                    # FIXME: do copy_time here if required
                    return $sftp->_best_effort($best_effort, setstat => $remote, $attrs);
                }
                return 1;
            }
        }
        $rfh = $sftp->open($remote, SSH2_FXF_WRITE)
            or return undef;
    }
    else {
        if ($atomic) {
            # check that does not exist a file of the same name that
            # would block the rename operation at the end
            if (!($numbered or $overwrite) and
                $sftp->test_e($remote)) {
                $sftp->_set_status(SSH2_FX_FAILURE);
                $sftp->_set_error(SFTP_ERR_REMOTE_ALREADY_EXISTS,
                                  "Remote file '$remote' already exists");
                return undef;
            }
            $atomic_remote = $remote;
            $remote .= sprintf("(%d).tmp", rand(10000));
            $atomic_numbered = $numbered;
            $numbered = 1;
            $debug and $debug & 128 and _debug("temporal remote file name: $remote");
        }
        local $sftp->{_autodie};
	if ($numbered) {
            while (1) {
                $rfh = $sftp->open($remote,
                                   SSH2_FXF_WRITE | SSH2_FXF_CREAT | SSH2_FXF_EXCL,
                                   $attrs);
                last if ($rfh or
                         $sftp->{_status} != SSH2_FX_FAILURE or
                         !$sftp->test_e($remote));
                _inc_numbered($remote);
	    }
            $$numbered = $remote if $rfh and ref $numbered;
	}
        else {
            # open can fail due to a remote file with the wrong
            # permissions being already there. We are optimistic here,
            # first we try to open the remote file and if it fails due
            # to a permissions error then we remove it and try again.
            for my $rep (0, 1) {
                $rfh = $sftp->open($remote,
                                   SSH2_FXF_WRITE | SSH2_FXF_CREAT |
                                   ($overwrite ? SSH2_FXF_TRUNC : SSH2_FXF_EXCL),
                                   $attrs);

                last if $rfh or $rep or !$overwrite or $sftp->{_status} != SSH2_FX_PERMISSION_DENIED;

                $debug and $debug & 2 and _debug("retrying open after removing remote file");
                local ($sftp->{_status}, $sftp->{_error});
                $sftp->remove($remote);
            }
        }
    }

    $sftp->_ok_or_autodie or return undef;
    # Once this point is reached and for the remaining of the sub,
    # code should never return but jump into the CLEANUP block.

    my $last_block_was_zeros;

    do {
        local $sftp->{autodie};

        # In some SFTP server implementations, open does not set the
        # attributes for existent files so we do it again. The
        # $late_set_perm work around is for some servers that do not
        # support changing the permissions of open files
        if (defined $perm and !$late_set_perm) {
            $sftp->_best_effort($best_effort, setstat => $rfh, $attrs) or goto CLEANUP;
        }

        my $rfid = $sftp->_rfid($rfh);
        defined $rfid or die "internal error: rfid is undef";

        # In append mode we add the size of the remote file in
        # writeoff, if lsize is undef, we initialize it to $writeoff:
        $lsize += $writeoff if ($append or not defined $lsize);

        # when a converter is used, the EOF can become delayed by the
        # buffering introduced, we use $eof_t to account for that.
        my ($eof, $eof_t);
        my @msgid;
    OK: while (1) {
            if (!$eof and @msgid < $queue_size) {
                my ($data, $len);
                if ($converter) {
                    while (!$eof_t and length $converted_input < $block_size) {
                        my $read = CORE::read($fh, my $input, $block_size * 4);
                        unless ($read) {
                            unless (defined $read) {
                                $sftp->_set_error(SFTP_ERR_LOCAL_READ_ERROR,
                                                  "Couldn't read from local file '$local'", $!);
                                last OK;
                            }
                            $eof_t = 1;
                        }

                        # note that the $converter is called a last time
                        # with an empty string
                        $lsize += $converter->($input);
                        utf8::downgrade($input, 1)
                                or croak "converter introduced wide characters in data";
                        $converted_input .= $input;
                    }
                    $data = substr($converted_input, 0, $block_size, '');
                    $len = length $data;
                    $eof = 1 if ($eof_t and !$len);
                }
                else {
                    $debug and $debug & 16384 and
                        _debug "reading block at offset ".CORE::tell($fh)." block_size: $block_size";

                    $len = CORE::read($fh, $data, $block_size);

                    if ($len) {
                        $debug and $debug & 16384 and _debug "block read, size: $len";

                        utf8::downgrade($data, 1)
                                or croak "wide characters unexpectedly read from file";

                        $debug and $debug & 16384 and length $data != $len and
                            _debug "read data changed size on downgrade to " . length($data);
                    }
                    else {
                        unless (defined $len) {
                            $sftp->_set_error(SFTP_ERR_LOCAL_READ_ERROR,
                                              "Couldn't read from local file '$local'", $!);
                            last OK;
                        }
                        $eof = 1;
                    }
                }

                my $nextoff = $writeoff + $len;

                if (defined $cb) {
                    $lsize = $nextoff if $nextoff > $lsize;
                    $cb->($sftp, $data, $writeoff, $lsize);

                    last OK if $sftp->{_error};

                    utf8::downgrade($data, 1) or croak "callback introduced wide characters in data";

                    $len = length $data;
                    $nextoff = $writeoff + $len;
                }

                if ($len) {
                    if ($sparse and $data =~ /^\x{00}*$/s) {
                        $last_block_was_zeros = 1;
                        $debug and $debug & 16384 and _debug "skipping zeros block at offset $writeoff, length $len";
                    }
                    else {
                        $debug and $debug & 16384 and _debug "writing block at offset $writeoff, length $len";

                        my $id = $sftp->_queue_new_msg(SSH2_FXP_WRITE, str => $rfid,
                                                       int64 => $writeoff, str => $data);
                        push @msgid, $id;
                        $last_block_was_zeros = 0;
                    }
                    $writeoff = $nextoff;
                }
            }

            last if ($eof and !@msgid);

            next unless  ($eof
                          or @msgid >= $queue_size
                          or $sftp->_do_io(0));

            my $id = shift @msgid;
            unless ($sftp->_check_status_ok($id,
                                            SFTP_ERR_REMOTE_WRITE_FAILED,
                                            "Couldn't write to remote file")) {
                last OK;
            }
        }

        CORE::close $fh unless $local_is_fh;

        $sftp->_get_msg for (@msgid);

        $sftp->truncate($rfh, $writeoff)
            if $last_block_was_zeros and not $sftp->{_error};

        $sftp->_close_save_status($rfh);

        goto CLEANUP if $sftp->{_error};

        # set perm for servers that does not support setting
        # permissions on open files and also atime and mtime:
        if ($copy_time or ($late_set_perm and defined $perm)) {
            $attrs->set_perm unless $late_set_perm and defined $perm;
            $attrs->set_amtime($latime, $lmtime) if $copy_time;
            $sftp->_best_effort($best_effort, setstat => $remote, $attrs) or goto CLEANUP
        }

        if ($atomic) {
            $sftp->rename($remote, $atomic_remote,
                          overwrite => $overwrite,
                          numbered => $atomic_numbered) or goto CLEANUP;
        }

    CLEANUP:
        if ($cleanup and $sftp->{_error}) {
            warn "cleanup $remote";
            $sftp->_remove_save_status($remote);
        }
    };
    $sftp->_ok_or_autodie;
}

sub put_content {
    @_ >= 3 or croak 'Usage: $sftp->put_content($content, $remote, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, undef, $remote, %opts) = @_;
    my %put_opts = ( map { $_ => delete $opts{$_} }
                     qw(perm umask block_size queue_size overwrite conversion resume
                        numbered late_set_perm atomic best_effort));
    %opts and _croak_bad_options(keys %opts);

    my $fh;
    unless (CORE::open $fh, '<', \$_[1]) {
        $sftp->_set_error(SFTP_ERR_LOCAL_OPEN_FAILED, "Can't open scalar as file handle", $!);
        return undef;
    }
    $sftp->put($fh, $remote, %opts);
}

sub ls {
    @_ >= 1 or croak 'Usage: $sftp->ls($remote_dir, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my $sftp = shift;
    my %opts = @_ & 1 ? (dir => @_) : @_;

    my $dir = delete $opts{dir};
    my $ordered = delete $opts{ordered};
    my $follow_links = delete $opts{follow_links};
    my $atomic_readdir = delete $opts{atomic_readdir};
    my $names_only = delete $opts{names_only};
    my $realpath = delete $opts{realpath};
    my $queue_size = delete $opts{queue_size};
    my $cheap = ($names_only and !$realpath); 
    my ($cheap_wanted, $wanted);
    if ($cheap and
	ref $opts{wanted} eq 'RegExp' and 
	not defined $opts{no_wanted}) {
	$cheap_wanted = delete $opts{wanted}
    }
    else {
	$wanted = (delete $opts{_wanted} ||
		   _gen_wanted(delete $opts{wanted},
			       delete $opts{no_wanted}));
	undef $cheap if defined $wanted;
    }

    %opts and _croak_bad_options(keys %opts);

    my $delayed_wanted = ($atomic_readdir and $wanted);
    $queue_size = 1 if ($follow_links or $realpath or
			($wanted and not $delayed_wanted));
    my $max_queue_size = $queue_size || $sftp->{_queue_size};
    $queue_size ||= 2;

    $dir = '.' unless defined $dir;
    $dir = $sftp->_rel2abs($dir);

    my $rdh = $sftp->opendir($dir);
    return unless defined $rdh;

    my $rdid = $sftp->_rdid($rdh);
    defined $rdid or return undef;

    my @dir;
    my @msgid;

    do {
        local $sftp->{_autodie};
    OK: while (1) {
            push @msgid, $sftp->_queue_str_request(SSH2_FXP_READDIR, $rdid)
                while (@msgid < $queue_size);

            my $id = shift @msgid;
            if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_NAME, $id,
                                                    SFTP_ERR_REMOTE_READDIR_FAILED,
                                                    "Couldn't read directory '$dir'" )) {
                my $count = $msg->get_int32 or last;

                if ($cheap) {
                    for (1..$count) {
                        my $fn = $sftp->_fs_decode($msg->get_str);
                        push @dir, $fn if (!defined $cheap_wanted or $fn =~ $cheap_wanted);
                        $msg->skip_str;
                        Net::SFTP::Foreign::Attributes->skip_from_buffer($msg);
                    }
                }
                else {
                    for (1..$count) {
                        my $fn = $sftp->_fs_decode($msg->get_str);
                        my $ln = $sftp->_fs_decode($msg->get_str);
                        # my $a = $msg->get_attributes;
                        my $a = Net::SFTP::Foreign::Attributes->new_from_buffer($msg);

                        my $entry =  { filename => $fn,
                                       longname => $ln,
                                       a => $a };

                        if ($follow_links and _is_lnk($a->perm)) {

                            if ($a = $sftp->stat($sftp->join($dir, $fn))) {
                                $entry->{a} = $a;
                            }
                            else {
                                $sftp->_clear_error_and_status;
                            }
                        }

                        if ($realpath) {
                            my $rp = $sftp->realpath($sftp->join($dir, $fn));
                            if (defined $rp) {
                                $fn = $entry->{realpath} = $rp;
                            }
                            else {
                                $sftp->_clear_error_and_status;
                            }
                        }

                        if (!$wanted or $delayed_wanted or $wanted->($sftp, $entry)) {
                            push @dir, (($names_only and !$delayed_wanted) ? $fn : $entry);
                        }
                    }
                }

                $queue_size ++ if $queue_size < $max_queue_size;
            }
            else {
                $sftp->_set_error if $sftp->{_status} == SSH2_FX_EOF;
                $sftp->_get_msg for @msgid;
                last;
            }
        }
        $sftp->_closedir_save_status($rdh) if $rdh;
    };
    unless ($sftp->{_error}) {
	if ($delayed_wanted) {
	    @dir = grep { $wanted->($sftp, $_) } @dir;
	    @dir = map { defined $_->{realpath}
			 ? $_->{realpath}
			 : $_->{filename} } @dir
		if $names_only;
	}
        if ($ordered) {
            if ($names_only) {
                @dir = sort @dir;
            }
            else {
                _sort_entries \@dir;
            }
        }
	return \@dir;
    }
    croak $sftp->{_error} if $sftp->{_autodie};
    return undef;
}

sub rremove {
    @_ >= 2 or croak 'Usage: $sftp->rremove($dirs, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $dirs, %opts) = @_;

    my $on_error = delete $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted});

    %opts and _croak_bad_options(keys %opts);

    my $count = 0;

    my @dirs;
    $sftp->find( $dirs,
		 on_error => $on_error,
		 atomic_readdir => 1,
		 wanted => sub {
		     my $e = $_[1];
		     my $fn = $e->{filename};
		     if (_is_dir($e->{a}->perm)) {
			 push @dirs, $e;
		     }
		     else {
			 if (!$wanted or $wanted->($sftp, $e)) {
			     if ($sftp->remove($fn)) {
				 $count++;
			     }
			     else {
				 $sftp->_call_on_error($on_error, $e);
			     }
			 }
		     }
		 } );

    _sort_entries(\@dirs);

    while (@dirs) {
	my $e = pop @dirs;
	if (!$wanted or $wanted->($sftp, $e)) {
	    if ($sftp->rmdir($e->{filename})) {
		$count++;
	    }
	    else {
		$sftp->_call_on_error($on_error, $e);
	    }
	}
    }

    return $count;
}

sub get_symlink {
    @_ >= 3 or croak 'Usage: $sftp->get_symlink($remote, $local, %opts)';
    my ($sftp, $remote, $local, %opts) = @_;
    my $overwrite = delete $opts{overwrite};
    my $numbered = delete $opts{numbered};

    croak "'overwrite' and 'numbered' can not be used together"
	if ($overwrite and $numbered);
   %opts and _croak_bad_options(keys %opts);

    $overwrite = 1 unless (defined $overwrite or $numbered);

    my $a = $sftp->lstat($remote) or return undef;
    unless (_is_lnk($a->perm)) {
	$sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
			  "Remote object '$remote' is not a symlink");
	return undef;
    }

    my $link = $sftp->readlink($remote) or return undef;

    # TODO: this is too weak, may contain race conditions.
    if ($numbered) {
        _inc_numbered($local) while -e $local;
    }
    elsif (-e $local) {
	if ($overwrite) {
	    unlink $local;
	}
	else {
	    $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
			      "local file $local already exists");
	    return undef
	}
    }

    unless (eval { CORE::symlink $link, $local }) {
	$sftp->_set_error(SFTP_ERR_LOCAL_SYMLINK_FAILED,
			  "creation of symlink '$local' failed", $!);
	return undef;
    }
    $$numbered = $local if ref $numbered;

    1;
}

sub put_symlink {
    @_ >= 3 or croak 'Usage: $sftp->put_symlink($local, $remote, %opts)';
    my ($sftp, $local, $remote, %opts) = @_;
    my $overwrite = delete $opts{overwrite};
    my $numbered = delete $opts{numbered};

    croak "'overwrite' and 'numbered' can not be used together"
	if ($overwrite and $numbered);
    %opts and _croak_bad_options(keys %opts);

    $overwrite = 1 unless (defined $overwrite or $numbered);
    my $perm = (CORE::lstat $local)[2];
    unless (defined $perm) {
	$sftp->_set_error(SFTP_ERR_LOCAL_STAT_FAILED,
			  "Couldn't stat local file '$local'", $!);
	return undef;
    }
    unless (_is_lnk($perm)) {
	$sftp->_set_error(SFTP_ERR_LOCAL_BAD_OBJECT,
			  "Local file $local is not a symlink");
	return undef;
    }
    my $target = readlink $local;
    unless (defined $target) {
	$sftp->_set_error(SFTP_ERR_LOCAL_READLINK_FAILED,
			  "Couldn't read link '$local'", $!);
	return undef;
    }

    while (1) {
        local $sftp->{_autodie};
        $sftp->symlink($remote, $target);
        if ($sftp->{_error} and
            $sftp->{_status} == SSH2_FX_FAILURE) {
            if ($numbered and $sftp->test_e($remote)) {
                _inc_numbered($remote);
                redo;
            }
            elsif ($overwrite and $sftp->_remove_save_status($remote)) {
                $overwrite = 0;
                redo;
            }
        }
        last
    }
    $$numbered = $remote if ref $numbered;
    $sftp->_ok_or_autodie;
}

sub rget {
    @_ >= 2 or croak 'Usage: $sftp->rget($remote, $local, %opts)';
    ${^TAINT} and &_catch_tainted_args;
    my ($sftp, $remote, $local, %opts) = @_;

    defined $remote or croak "remote file path is undefined";
    $local = File::Spec->curdir unless defined $local;

    # my $cb = delete $opts{callback};
    my $umask = delete $opts{umask};
    my $copy_perm = delete $opts{exists $opts{copy_perm} ? 'copy_perm' : 'copy_perms'};
    my $copy_time = delete $opts{copy_time};
    my $newer_only = delete $opts{newer_only};
    my $on_error = delete $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $ignore_links = delete $opts{ignore_links};

    # my $relative_links = delete $opts{relative_links};

    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted} );

    my %get_opts = (map { $_ => delete $opts{$_} }
                    qw(block_size queue_size overwrite conversion
                       resume numbered atomic best_effort));

    if ($get_opts{resume} and $get_opts{conversion}) {
        carp "resume option is useless when data conversion has also been requested";
        delete $get_opts{resume};
    }

    my %get_symlink_opts = (map { $_ => $get_opts{$_} }
                            qw(overwrite numbered));

    %opts and _croak_bad_options(keys %opts);

    $remote = $sftp->join($remote, './');
    my $qremote = quotemeta $remote;
    my $reremote = qr/^$qremote(.*)$/i;

    my $save = _umask_save_and_set $umask;

    $copy_perm = 1 unless defined $copy_perm;
    $copy_time = 1 unless defined $copy_time;

    require File::Spec;

    my $count = 0;
    $sftp->find( [$remote],
		 descend => sub {
		     my $e = $_[1];
		     # print "descend: $e->{filename}\n";
		     if (!$wanted or $wanted->($sftp, $e)) {
			 my $fn = $e->{filename};
			 if ($fn =~ $reremote) {
			     my $lpath = File::Spec->catdir($local, $1);
                             ($lpath) = $lpath =~ /(.*)/ if ${^TAINT};
			     if (-d $lpath) {
				 $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
						   "directory '$lpath' already exists");
				 $sftp->_call_on_error($on_error, $e);
				 return 1;
			     }
			     else {
				 if (CORE::mkdir $lpath, ($copy_perm ? $e->{a}->perm & 0777 : 0777)) {
				     $count++;
				     return 1;
				 }
				 else {
				     $sftp->_set_error(SFTP_ERR_LOCAL_MKDIR_FAILED,
						       "mkdir '$lpath' failed", $!);
				 }
			     }
			 }
			 else {
			     $sftp->_set_error(SFTP_ERR_REMOTE_BAD_PATH,
					       "bad remote path '$fn'");
			 }
			 $sftp->_call_on_error($on_error, $e);
		     }
		     return undef;
		 },
		 wanted => sub {
		     my $e = $_[1];
		     # print "file fn:$e->{filename}, a:$e->{a}\n";
		     unless (_is_dir($e->{a}->perm)) {
			 if (!$wanted or $wanted->($sftp, $e)) {
			     my $fn = $e->{filename};
			     if ($fn =~ $reremote) {
				 my $lpath = File::Spec->catfile($local, $1);
                                 ($lpath) = $lpath =~ /(.*)/ if ${^TAINT};
				 if (_is_lnk($e->{a}->perm) and !$ignore_links) {
				     if ($sftp->get_symlink($fn, $lpath,
							    # copy_time => $copy_time,
                                                            %get_symlink_opts)) {
					 $count++;
					 return undef;
				     }
				 }
				 elsif (_is_reg($e->{a}->perm)) {
				     if ($newer_only and -e $lpath
					 and (CORE::stat _)[9] >= $e->{a}->mtime) {
					 $sftp->_set_error(SFTP_ERR_LOCAL_ALREADY_EXISTS,
							   "newer local file '$lpath' already exists");
				     }
				     else {
					 if ($sftp->get($fn, $lpath,
							copy_perm => $copy_perm,
							copy_time => $copy_time,
                                                        %get_opts)) {
					     $count++;
					     return undef;
					 }
				     }
				 }
				 else {
				     $sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
						       ( $ignore_links
							 ? "remote file '$fn' is not regular file or directory"
							 : "remote file '$fn' is not regular file, directory or link"));
				 }
			     }
			     else {
				 $sftp->_set_error(SFTP_ERR_REMOTE_BAD_PATH,
						   "bad remote path '$fn'");
			     }
			     $sftp->_call_on_error($on_error, $e);
			 }
		     }
		     return undef;
		 } );

    return $count;
}

sub rput {
    @_ >= 2 or croak 'Usage: $sftp->rput($local, $remote, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $local, $remote, %opts) = @_;

    defined $local or croak "local path is undefined";
    $remote = '.' unless defined $remote;

    # my $cb = delete $opts{callback};
    my $umask = delete $opts{umask};
    my $copy_perm = delete $opts{exists $opts{copy_perm} ? 'copy_perm' : 'copy_perms'};
    my $copy_time = delete $opts{copy_time};

    my $newer_only = delete $opts{newer_only};
    my $on_error = delete $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $ignore_links = delete $opts{ignore_links};

    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted} );

    my %put_opts = (map { $_ => delete $opts{$_} }
		    qw(block_size queue_size overwrite
                       conversion resume numbered
                       late_set_perm atomic best_effort
                       sparse));

    my %put_symlink_opts = (map { $_ => $put_opts{$_} }
                            qw(overwrite numbered));

    %opts and _croak_bad_options(keys %opts);

    require Net::SFTP::Foreign::Local;
    my $lfs = Net::SFTP::Foreign::Local->new;

    $local = $lfs->join($local, './');
    my $relocal;
    if ($local =~ m|^\./?$|) {
	$relocal = qr/^(.*)$/;
    }
    else {
	my $qlocal = quotemeta $local;
	$relocal = qr/^$qlocal(.*)$/i;
    }

    $copy_perm = 1 unless defined $copy_perm;
    $copy_time = 1 unless defined $copy_time;

    $umask = umask unless defined $umask;
    my $mask = ~$umask;

    if ($on_error) {
	my $on_error1 = $on_error;
	$on_error = sub {
	    my $lfs = shift;
	    $sftp->_copy_error($lfs);
	    $sftp->_call_on_error($on_error1, @_);
	}
    }

    my $count = 0;
    $lfs->find( [$local],
		descend => sub {
		    my $e = $_[1];
		    # print "descend: $e->{filename}\n";
		    if (!$wanted or $wanted->($lfs, $e)) {
			my $fn = $e->{filename};
			$debug and $debug & 32768 and _debug "rput handling $fn";
			if ($fn =~ $relocal) {
			    my $rpath = $sftp->join($remote, File::Spec->splitdir($1));
			    $debug and $debug & 32768 and _debug "rpath: $rpath";
			    if ($sftp->test_d($rpath)) {
				$lfs->_set_error(SFTP_ERR_REMOTE_ALREADY_EXISTS,
						 "Remote directory '$rpath' already exists");
				$lfs->_call_on_error($on_error, $e);
				return 1;
			    }
			    else {
				my $a = Net::SFTP::Foreign::Attributes->new;
				$a->set_perm(($copy_perm ? $e->{a}->perm & 0777 : 0777) & $mask);
				if ($sftp->mkdir($rpath, $a)) {
				    $count++;
				    return 1;
				}
				else {
				    $lfs->_copy_error($sftp);
				}
			    }
			}
			else {
			    $lfs->_set_error(SFTP_ERR_LOCAL_BAD_PATH,
					      "Bad local path '$fn'");
			}
			$lfs->_call_on_error($on_error, $e);
		    }
		    return undef;
		},
		wanted => sub {
		    my $e = $_[1];
		    # print "file fn:$e->{filename}, a:$e->{a}\n";
		    unless (_is_dir($e->{a}->perm)) {
			if (!$wanted or $wanted->($lfs, $e)) {
			    my $fn = $e->{filename};
			    $debug and $debug & 32768 and _debug "rput handling $fn";
			    if ($fn =~ $relocal) {
				my (undef, $d, $f) = File::Spec->splitpath($1);
				my $rpath = $sftp->join($remote, File::Spec->splitdir($d), $f);
				if (_is_lnk($e->{a}->perm) and !$ignore_links) {
				    if ($sftp->put_symlink($fn, $rpath,
                                                           %put_symlink_opts)) {
					$count++;
					return undef;
				    }
				    $lfs->_copy_error($sftp);
				}
				elsif (_is_reg($e->{a}->perm)) {
				    my $ra;
				    if ( $newer_only and
					 $ra = $sftp->stat($rpath) and
					 $ra->mtime >= $e->{a}->mtime) {
					$lfs->_set_error(SFTP_ERR_REMOTE_ALREADY_EXISTS,
							 "Newer remote file '$rpath' already exists");
				    }
				    else {
					if ($sftp->put($fn, $rpath,
                                                       ($copy_perm
                                                        ? (perm  => $e->{a}->perm & 0777 & $mask)
                                                        : (umask => $umask) ),
						       copy_time => $copy_time,
                                                       %put_opts)) {
					    $count++;
					    return undef;
					}
					$lfs->_copy_error($sftp);
				    }
				}
				else {
				    $lfs->_set_error(SFTP_ERR_LOCAL_BAD_OBJECT,
						      ( $ignore_links
							? "Local file '$fn' is not regular file or directory"
							: "Local file '$fn' is not regular file, directory or link"));
				}
			    }
			    else {
				$lfs->_set_error(SFTP_ERR_LOCAL_BAD_PATH,
						  "Bad local path '$fn'");
			    }
			    $lfs->_call_on_error($on_error, $e);
			}
		    }
		    return undef;
		} );

    return $count;
}

sub mget {
    @_ >= 2 or croak 'Usage: $sftp->mget($remote, $localdir, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $remote, $localdir, %opts) = @_;

    defined $remote or croak "remote pattern is undefined";

    my $on_error = $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $ignore_links = delete $opts{ignore_links};

    my %glob_opts = (map { $_ => delete $opts{$_} }
		     qw(on_error follow_links ignore_case
                        wanted no_wanted strict_leading_dot));

    my %get_symlink_opts = (map { $_ => $opts{$_} }
			    qw(overwrite numbered));

    my %get_opts = (map { $_ => delete $opts{$_} }
		    qw(umask perm copy_perm copy_time block_size queue_size
                       overwrite conversion resume numbered atomic best_effort));

    %opts and _croak_bad_options(keys %opts);

    my @remote = map $sftp->glob($_, %glob_opts), _ensure_list $remote;

    my $count = 0;

    require File::Spec;
    for my $e (@remote) {
	my $perm = $e->{a}->perm;
	if (_is_dir($perm)) {
	    $sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
			      "Remote object '$e->{filename}' is a directory");
	}
	else {
	    my $fn = $e->{filename};
	    my ($local) = $fn =~ m{([^\\/]*)$};

	    $local = File::Spec->catfile($localdir, $local)
		if defined $localdir;

	    if (_is_lnk($perm)) {
		next if $ignore_links;
		$sftp->get_symlink($fn, $local, %get_symlink_opts);
	    }
	    else {
		$sftp->get($fn, $local, %get_opts);
	    }
	}
	$count++ unless $sftp->{_error};
	$sftp->_call_on_error($on_error, $e);
    }
    $count;
}

sub mput {
    @_ >= 2 or croak 'Usage: $sftp->mput($local, $remotedir, %opts)';

    my ($sftp, $local, $remotedir, %opts) = @_;

    defined $local or die "local pattern is undefined";

    my $on_error = $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $ignore_links = delete $opts{ignore_links};

    my %glob_opts = (map { $_ => delete $opts{$_} }
		     qw(on_error follow_links ignore_case
                        wanted no_wanted strict_leading_dot));
    my %put_symlink_opts = (map { $_ => $opts{$_} }
			    qw(overwrite numbered));

    my %put_opts = (map { $_ => delete $opts{$_} }
		    qw(umask perm copy_perm copy_time block_size queue_size
                       overwrite conversion resume numbered late_set_perm
                       atomic best_effort sparse));

    %opts and _croak_bad_options(keys %opts);

    require Net::SFTP::Foreign::Local;
    my $lfs = Net::SFTP::Foreign::Local->new;
    my @local = map $lfs->glob($_, %glob_opts), _ensure_list $local;

    my $count = 0;
    require File::Spec;
    for my $e (@local) {
	my $perm = $e->{a}->perm;
	if (_is_dir($perm)) {
	    $sftp->_set_error(SFTP_ERR_REMOTE_BAD_OBJECT,
			      "Remote object '$e->{filename}' is a directory");
	}
	else {
	    my $fn = $e->{filename};
	    my $remote = (File::Spec->splitpath($fn))[2];
	    $remote = $sftp->join($remotedir, $remote)
		if defined $remotedir;

	    if (_is_lnk($perm)) {
		next if $ignore_links;
		$sftp->put_symlink($fn, $remote, %put_symlink_opts);
	    }
	    else {
		$sftp->put($fn, $remote, %put_opts);
	    }
	}
	$count++ unless $sftp->{_error};
	$sftp->_call_on_error($on_error, $e);
    }
    $count;
}

sub statvfs {
    @_ == 2 or croak 'Usage: $sftp->statvfs($path_or_fh)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $pofh) = @_;
    my ($extension, $arg) = ( (ref $pofh and UNIVERSAL::isa($pofh, 'Net::SFTP::Foreign::FileHandle'))
                              ? ('fstatvfs@openssh.com', $sftp->_rid($pofh) )
                              : ('statvfs@openssh.com' , $sftp->_fs_encode($sftp->_rel2abs($pofh)) ) );

    $sftp->_check_extension($extension => 2,
                            SFTP_ERR_REMOTE_STATVFS_FAILED,
                            "statvfs failed")
        or return undef;

    my $id = $sftp->_queue_new_msg(SSH2_FXP_EXTENDED,
                                   str => $extension,
                                   str => $arg);

    if (my $msg = $sftp->_get_msg_and_check(SSH2_FXP_EXTENDED_REPLY, $id,
                                            SFTP_ERR_REMOTE_STATVFS_FAILED,
                                            "Couldn't stat remote file system")) {
        my %statvfs = map { $_ => $msg->get_int64 } qw(bsize frsize blocks
                                                       bfree bavail files ffree
                                                       favail fsid flag namemax);
        return \%statvfs;
    }
    return undef;
}

sub fstatvfs {
    _deprecated "fstatvfs is deprecated and will be removed on the upcomming 2.xx series, "
        . "statvfs method accepts now both file handlers and paths";
    goto &statvfs;
}

package Net::SFTP::Foreign::Handle;

use Tie::Handle;
our @ISA = qw(Tie::Handle);
our @CARP_NOT = qw(Net::SFTP::Foreign Tie::Handle);

my $gen_accessor = sub {
    my $ix = shift;
    sub {
	my $st = *{shift()}{ARRAY};
	if (@_) {
	    $st->[$ix] = shift;
	}
	else {
	    $st->[$ix]
	}
    }
};

my $gen_proxy_method = sub {
    my $method = shift;
    sub {
	my $self = $_[0];
	$self->_check
	    or return undef;

	my $sftp = $self->_sftp;
	if (wantarray) {
	    my @ret = $sftp->$method(@_);
	    $sftp->_set_errno unless @ret;
	    return @ret;
	}
	else {
	    my $ret = $sftp->$method(@_);
	    $sftp->_set_errno unless defined $ret;
	    return $ret;
	}
    }
};

my $gen_not_supported = sub {
    sub {
	$! = Errno::ENOTSUP();
	undef
    }
};

sub TIEHANDLE { return shift }

# sub UNTIE {}

sub _new_from_rid {
    my $class = shift;
    my $sftp = shift;
    my $rid = shift;
    my $flags = shift || 0;

    my $self = Symbol::gensym;
    bless $self, $class;
    *$self = [ $sftp, $rid, 0, $flags, @_];
    tie *$self, $self;

    $self;
}

sub _close {
    my $self = shift;
    @{*{$self}{ARRAY}} = ();
}

sub _check {
    return 1 if defined(*{shift()}{ARRAY}[0]);
    $! = Errno::EBADF;
    undef;
}

sub FILENO {
    my $self = shift;
    $self->_check
	or return undef;

    my $hrid = unpack 'H*' => $self->_rid;
    "-1:sftp(0x$hrid)"
}

sub _sftp { *{shift()}{ARRAY}[0] }
sub _rid { *{shift()}{ARRAY}[1] }

* _pos = $gen_accessor->(2);

sub _inc_pos {
    my ($self, $inc) = @_;
    *{shift()}{ARRAY}[2] += $inc;
}


my %flag_bit = (append => 0x1);

sub _flag {
    my $st = *{shift()}{ARRAY};
    my $fn = shift;
    my $flag = $flag_bit{$fn};
    Carp::croak("unknown flag $fn") unless defined $flag;
    if (@_) {
	if (shift) {
	    $st->[3] |= $flag;
	}
	else {
	    $st->[3] &= ~$flag;
	}
    }
    $st->[3] & $flag ? 1 : 0
}

sub _check_is_file {
    Carp::croak("expecting remote file handler, got directory handler");
}
sub _check_is_dir {
    Carp::croak("expecting remote directory handler, got file handler");
}

my $autoloaded;
sub AUTOLOAD {
    my $self = shift;
    our $AUTOLOAD;
    if ($autoloaded) {
	my $class = ref $self || $self;
	Carp::croak qq|Can't locate object method "$AUTOLOAD" via package "$class|;
    }
    else {
	$autoloaded = 1;
	require IO::File;
	require IO::Dir;
	my ($method) = $AUTOLOAD =~ /^.*::(.*)$/;
	$self->$method(@_);
    }
}

package Net::SFTP::Foreign::FileHandle;
our @ISA = qw(Net::SFTP::Foreign::Handle IO::File);

sub _new_from_rid {
    my $class = shift;
    my $sftp = shift;
    my $rid = shift;
    my $flags = shift;

    my $self = $class->SUPER::_new_from_rid($sftp, $rid, $flags, '', '');
}

sub _check_is_file {}

sub _bin { \(*{shift()}{ARRAY}[4]) }
sub _bout { \(*{shift()}{ARRAY}[5]) }

sub WRITE {
    my ($self, undef, $length, $offset) = @_;
    $self->_check
	or return undef;

    $offset = 0 unless defined $offset;
    $offset = length $_[1] + $offset if $offset < 0;
    $length = length $_[1] unless defined $length;

    my $sftp = $self->_sftp;

    my $ret = $sftp->write($self, substr($_[1], $offset, $length));
    $sftp->_set_errno unless defined $ret;
    $ret;
}

sub READ {
    my ($self, undef, $len, $offset) = @_;
    $self->_check
	or return undef;

    $_[1] = '' unless defined $_[1];
    $offset ||= 0;
    if ($offset > length $_[1]) {
	$_[1] .= "\0" x ($offset - length $_[1])
    }

    if ($len == 0) {
	substr($_[1], $offset) = '';
	return 0;
    }

    my $sftp = $self->_sftp;
    $sftp->_fill_read_cache($self, $len);

    my $bin = $self->_bin;
    if (length $$bin) {
	my $data = substr($$bin, 0, $len, '');
	$self->_inc_pos($len);
	substr($_[1], $offset) = $data;
	return length $data;
    }
    return 0 if $sftp->{_status} == $sftp->SSH2_FX_EOF;
    $sftp->_set_errno;
    undef;
}

sub EOF {
    my $self = $_[0];
    $self->_check or return undef;
    my $sftp = $self->_sftp;
    my $ret = $sftp->eof($self);
    $sftp->_set_errno unless defined $ret;
    $ret;
}

*GETC = $gen_proxy_method->('getc');
*TELL = $gen_proxy_method->('tell');
*SEEK = $gen_proxy_method->('seek');
*CLOSE = $gen_proxy_method->('close');

my $readline = $gen_proxy_method->('readline');
sub READLINE { $readline->($_[0], $/) }

sub OPEN {
    shift->CLOSE;
    undef;
}

sub DESTROY {
    local ($@, $!, $?);
    my $self = shift;
    my $sftp = $self->_sftp;
    $debug and $debug & 4 and Net::SFTP::Foreign::_debug("$self->DESTROY called (sftp: ".($sftp||'<undef>').")");
    if ($self->_check and $sftp) {
        local $sftp->{_autodie};
	$sftp->_close_save_status($self)
    }
}

package Net::SFTP::Foreign::DirHandle;
our @ISA = qw(Net::SFTP::Foreign::Handle IO::Dir);

sub _new_from_rid {
    my $class = shift;
    my $sftp = shift;
    my $rid = shift;
    my $flags = shift;

    my $self = $class->SUPER::_new_from_rid($sftp, $rid, $flags, []);
}


sub _check_is_dir {}

sub _cache { *{shift()}{ARRAY}[4] }

*CLOSEDIR = $gen_proxy_method->('closedir');
*READDIR = $gen_proxy_method->('_readdir');

sub OPENDIR {
    shift->CLOSEDIR;
    undef;
}

*REWINDDIR = $gen_not_supported->();
*TELLDIR = $gen_not_supported->();
*SEEKDIR = $gen_not_supported->();

sub DESTROY {
    local ($@, $!, $?);
    my $self = shift;
    my $sftp = $self->_sftp;

    $debug and $debug & 4 and Net::SFTP::Foreign::_debug("$self->DESTROY called (sftp: ".($sftp||'').")");

    if ($self->_check and $sftp) {
        local $sftp->{_autodie};
	$sftp->_closedir_save_status($self)
    }
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign - SSH File Transfer Protocol client

=head1 SYNOPSIS

    use Net::SFTP::Foreign;
    my $sftp = Net::SFTP::Foreign->new($host);
    $sftp->die_on_error("Unable to establish SFTP connection");

    $sftp->setcwd($path) or die "unable to change cwd: " . $sftp->error;

    $sftp->get("foo", "bar") or die "get failed: " . $sftp->error;

    $sftp->put("bar", "baz") or die "put failed: " . $sftp->error;

=head1 DESCRIPTION

SFTP stands for SSH File Transfer Protocol and is a method of
transferring files between machines over a secure, encrypted
connection (as opposed to regular FTP, which functions over an
insecure connection). The security in SFTP comes through its
integration with SSH, which provides an encrypted transport layer over
which the SFTP commands are executed.

Net::SFTP::Foreign is a Perl client for the SFTP version 3 as defined
in the SSH File Transfer Protocol IETF draft, which can be found at
L<http://www.openssh.org/txt/draft-ietf-secsh-filexfer-02.txt> (also
included on this package distribution, on the C<rfc> directory).

Net::SFTP::Foreign uses any compatible C<ssh> command installed on
the system (for instance, OpenSSH C<ssh>) to establish the secure
connection to the remote server.

A wrapper module L<Net::SFTP::Foreign::Compat> is also provided for
compatibility with L<Net::SFTP>.


=head2 Net::SFTP::Foreign Vs. Net::SFTP Vs. Net::SSH2::SFTP

Why should I prefer Net::SFTP::Foreign over L<Net::SFTP>?

Well, both modules have their pros and cons:

Net::SFTP::Foreign does not require a bunch of additional modules and
external libraries to work, just the OpenBSD SSH client (or any other
client compatible enough).

I trust OpenSSH SSH client more than L<Net::SSH::Perl>, there are lots
of paranoid people ensuring that OpenSSH doesn't have security
holes!!!

If you have an SSH infrastructure already deployed, by using the same
binary SSH client, Net::SFTP::Foreign ensures a seamless integration
within your environment (configuration files, keys, etc.).

Net::SFTP::Foreign is much faster transferring files, specially over
networks with high (relative) latency.

Net::SFTP::Foreign provides several high level methods not available
from Net::SFTP as for instance C<find>, C<glob>, C<rget>, C<rput>,
C<rremove>, C<mget>, C<mput>.

On the other hand, using the external command means an additional
process being launched and running, depending on your OS this could
eat more resources than the in process pure perl implementation
provided by L<Net::SSH::Perl>.

L<Net::SSH2> is a module wrapping libssh2, an SSH version 2 client
library written in C. It is a very active project that aims to replace
L<Net::SSH::Perl>. Unfortunately, libssh2 SFTP functionality
(available in Perl via L<Net::SSH2::SFTP>) is rather limited and its
performance very poor.

Later versions of Net::SFTP::Foreign can use L<Net::SSH2> as the
transport layer via the backend module
L<Net::SFTP::Foreign::Backend::Net_SSH2>.

=head2 Error handling

Most of the methods available from this package return undef on
failure and a true value or the requested data on
success. C<$sftp-E<gt>error> should be used to check for errors
explicitly after every method call. For instance:

  $sftp = Net::SFTP::Foreign->new($host);
  $sftp->error and die "unable to connect to remote host: " . $sftp->error;

Also, the L</die_on_error> method provides a handy shortcut for the last line:

  $sftp = Net::SFTP::Foreign->new($host);
  $sftp->die_on_error("unable to connect to remote host");

Alternatively, the C<autodie> mode that makes the module die when any
error is found can be activated from the constructor. For instance:

  $sftp = Net::SFTP::Foreign->new($host, autodie => 1);
  my $ls = $sftp->ls("/bar");
  # dies as: "Couldn't open remote dir '/bar': No such file"

The C<autodie> mode will be disabled when an C<on_error> handler is
passed to methods accepting it:

  my $sftp = Net::SFTP::Foreign->new($host, autodie => 1);
  # prints "foo!" and does not die:
  $sftp->find("/sdfjkalshfl", # nonexistent directory
              on_error => sub { print "foo!\n" });
  # dies:
  $sftp->find("/sdfjkalshfl");

=head2 API

The methods available from this module are described below.

Don't forget to read also the FAQ and BUGS sections at the end of this
document!

=over 4

=item Net::SFTP::Foreign->new($host, %args)

=item Net::SFTP::Foreign->new(%args)

Opens a new SFTP connection with a remote host C<$host>, and returns a
Net::SFTP::Foreign object representing that open connection.

An explicit check for errors should be included always after the
constructor call:

  my $sftp = Net::SFTP::Foreign->new(...);
  $sftp->die_on_error("SSH connection failed");

The optional arguments accepted are as follows:

=over 4

=item host =E<gt> $hostname

remote host name

=item user =E<gt> $username

username to log in to the remote server. This should be your SSH
login, and can be empty, in which case the username is drawn from the
user executing the process.

=item port =E<gt> $portnumber

port number where the remote SSH server is listening

=item ssh1 =E<gt> 1

use old SSH1 approach for starting the remote SFTP server.

=item more =E<gt> [@more_ssh_args]

additional args passed to C<ssh> command.

For debugging purposes you can run C<ssh> in verbose mode passing it
the C<-v> option:

  my $sftp = Net::SFTP::Foreign->new($host, more => '-v');

Note that this option expects a single command argument or a reference
to an array of arguments. For instance:

  more => '-v'         # right
  more => ['-v']       # right
  more => "-c $cipher"    # wrong!!!
  more => [-c => $cipher] # right

=item timeout =E<gt> $seconds

when this parameter is set, the connection is dropped if no data
arrives on the SSH socket for the given time while waiting for some
command to complete.

When the timeout expires, the current method is aborted and
the SFTP connection becomes invalid.

=item fs_encoding =E<gt> $encoding

Version 3 of the SFTP protocol (the one supported by this module)
knows nothing about the character encoding used on the remote
filesystem to represent file and directory names.

This option allows one to select the encoding used in the remote
machine. The default value is C<utf8>.

For instance:

  $sftp = Net::SFTP::Foreign->new('user@host', fs_encoding => 'latin1');

will convert any path name passed to any method in this package to its
C<latin1> representation before sending it to the remote side.

Note that this option will not affect file contents in any way.

This feature is not supported in perl 5.6 due to incomplete Unicode
support in the interpreter.

=item key_path =E<gt> $filename

=item key_path =E<gt> \@filenames

asks C<ssh> to use the key(s) in the given file(s) for authentication.

=item password =E<gt> $password

Logs into the remote host using password authentication with the given
password.

Password authentication is only available if the module L<IO::Pty> is
installed. Note also, that on Windows this module is only available
when running the Cygwin port of Perl.

=item asks_for_username_at_login =E<gt> 0|'auto'|1

During the interactive authentication dialog, most SSH servers only
ask for the user password as the login name is passed inside the SSH
protocol. But under some uncommon servers or configurations it is
possible that a username is also requested.

When this flag is set to C<1>, the username will be send
unconditionally at the first remote prompt and then the password at
the second.

When it is set to C<auto> the module will use some heuristics in order
to determine if it is being asked for an username.

When set to C<0>, the username will never be sent during the
authentication dialog. This is the default.

=item password_prompt => $regex_or_str

The module expects the password prompt from the remote server to end
in a colon or a question mark. This seems to cover correctly 99% of
real life cases.

Otherwise this option can be used to handle the exceptional cases. For
instance:

  $sftp = Net::SFTP::Foreign->new($host, password => $password,
                                  password_prompt => qr/\bpassword>\s*$/);

Note that your script will hang at the login phase if the wrong prompt
is used.

=item passphrase =E<gt> $passphrase

Logs into the remote server using a passphrase protected private key.

Requires also the module L<IO::Pty>.

=item expect_log_user =E<gt> $bool

This feature is obsolete as Expect is not used anymore to handle
password authentication.

=item ssh_cmd =E<gt> $sshcmd

=item ssh_cmd =E<gt> \@sshcmd

name of the external SSH client. By default C<ssh> is used.

For instance:

  $sftp = Net::SFTP::Foreign->new($host, ssh_cmd => 'plink');

When an array reference is used, its elements are inserted at the
beginning of the system call. That allows, for instance, to connect to
the target host through some SSH proxy:

  $sftp = Net::SFTP::Foreign->new($host,
              ssh_cmd => qw(ssh -l user proxy.server ssh));

But note that the module will not handle password authentication for
those proxies.

=item ssh_cmd_interface =E<gt> 'plink' or 'ssh' or 'tectia'

declares the command line interface that the SSH client used to
connect to the remote host understands. Currently C<plink>, C<ssh> and
C<tectia> are supported.

This option would be rarely required as the module infers the
interface from the SSH command name.

=item transport =E<gt> $fh

=item transport =E<gt> [$in_fh, $out_fh]

=item transport =E<gt> [$in_fh, $out_fh, $pid]

allows one to use an already open pipe or socket as the transport for
the SFTP protocol.

It can be (ab)used to make this module work with password
authentication or with keys requiring a passphrase.

C<in_fh> is the file handler used to read data from the remote server,
C<out_fh> is the file handler used to write data.

On some systems, when using a pipe as the transport, closing it, does
not cause the process at the other side to exit. The additional
C<$pid> argument can be used to instruct this module to kill that
process if it doesn't exit by itself.

=item open2_cmd =E<gt> [@cmd]

=item open2_cmd =E<gt> $cmd;

allows one to completely redefine how C<ssh> is called. Its arguments
are passed to L<IPC::Open2::open2> to open a pipe to the remote
server.

=item stderr_fh =E<gt> $fh

redirects the output sent to stderr by the SSH subprocess to the given
file handle.

It can be used to suppress banners:

  open my $ssherr, '>', '/dev/null' or die "unable to open /dev/null";
  my $sftp = Net::SFTP::Foreign->new($host,
                                     stderr_fh => $ssherr);

Or to send SSH stderr to a file in order to capture errors for later
analysis:

  my $ssherr = File::Temp->new or die "File::Temp->new failed";
  my $sftp = Net::SFTP::Foreign->new($hostname, more => ['-v'],
                                     stderr_fh => $ssherr);
  if ($sftp->error) {
    print "sftp error: ".$sftp->error."\n";
    seek($ssherr, 0, 0);
    while (<$ssherr>) {
      print "captured stderr: $_";
    }
  }

=item stderr_discard =E<gt> 1

redirects stderr to /dev/null

=item block_size =E<gt> $default_block_size

=item queue_size =E<gt> $default_queue_size

default C<block_size> and C<queue_size> used for read and write
operations (see the C<put> or C<get> documentation).

=item autoflush =E<gt> $bool

by default, and for performance reasons, write operations are cached,
and only when the write buffer becomes big enough is the data written to
the remote file. Setting this flag makes the write operations immediate.

=item write_delay =E<gt> $bytes

This option determines how many bytes are buffered before the real
SFTP write operation is performed.

=item read_ahead =E<gt> $bytes

On read operations this option determines how many bytes to read in
advance so that later read operations can be fulfilled from the
buffer.

Using a high value will increase the performance of the module for a
sequential reads access pattern but degrade it for a short random
reads access pattern. It can also cause synchronization problems if
the file is concurrently modified by other parties (L</flush> can be
used to discard all the data inside the read buffer on demand).

The default value is set dynamically considering some runtime
parameters and given options, though it tends to favor the sequential
read access pattern.

=item autodisconnect =E<gt> $ad

by default, the SSH connection is closed from the DESTROY method when
the object goes out of scope. But on scripts that fork new processes,
that results on the SSH connection being closed by the first process
where the object goes out of scope, something undesirable.

This option allows one to work-around this issue to some extend.

The acceptable values for C<$ad> are:

=over 4

=item 0

Never try to disconnect this object when exiting from any process.

On most operating systems, the SSH process will exit when the last
process connected to it ends, but this is not guaranteed.

=item 1

Disconnect on exit from any process. This is the default.

=item 2

Disconnect on exit from the current process only.

=back

See also the C<disconnect> and C<autodisconnect> methods.

=item late_set_perm =E<gt> $bool

See the FAQ below.

=item dirty_cleanup =E<gt> $bool

Sets the C<dirty_cleanup> flag in a per object basis (see the BUGS
section).

=item backend => $backend

From version 1.57 Net::SFTP::Foreign supports plugable backends in
order to allow other ways to communicate with the remote server in
addition to the default I<pipe-to-ssh-process>.

Custom backends may change the set of options supported by the C<new>
method.

=item autodie => $bool

Enables the autodie mode that will cause the module to die when any
error is found (a la L<autodie>).

=back

=item $sftp-E<gt>error

Returns the error code from the last executed command. The value
returned is similar to C<$!>, when used as a string it yields the
corresponding error string.

See L<Net::SFTP::Foreign::Constants> for a list of possible error
codes and how to import them on your scripts.

=item $sftp-E<gt>die_on_error($msg)

Convenience method:

  $sftp->die_on_error("Something bad happened");
  # is a shortcut for...
  $sftp->error and die "Something bad happened: " . $sftp->error;

=item $sftp-E<gt>status

Returns the code from the last SSH2_FXP_STATUS response. It is also a
dualvar that yields the status string when used as a string.

Usually C<$sftp-E<gt>error> should be checked first to see if there was
any error and then C<$sftp-E<gt>status> to find out its low level cause.

=item $sftp-E<gt>cwd

Returns the remote current working directory.

When a relative remote path is passed to any of the methods on this
package, this directory is used to compose the absolute path.

=item $sftp-E<gt>setcwd($dir)

Changes the remote current working directory. The remote directory
should exist, otherwise the call fails.

Returns the new remote current working directory or undef on failure.

=item $sftp-E<gt>get($remote, $local, %options)

X<get>Copies remote file C<$remote> to local $local. By default file
attributes are also copied (permissions, atime and mtime). For
instance:

  $sftp->get('/var/log/messages', /tmp/messages')
    or die "file transfer failed: " . $sftp->error;

A file handle can also be used as the local target. In that case, the
remote file contents are retrieved and written to the given file
handle. Note also that the handle is not closed when the transmission
finish.

  open F, '| gzip -c > /tmp/foo' or die ...;
  $sftp->get("/etc/passwd", \*F)
    or die "get failed: " . $sftp->error;
  close F or die ...;

Accepted options (not all combinations are possible):

=over 4

=item copy_time =E<gt> $bool

determines if access and modification time attributes have to be
copied from remote file. Default is to copy them.

=item copy_perm =E<gt> $bool

determines if permission attributes have to be copied from remote
file. Default is to copy them after applying the local process umask.

=item umask =E<gt> $umask

allows one to select the umask to apply when setting the permissions
of the copied file. Default is to use the umask for the current
process or C<0> if the C<perm> option is also used.

=item perm =E<gt> $perm

sets the permission mask of the file to be $perm, remote
permissions are ignored.

=item resume =E<gt> 1 | 'auto'

resumes an interrupted transfer.

If the C<auto> value is given, the transfer will be resumed only when
the local file is newer than the remote one.

C<get> transfers can not be resumed when a data conversion is in
place.

=item append =E<gt> 1

appends the contents of the remote file at the end of the local one
instead of overwriting it. If the local file does not exist a new one
is created.

=item overwrite =E<gt> 0

setting this option to zero cancels the transfer when a local file of
the same name already exists.

=item numbered =E<gt> 1

modifies the local file name inserting a sequence number when required
in order to avoid overwriting local files.

For instance:

  for (1..2) {
    $sftp->get("data.txt", "data.txt", numbered => 1);
  }

will copy the remote file as C<data.txt> the first time and as
C<data(1).txt> the second one.

If a scalar reference is passed as the numbered value, the final
target will be stored in the value pointed by the reference. For
instance:

  my $target;
  $sftp->get("data.txt", "data.txt", numbered => \$target);
  say "file was saved as $target" unless $sftp->error

=item atomic =E<gt> 1

The remote file contents are transferred into a temporal file that
once the copy completes is renamed to the target destination.

If not-overwrite of remote files is also requested, an empty file may
appear at the target destination before the rename operation is
performed. This is due to limitations of some operating/file systems.

=item cleanup =E<gt> 1

If the transfer fails, remove the incomplete file.

This option is set to by default when there is not possible to resume
the transfer afterwards (i.e., when using `atomic` or `numbered`
options).

=item best_effort =E<gt> 1

Ignore minor errors as setting time or permissions.

=item conversion =E<gt> $conversion

on the fly data conversion of the file contents can be performed with
this option. See L</On the fly data conversion> below.

=item callback =E<gt> $callback

C<$callback> is a reference to a subroutine that will be called after
every iteration of the download process.

The callback function will receive as arguments: the current
Net::SFTP::Foreign object; the data read from the remote file; the
offset from the beginning of the file in bytes; and the total size of
the file in bytes.

This mechanism can be used to provide status messages, download
progress meters, etc.:

    sub callback {
        my($sftp, $data, $offset, $size) = @_;
        print "Read $offset / $size bytes\r";
    }

The C<abort> method can be called from inside the callback to abort
the transfer:

    sub callback {
        my($sftp, $data, $offset, $size) = @_;
        if (want_to_abort_transfer()) {
            $sftp->abort("You wanted to abort the transfer");
        }
    }

The callback will be called one last time with an empty data argument
to indicate the end of the file transfer.

The size argument can change between different calls as data is
transferred (for instance, when on-the-fly data conversion is being
performed or when the size of the file can not be retrieved with the
C<stat> SFTP command before the data transfer starts).

=item block_size =E<gt> $bytes

size of the blocks the file is being split on for transfer.
Incrementing this value can improve performance but most servers limit
the maximum size.

=item queue_size =E<gt> $size

read and write requests are pipelined in order to maximize transfer
throughput. This option allows one to set the maximum number of
requests that can be concurrently waiting for a server response.

=back

=item $sftp-E<gt>get_content($remote)

Returns the content of the remote file.

=item $sftp-E<gt>get_symlink($remote, $local, %opts)

copies a symlink from the remote server to the local file system

The accepted options are C<overwrite> and C<numbered>. They have the
same effect as for the C<get> method.

=item $sftp-E<gt>put($local, $remote, %opts)

Uploads a file C<$local> from the local host to the remote host saving
it as C<$remote>. By default file attributes are also copied. For
instance:

  $sftp->put("test.txt", "test.txt")
    or die "put failed: " . $sftp->error;

A file handle can also be passed in the C<$local> argument. In that
case, data is read from there and stored in the remote file. UTF8 data
is not supported unless a custom converter callback is used to
transform it to bytes. The method will croak if it encounters any data
in perl internal UTF8 format. Note also that the handle is not closed
when the transmission finish.

Example:

  binmode STDIN;
  $sftp->put(\*STDIN, "stdin.dat") or die "put failed";
  close STDIN;

This method accepts several options:

=over 4

=item copy_time =E<gt> $bool

determines if access and modification time attributes have to be
copied from remote file. Default is to copy them.

=item copy_perm =E<gt> $bool

determines if permission attributes have to be copied from remote
file. Default is to copy them after applying the local process umask.

=item umask =E<gt> $umask

allows one to select the umask to apply when setting the permissions
of the copied file. Default is to use the umask for the current
process.

=item perm =E<gt> $perm

sets the permission mask of the file to be $perm, umask and local
permissions are ignored.

=item overwrite =E<gt> 0

by default C<put> will overwrite any pre-existent file with the same
name at the remote side. Setting this flag to zero will make the
method fail in that case.

=item numbered =E<gt> 1

when set, a sequence number is added to the remote file name in order
to avoid overwriting pre-existent files. Off by default.

=item append =E<gt> 1

appends the local file at the end of the remote file instead of
overwriting it. If the remote file does not exist a new one is
created. Off by default.

=item resume =E<gt> 1 | 'auto'

resumes an interrupted transfer.

If the C<auto> value is given, the transfer will be resumed only when
the remote file is newer than the local one.

=item sparse =E<gt> 1

Blocks that are all zeros are skipped possibly creating an sparse file
on the remote host.

=item atomic =E<gt> 1

The local file contents are transferred into a temporal file that
once the copy completes is renamed to the target destination.

This operation relies on the SSH server to perform an
overwriting/non-overwriting atomic rename operation free of race
conditions.

OpenSSH server does it correctly on top of Linux/UNIX native file
systems (i.e. ext[234]>, ffs or zfs) but has problems on file systems
not supporting hard links (i.e. FAT) or on operating systems with
broken POSIX semantics as Windows.

=item cleanup =E<gt> 1

If the transfer fails, attempts to remove the incomplete file. Cleanup
may fail (for example, if the SSH connection gets broken).

This option is set by default when the transfer is not resumable
(i.e., when using `atomic` or `numbered` options).

=item best_effort =E<gt> 1

Ignore minor errors, as setting time and permissions on the remote
file.

=item conversion =E<gt> $conversion

on the fly data conversion of the file contents can be performed with
this option. See L</On the fly data conversion> below.

=item callback =E<gt> $callback

C<$callback> is a reference to a subroutine that will be called after
every iteration of the upload process.

The callback function will receive as arguments: the current
Net::SFTP::Foreign object; the data that is going to be written to the
remote file; the offset from the beginning of the file in bytes; and
the total size of the file in bytes.

The callback will be called one last time with an empty data argument
to indicate the end of the file transfer.

The size argument can change between calls as data is transferred (for
instance, when on the fly data conversion is being performed).

This mechanism can be used to provide status messages, download
progress meters, etc.

The C<abort> method can be called from inside the callback to abort
the transfer.

=item block_size =E<gt> $bytes

size of the blocks the file is being split on for transfer.
Incrementing this value can improve performance but some servers limit
its size and if this limit is overpassed the command will fail.

=item queue_size =E<gt> $size

read and write requests are pipelined in order to maximize transfer
throughput. This option allows one to set the maximum number of
requests that can be concurrently waiting for a server response.

=item late_set_perm =E<gt> $bool

See the FAQ below.

=back

=item $sftp-E<gt>put_content($bytes, $remote, %opts)

Creates (or overwrites) a remote file whose content is the passed
data.

=item $sftp-E<gt>put_symlink($local, $remote, %opts)

Copies a local symlink to the remote host.

The accepted options are C<overwrite> and C<numbered>.

=item $sftp-E<gt>abort()

=item $sftp-E<gt>abort($msg)

This method, when called from inside a callback sub, causes the
current transfer to be aborted

The error state is set to SFTP_ERR_ABORTED and the optional $msg
argument is used as its textual value.

=item $sftp-E<gt>ls($remote, %opts)

Fetches a listing of the remote directory C<$remote>. If C<$remote> is
not given, the current remote working directory is listed.

Returns a reference to a list of entries. Every entry is a reference
to a hash with three keys: C<filename>, the name of the entry;
C<longname>, an entry in a "long" listing like C<ls -l>; and C<a>, a
L<Net::SFTP::Foreign::Attributes> object containing file atime, mtime,
permissions and size.

    my $ls = $sftp->ls('/home/foo')
        or die "unable to retrieve directory: ".$sftp->error;

    print "$_->{filename}\n" for (@$ls);



The options accepted by this method are as follows (note that usage of
some of them can degrade the method performance when reading large
directories):

=over 4

=item wanted =E<gt> qr/.../

Only elements whose name matches the given regular expression are
included on the listing.

=item wanted =E<gt> sub {...}

Only elements for which the callback returns a true value are included
on the listing. The callback is called with two arguments: the
C<$sftp> object and the current entry (a hash reference as described
before). For instance:

  use Fcntl ':mode';

  my $files = $sftp->ls ( '/home/hommer',
			  wanted => sub {
			      my $entry = $_[1];
			      S_ISREG($entry->{a}->perm)
			  } )
	or die "ls failed: ".$sftp->error;


=item no_wanted =E<gt> qr/.../

=item no_wanted =E<gt> sub {...}

those options have the opposite result to their C<wanted> counterparts:

  my $no_hidden = $sftp->ls( '/home/homer',
			     no_wanted => qr/^\./ )
	or die "ls failed";


When both C<no_wanted> and C<wanted> rules are used, the C<no_wanted>
rule is applied first and then the C<wanted> one (order is important
if the callbacks have side effects, experiment!).

=item ordered =E<gt> 1

the list of entries is ordered by filename.

=item follow_links =E<gt> 1

by default, the attributes on the listing correspond to a C<lstat>
operation, setting this option causes the method to perform C<stat>
requests instead. C<lstat> attributes will still appear for links
pointing to non existent places.

=item atomic_readdir =E<gt> 1

reading a directory is not an atomic SFTP operation and the protocol
draft does not define what happens if C<readdir> requests and write
operations (for instance C<remove> or C<open>) affecting the same
directory are intermixed.

This flag ensures that no callback call (C<wanted>, C<no_wanted>) is
performed in the middle of reading a directory and has to be set if
any of the callbacks can modify the file system.

=item realpath =E<gt> 1

for every file object, performs a realpath operation and populates the
C<realpath> entry.

=item names_only =E<gt> 1

makes the method return a simple array containing the file names from
the remote directory only. For instance, these two sentences are
equivalent:

  my @ls1 = @{ $sftp->ls('.', names_only => 1) };

  my @ls2 = map { $_->{filename} } @{$sftp->ls('.')};

=back

=item $sftp-E<gt>find($path, %opts)

=item $sftp-E<gt>find(\@paths, %opts)

X<find>Does a recursive search over the given directory C<$path> (or
directories C<@path>) and returns a list of the entries found or the
total number of them on scalar context.

Every entry is a reference to a hash with two keys: C<filename>, the
full path of the entry; and C<a>, a L<Net::SFTP::Foreign::Attributes>
object containing file atime, mtime, permissions and size.

This method tries to recover and continue under error conditions.

The options accepted:

=over 4

=item on_error =E<gt> sub { ... }

the callback is called when some error is detected, two arguments are
passed: the C<$sftp> object and the entry that was being processed
when the error happened. For instance:

  my @find = $sftp->find( '/',
			  on_error => sub {
			      my ($sftp, $e) = @_;
		 	      print STDERR "error processing $e->{filename}: "
				   . $sftp->error;
			  } );

=item realpath =E<gt> 1

calls method C<realpath> for every entry, the result is stored under
the key C<realpath>. This option slows down the process as a new
remote query is performed for every entry, specially on networks with
high latency.

=item follow_links =E<gt> 1

By default symbolic links are not resolved and appear as that on the
final listing. This option causes then to be resolved and substituted
by the target file system object. Dangling links are ignored, though
they generate a call to the C<on_error> callback when stat fails on
them.

Following symbolic links can introduce loops on the search. Infinite
loops are detected and broken but files can still appear repeated on
the final listing under different names unless the option C<realpath>
is also active.

=item ordered =E<gt> 1

By default, the file system is searched in an implementation dependent
order (actually optimized for low memory consumption). If this option
is included, the file system is searched in a deep-first, sorted by
filename fashion.

=item wanted =E<gt> qr/.../

=item wanted =E<gt> sub { ... }

=item no_wanted =E<gt> qr/.../

=item no_wanted =E<gt> sub { ... }

These options have the same effect as on the C<ls> method, allowing to
filter out unwanted entries (note that filename keys contain B<full
paths> here).

The callbacks can also be used to perform some action instead of
creating the full listing of entries in memory (that could use huge
amounts of RAM for big file trees):

  $sftp->find($src_dir,
	      wanted => sub {
		  my $fn = $_[1]->{filename}
		  print "$fn\n" if $fn =~ /\.p[ml]$/;
		  return undef # so it is discarded
	      });

=item descend =E<gt> qr/.../

=item descend =E<gt> sub { ... }

=item no_descend =E<gt> qr/.../

=item no_descend =E<gt> sub { ... }

These options, similar to the C<wanted> ones, allow to prune the
search, discarding full subdirectories. For instance:

    use Fcntl ':mode';
    my @files = $sftp->find( '.',
			     no_descend => qr/\.svn$/,
			     wanted => sub {
				 S_ISREG($_[1]->{a}->perm)
			     } );


C<descend> and C<wanted> rules are unrelated. A directory discarded by
a C<wanted> rule will still be recursively searched unless it is also
discarded on a C<descend> rule and vice versa.

=item atomic_readdir =E<gt> 1

see C<ls> method documentation.

=item names_only =E<gt> 1

makes the method return a list with the names of the files only (see C<ls>
method documentation).

equivalent:

  my $ls1 = $sftp->ls('.', names_only => 1);

=back

=item $sftp-E<gt>glob($pattern, %opts)

X<glob>performs a remote glob and returns the list of matching entries
in the same format as the L</find> method.

This method tries to recover and continue under error conditions.

The given pattern can be a UNIX style pattern (see L<glob(7)>) or a
Regexp object (i.e C<qr/foo/>). In the later case, only files on the
current working directory will be matched against the Regexp.

Accepted options:

=over 4

=item ignore_case =E<gt> 1

by default the matching over the file system is carried out in a case
sensitive fashion, this flag changes it to be case insensitive.

This flag is ignored when a Regexp object is used as the pattern.

=item strict_leading_dot =E<gt> 0

by default, a dot character at the beginning of a file or directory
name is not matched by wildcards (C<*> or C<?>). Setting this flags to
a false value changes this behaviour.

This flag is ignored when a Regexp object is used as the pattern.

=item follow_links =E<gt> 1

=item ordered =E<gt> 1

=item names_only =E<gt> 1

=item realpath =E<gt> 1

=item on_error =E<gt> sub { ... }

=item wanted =E<gt> ...

=item no_wanted =E<gt> ...

these options perform as on the C<ls> method.

=back

Some usage samples:

  my $files = $sftp->glob("*/lib");

  my $files = $sftp->glob("/var/log/dmesg.*.gz");

  $sftp->set_cwd("/var/log");
  my $files = $sftp->glob(qr/^dmesg\.[\d+]\.gz$/);

  my $files = $sftp->glob("*/*.pdf", strict_leading_dot => 0);

=item $sftp-E<gt>rget($remote, $local, %opts)

Recursively copies the contents of remote directory C<$remote> to
local directory C<$local>. Returns the total number of elements
(files, directories and symbolic links) successfully copied.

This method tries to recover and continue when some error happens.

The options accepted are:

=over 4

=item umask =E<gt> $umask

use umask C<$umask> to set permissions on the files and directories
created.

=item copy_perm =E<gt> $bool;

if set to a true value, file and directory permissions are copied to
the remote server (after applying the umask). On by default.

=item copy_time =E<gt> $bool;

if set to a true value, file atime and mtime are copied from the
remote server. By default it is on.

=item overwrite =E<gt> $bool

if set to a true value, when a local file with the same name
already exists it is overwritten. On by default.

=item numbered =E<gt> $bool

when required, adds a sequence number to local file names in order to
avoid overwriting pre-existent remote files. Off by default.

=item newer_only =E<gt> $bool

if set to a true value, when a local file with the same name
already exists it is overwritten only if the remote file is newer.

=item ignore_links =E<gt> $bool

if set to a true value, symbolic links are not copied.

=item on_error =E<gt> sub { ... }

the passed sub is called when some error happens. It is called with two
arguments, the C<$sftp> object and the entry causing the error.

=item wanted =E<gt> ...

=item no_wanted =E<gt> ...

This option allows one to select which files and directories have to
be copied. See also C<ls> method docs.

If a directory is discarded all of its contents are also discarded (as
it is not possible to copy child files without creating the directory
first!).

=item atomic =E<gt> 1

=item block_size =E<gt> $block_size

=item queue_size =E<gt> $queue_size

=item conversion =E<gt> $conversion

=item resume =E<gt> $resume

=item best_effort =E<gt> $best_effort

See C<get> method docs.

=back

=item $sftp-E<gt>rput($local, $remote, %opts)

Recursively copies the contents of local directory C<$local> to
remote directory C<$remote>.

This method tries to recover and continue when some error happens.

Accepted options are:

=over 4

=item umask =E<gt> $umask

use umask C<$umask> to set permissions on the files and directories
created.

=item copy_perm =E<gt> $bool;

if set to a true value, file and directory permissions are copied
to the remote server (after applying the umask). On by default.

=item copy_time =E<gt> $bool;

if set to a true value, file atime and mtime are copied to the
remote server. On by default.

=item overwrite =E<gt> $bool

if set to a true value, when a remote file with the same name already
exists it is overwritten. On by default.

=item newer_only =E<gt> $bool

if set to a true value, when a remote file with the same name already exists it is
overwritten only if the local file is newer.

=item ignore_links =E<gt> $bool

if set to a true value, symbolic links are not copied

=item on_error =E<gt> sub { ... }

the passed sub is called when some error happens. It is called with two
arguments, the C<$sftp> object and the entry causing the error.

=item wanted =E<gt> ...

=item no_wanted =E<gt> ...

This option allows one to select which files and directories have to
be copied. See also C<ls> method docs.

If a directory is discarded all of its contents are also discarded (as
it is not possible to copy child files without creating the directory
first!).

=item atomic =E<gt> 1

=item block_size =E<gt> $block_size

=item queue_size =E<gt> $queue_size

=item conversion =E<gt> $conversion

=item resume =E<gt> $resume

=item best_effort =E<gt> $best_effort

=item late_set_perm =E<gt> $bool

see C<put> method docs.

=back

=item $sftp-E<gt>rremove($dir, %opts)

=item $sftp-E<gt>rremove(\@dirs, %opts)

recursively remove directory $dir (or directories @dirs) and its
contents. Returns the number of elements successfully removed.

This method tries to recover and continue when some error happens.

The options accepted are:

=over 4

=item on_error =E<gt> sub { ... }

This callback is called when some error is occurs. The arguments
passed are the C<$sftp> object and the current entry (see C<ls> docs
for more information).

=item wanted =E<gt> ...

=item no_wanted =E<gt> ...

Allow to select which file system objects have to be deleted.

=back

=item $sftp-E<gt>mget($remote, $localdir, %opts)

=item $sftp-E<gt>mget(\@remote, $localdir, %opts)

X<mget>expands the wildcards on C<$remote> or C<@remote> and retrieves
all the matching files.

For instance:

  $sftp->mget(['/etc/hostname.*', '/etc/init.d/*'], '/tmp');

The method accepts all the options valid for L</glob> and for L</get>
(except those that do not make sense :-)

C<$localdir> is optional and defaults to the process current working
directory (C<cwd>).

Files are saved with the same name they have in the remote server
excluding the directory parts.

Note that name collisions are not detected. For instance:

 $sftp->mget(["foo/file.txt", "bar/file.txt"], "/tmp")

will transfer the first file to "/tmp/file.txt" and later overwrite it
with the second one. The C<numbered> option can be used to avoid this
issue.

=item $sftp-E<gt>mput($local, $remotedir, %opts)

=item $sftp-E<gt>mput(\@local, $remotedir, %opts)

similar to L</mget> but works in the opposite direction transferring
files from the local side to the remote one.

=item $sftp-E<gt>join(@paths)

returns the given path fragments joined in one path (currently the
remote file system is expected to be UNIX like).

=item $sftp-E<gt>open($path, $flags [, $attrs ])

Sends the C<SSH_FXP_OPEN> command to open a remote file C<$path>,
and returns an open handle on success. On failure returns
C<undef>.

The returned value is a tied handle (see L<Tie::Handle>) that can be
used to access the remote file both with the methods available from
this module and with perl built-ins. For instance:

  # reading from the remote file
  my $fh1 = $sftp->open("/etc/passwd")
    or die $sftp->error;
  while (<$fh1>) { ... }

  # writing to the remote file
  use Net::SFTP::Foreign::Constants qw(:flags);
  my $fh2 = $sftp->open("/foo/bar", SSH2_FXF_WRITE|SSH2_FXF_CREAT)
    or die $sftp->error;
  print $fh2 "printing on the remote file\n";
  $sftp->write($fh2, "writing more");

The C<$flags> bitmap determines how to open the remote file as defined
in the SFTP protocol draft (the following constants can be imported
from L<Net::SFTP::Foreign::Constants>):

=over 4

=item SSH2_FXF_READ

Open the file for reading. It is the default mode.

=item SSH2_FXF_WRITE

Open the file for writing.  If both this and C<SSH2_FXF_READ> are
specified, the file is opened for both reading and writing.

=item SSH2_FXF_APPEND

Force all writes to append data at the end of the file.

As OpenSSH SFTP server implementation ignores this flag, the module
emulates it (I will appreciate receiving feedback about the
inter-operation of this module with other server implementations when
this flag is used).

=item SSH2_FXF_CREAT

If this flag is specified, then a new file will be created if one does
not already exist.

=item SSH2_FXF_TRUNC

Forces an existing file with the same name to be truncated to zero
length when creating a file. C<SSH2_FXF_CREAT> must also be specified
if this flag is used.

=item SSH2_FXF_EXCL

Causes the request to fail if the named file already exists.
C<SSH2_FXF_CREAT> must also be specified if this flag is used.

=back

When creating a new remote file, C<$attrs> allows one to set its
initial attributes. C<$attrs> has to be an object of class
L<Net::SFTP::Foreign::Attributes>.

=item $sftp-E<gt>close($handle)

Closes the remote file handle C<$handle>.

Files are automatically closed on the handle C<DESTROY> method when
not done explicitly.

Returns true on success and undef on failure.

=item $sftp-E<gt>read($handle, $length)

reads C<$length> bytes from an open file handle C<$handle>. On success
returns the data read from the remote file and undef on failure
(including EOF).

=item $sftp-E<gt>write($handle, $data)

writes C<$data> to the remote file C<$handle>. Returns the number of
bytes written or undef on failure.

=item $sftp-E<gt>readline($handle)

=item $sftp-E<gt>readline($handle, $sep)

in scalar context reads and returns the next line from the remote
file. In list context, it returns all the lines from the current
position to the end of the file.

By default "\n" is used as the separator between lines, but a
different one can be used passing it as the second method argument. If
the empty string is used, it returns all the data from the current
position to the end of the file as one line.

=item $sftp-E<gt>getc($handle)

returns the next character from the file.

=item $sftp-E<gt>seek($handle, $pos, $whence)

sets the current position for the remote file handle C<$handle>. If
C<$whence> is 0, the position is set relative to the beginning of the
file; if C<$whence> is 1, position is relative to current position and
if $<$whence> is 2, position is relative to the end of the file.

returns a trues value on success, undef on failure.

=item $sftp-E<gt>tell($fh)

returns the current position for the remote file handle C<$handle>.

=item $sftp-E<gt>eof($fh)

reports whether the remote file handler points at the end of the file.

=item $sftp-E<gt>flush($fh)

X<flush>writes to the remote file any pending data and discards the read
cache.

=item $sftp-E<gt>sftpread($handle, $offset, $length)

low level method that sends a SSH2_FXP_READ request to read from an
open file handle C<$handle>, C<$length> bytes starting at C<$offset>.

Returns the data read on success and undef on failure.

Some servers (for instance OpenSSH SFTP server) limit the size of the
read requests and so the length of data returned can be smaller than
requested.

=item $sftp-E<gt>sftpwrite($handle, $offset, $data)

low level method that sends a C<SSH_FXP_WRITE> request to write to an
open file handle C<$handle>, starting at C<$offset>, and where the
data to be written is in C<$data>.

Returns true on success and undef on failure.

=item $sftp-E<gt>opendir($path)

Sends a C<SSH_FXP_OPENDIR> command to open the remote directory
C<$path>, and returns an open handle on success (unfortunately,
current versions of perl does not support directory operations via
tied handles, so it is not possible to use the returned handle as a
native one).

On failure returns C<undef>.

=item $sftp-E<gt>closedir($handle)

closes the remote directory handle C<$handle>.

Directory handles are closed from their C<DESTROY> method when not
done explicitly.

Return true on success, undef on failure.

=item $sftp-E<gt>readdir($handle)

returns the next entry from the remote directory C<$handle> (or all
the remaining entries when called in list context).

The return values are a hash with three keys: C<filename>, C<longname> and
C<a>. The C<a> value contains a L<Net::SFTP::Foreign::Attributes>
object describing the entry.

Returns undef on error or when no more entries exist on the directory.

=item $sftp-E<gt>stat($path_or_fh)

performs a C<stat> on the remote file and returns a
L<Net::SFTP::Foreign::Attributes> object with the result values. Both
paths and open remote file handles can be passed to this method.

Returns undef on failure.

=item $sftp-E<gt>fstat($handle)

this method is deprecated.

=item $sftp-E<gt>lstat($path)

this method is similar to C<stat> method but stats a symbolic link
instead of the file the symbolic links points to.

=item $sftp-E<gt>setstat($path_or_fh, $attrs)

sets file attributes on the remote file. Accepts both paths and open
remote file handles.

Returns true on success and undef on failure.

=item $sftp-E<gt>fsetstat($handle, $attrs)

this method is deprecated.

=item $sftp-E<gt>truncate($path_or_fh, $size)

=item $sftp-E<gt>chown($path_or_fh, $uid, $gid)

=item $sftp-E<gt>chmod($path_or_fh, $perm)

=item $sftp-E<gt>utime($path_or_fh, $atime, $mtime)

Shortcuts around C<setstat> method.

=item $sftp-E<gt>remove($path)

Sends a C<SSH_FXP_REMOVE> command to remove the remote file
C<$path>. Returns a true value on success and undef on failure.

=item $sftp-E<gt>mkdir($path)

=item $sftp-E<gt>mkdir($path, $attrs)

Sends a C<SSH_FXP_MKDIR> command to create a remote directory C<$path>
whose attributes are initialized to C<$attrs> (a
L<Net::SFTP::Foreign::Attributes> object) if given.

Returns a true value on success and undef on failure.

=item $sftp-E<gt>mkpath($path)

=item $sftp-E<gt>mkpath($path, $attrs)

This method is similar to C<mkdir> but also creates any non-existent
parent directories recursively.

=item $sftp-E<gt>rmdir($path)

Sends a C<SSH_FXP_RMDIR> command to remove a remote directory
C<$path>. Returns a true value on success and undef on failure.

=item $sftp-E<gt>realpath($path)

Sends a C<SSH_FXP_REALPATH> command to canonicalise C<$path>
to an absolute path. This can be useful for turning paths
containing C<'..'> into absolute paths.

Returns the absolute path on success, C<undef> on failure.

=item $sftp-E<gt>rename($old, $new, %opts)

Sends a C<SSH_FXP_RENAME> command to rename C<$old> to C<$new>.
Returns a true value on success and undef on failure.

Accepted options are:

=over 4

=item overwrite => $bool

By default, the rename operation fails when a file C<$new> already
exists. When this options is set, any previous existent file is
deleted first (the C<atomic_rename> operation will be used if
available).

Note than under some conditions the target file could be deleted and
afterwards the rename operation fail.

=back

=item $sftp-E<gt>atomic_rename($old, $new)

Renames a file using the C<posix-rename@openssh.com> extension when
available.

Unlike the C<rename> method, it overwrites any previous C<$new> file.

=item $sftp-E<gt>readlink($path)

Sends a C<SSH_FXP_READLINK> command to read the path where the
symbolic link is pointing.

Returns the target path on success and undef on failure.

=item $sftp-E<gt>symlink($sl, $target)

Sends a C<SSH_FXP_SYMLINK> command to create a new symbolic link
C<$sl> pointing to C<$target>.

C<$target> is stored as-is, without any path expansion taken place on
it. Use C<realpath> to normalize it:

  $sftp->symlink("foo.lnk" => $sftp->realpath("../bar"))

=item $sftp-E<gt>hardlink($hl, $target)

Creates a hardlink on the server.

This command requires support for the 'hardlink@openssh.com' extension
on the server (available in OpenSSH from version 5.7).

=item $sftp-E<gt>statvfs($path)

=item $sftp-E<gt>fstatvfs($fh)

On servers supporting C<statvfs@openssh.com> and
C<fstatvfs@openssh.com> extensions respectively, these methods return
a hash reference with information about the file system where the file
named C<$path> or the open file C<$fh> resides.

The hash entries are:

  bsize   => file system block size
  frsize  => fundamental fs block size
  blocks  => number of blocks (unit f_frsize)
  bfree   => free blocks in file system
  bavail  => free blocks for non-root
  files   => total file inodes
  ffree   => free file inodes
  favail  => free file inodes for to non-root
  fsid    => file system id
  flag    => bit mask of f_flag values
  namemax => maximum filename length

The values of the f_flag bit mask are as follows:

  SSH2_FXE_STATVFS_ST_RDONLY => read-only
  SSH2_FXE_STATVFS_ST_NOSUID => no setuid

=item $sftp-E<gt>disconnect

Closes the SSH connection to the remote host. From this point the
object becomes mostly useless.

Usually, this method should not be called explicitly, but implicitly
from the DESTROY method when the object goes out of scope.

See also the documentation for the C<autodiscconnect> constructor
argument.

=item $sftp-E<gt>autodisconnect($ad)

Sets the C<autodisconnect> behaviour.

See also the documentation for the C<autodiscconnect> constructor
argument. The values accepted here are the same as there.

=back


=head2 On the fly data conversion

Some of the methods on this module allow to perform on the fly data
conversion via the C<conversion> option that accepts the following
values:

=over 4

=item conversion =E<gt> 'dos2unix'

Converts CR+LF line endings (as commonly used under MS-DOS) to LF
(UNIX).

=item conversion =E<gt> 'unix2dos'

Converts LF line endings (UNIX) to CR+LF (DOS).

=item conversion =E<gt> sub { CONVERT $_[0] }

When a callback is given, it is invoked repeatedly as chunks of data
become available. It has to change C<$_[0]> in place in order to
perform the conversion.

Also, the subroutine is called one last time with and empty data
string to indicate that the transfer has finished, so that
intermediate buffers can be flushed.

Note that when writing conversion subroutines, special care has to be
taken to handle sequences crossing chunk borders.

=back

The data conversion is always performed before any other callback
subroutine is called.

See the Wikipedia entry on line endings
L<http://en.wikipedia.org/wiki/Newline> or the article Understanding
Newlines by Xavier Noria
(L<http://www.onlamp.com/pub/a/onlamp/2006/08/17/understanding-newlines.html>)
for details about the different conventions.

=head1 FAQ

=over 4

=item Closing the connection:

B<Q>: How do I close the connection to the remote server?

B<A>: let the C<$sftp> object go out of scope or just undefine it:

  undef $sftp;

=item Using Net::SFTP::Foreign from a cron script:

B<Q>: I wrote a script for performing sftp file transfers that works
beautifully from the command line. However when I try to run the same
script from cron it fails with a broken pipe error:

  open2: exec of ssh -l user some.location.com -s sftp
    failed at Net/SFTP/Foreign.pm line 67

B<A>: C<ssh> is not on your cron PATH.

The remedy is either to add the location of the C<ssh> application to
your cron PATH or to use the C<ssh_cmd> option of the C<new> method to
hardcode the location of C<ssh> inside your script, for instance:

  my $ssh = Net::SFTP::Foreign->new($host,
                                    ssh_cmd => '/usr/local/ssh/bin/ssh');

=item C<more> constructor option expects an array reference:

B<Q>: I'm trying to pass in the private key file using the -i option,
but it keep saying it couldn't find the key. What I'm doing wrong?

B<A>: The C<more> argument on the constructor expects a single option
or a reference to an array of options. It will not split an string
containing several options.

Arguments to SSH options have to be also passed as different entries
on the array:

  my $sftp = Net::SFTP::Foreign->new($host,
                                      more => [qw(-i /home/foo/.ssh/id_dsa)]);

Note also that latest versions of Net::SFTP::Foreign support the
C<key_path> argument:

  my $sftp = Net::SFTP::Foreign->new($host,
                                      key_path => '/home/foo/.ssh/id_dsa');

=item Plink and password authentication

B<Q>: Why password authentication is not supported for the plink SSH
client?

B<A>: A bug in plink breaks it.

Newer versions of Net::SFTP::Foreign pass the password to C<plink>
using its C<-pw> option. As this feature is not completely secure a
warning is generated.

It can be silenced (though, don't do it without understanding why it
is there, please!) as follows:

  no warnings 'Net::SFTP::Foreign';
  my $sftp = Net::SFTP::Foreign->new('foo@bar',
                                     ssh_cmd => 'plink',
                                     password => $password);
  $sftp->die_on_error;

=item Plink

B<Q>: What is C<plink>?

B<A>: Plink is a command line tool distributed with the
L<PuTTY|http://the.earth.li/~sgtatham/putty/> SSH client. Very popular
between MS Windows users, it is also available for Linux and other
UNIX now.

=item Put method fails

B<Q>: put fails with the following error:

  Couldn't setstat remote file: The requested operation cannot be
  performed because there is a file transfer in progress.

B<A>: Try passing the C<late_set_perm> option to the put method:

  $sftp->put($local, $remote, late_set_perm => 1)
     or die "unable to transfer file: " . $sftp->error;

Some servers do not support the C<fsetstat> operation on open file
handles. Setting this flag allows one to delay that operation until
the file has been completely transferred and the remote file handle
closed.

Also, send me a bug report containing a dump of your $sftp object so I
can add code for your particular server software to activate the
work-around automatically.

=item Put method fails even with late_set_perm set

B<Q>: I added C<late_set_perm =E<gt> 1> to the put call, but we are still
receiving the error C<Couldn't setstat remote file (setstat)>.

B<A>: Some servers forbid the SFTP C<setstat> operation used by the
C<put> method for replicating the file permissions and time-stamps on
the remote side.

As a work around you can just disable the feature:

  $sftp->put($local_file, $remote_file,
             copy_perms => 0, copy_time => 0);

=item Disable password authentication completely

B<Q>: When we try to open a session and the key either doesn't exist
or is invalid, the child SSH hangs waiting for a password to be
entered.  Is there a way to make this fail back to the Perl program to
be handled?

B<A>: Disable anything but public key SSH authentication calling the
new method as follows:

  $sftp = Net::SFTP::Foreign->new($host,
                more => [qw(-o PreferredAuthentications=publickey)])

See L<ssh_config(5)> for the details.

=item Understanding C<$attr-E<gt>perm> bits

B<Q>: How can I know if a directory entry is a (directory|link|file|...)?

B<A>: Use the C<S_IS*> functions from L<Fcntl>. For instance:

  use Fcntl qw(S_ISDIR);
  my $ls = $sftp->ls or die $sftp->error;
  for my $entry (@$ls) {
    if (S_ISDIR($entry->{a}->perm)) {
      print "$entry->{filename} is a directory\n";
    }
  }

=item Host key checking

B<Q>: Connecting to a remote server with password authentication fails
with the following error:

  The authenticity of the target host can not be established,
  connect from the command line first

B<A>: That probably means that the public key from the remote server
is not stored in the C<~/.ssh/known_hosts> file. Run an SSH Connection
from the command line as the same user as the script and answer C<yes>
when asked to confirm the key supplied.

Example:

  $ ssh pluto /bin/true
  The authenticity of host 'pluto (172.25.1.4)' can't be established.
  RSA key fingerprint is 41:b1:a7:86:d2:a9:7b:b0:7f:a1:00:b7:26:51:76:52.
  Are you sure you want to continue connecting (yes/no)? yes

Your SSH client may also support some flag to disable this check, but
doing it can ruin the security of the SSH protocol so I advise against
its usage.

Example:

  # Warning: don't do that unless you fully understand
  # its security implications!!!
  $sftp = Net::SFTP::Foreign->new($host,
                                  more => [-o => 'StrictHostKeyChecking no'],
                                  ...);

=back

=head1 BUGS

These are the currently known bugs:

=over 4

=item - Doesn't work on VMS:

The problem is related to L<IPC::Open3> not working on VMS. Patches
are welcome!

=item - Dirty cleanup:

On some operating systems, closing the pipes used to communicate with
the slave SSH process does not terminate it and a work around has to
be applied. If you find that your scripts hung when the $sftp object
gets out of scope, try setting C<$Net::SFTP::Foreign::dirty_cleanup>
to a true value and also send me a report including the value of
C<$^O> on your machine and the OpenSSH version.

From version 0.90_18 upwards, a dirty cleanup is performed anyway when
the SSH process does not terminate by itself in 8 seconds or less.

=item - Reversed symlink arguments:

This package uses the non-conforming OpenSSH argument order for the
SSH_FXP_SYMLINK command that seems to be the de facto standard. When
interacting with SFTP servers that follow the SFTP specification, the
C<symlink> method will interpret its arguments in reverse order.

=item - IPC::Open3 bugs on Windows

On Windows the IPC::Open3 module is used to spawn the slave SSH
process. That module has several nasty bugs (related to STDIN, STDOUT
and STDERR being closed or not being assigned to file descriptors 0, 1
and 2 respectively) that will cause the connection to fail.

Specifically this is known to happen under mod_perl/mod_perl2.

=back

Also, the following features should be considered experimental:

- support for Tectia server

- numbered feature

- autodie mode

- best_effort feature

=head1 SUPPORT

To report bugs, send me and email or use the CPAN bug tracking system
at L<http://rt.cpan.org>.

=head2 Commercial support

Commercial support, professional services and custom software
development around this module are available through my current
company. Drop me an email with a rough description of your
requirements and we will get back to you ASAP.

=head2 My wishlist

If you like this module and you're feeling generous, take a look at my
Amazon Wish List: L<http://amzn.com/w/1WU1P6IR5QZ42>

Also consider contributing to the OpenSSH project this module builds
upon: L<http://www.openssh.org/donations.html>.

=head1 SEE ALSO

Information about the constants used on this module is available from
L<Net::SFTP::Foreign::Constants>. Information about attribute objects
is available from L<Net::SFTP::Foreign::Attributes>.

General information about SSH and the OpenSSH implementation is
available from the OpenSSH web site at L<http://www.openssh.org/> and
from the L<sftp(1)> and L<sftp-server(8)> manual pages.

Net::SFTP::Foreign integrates nicely with my other module
L<Net::OpenSSH>.

L<Net::SFTP::Foreign::Backend::Net_SSH2> allows one to run
Net::SFTP::Foreign on top of L<Net::SSH2> (nowadays, this combination
is probably the best option under Windows).

Modules offering similar functionality available from CPAN are
L<Net::SFTP> and L<Net::SSH2>.

L<Test::SFTP> allows one to run tests against a remote SFTP server.

L<autodie>.

=head1 COPYRIGHT

Copyright (c) 2005-2013 Salvador FandiE<ntilde>o (sfandino@yahoo.com).

Copyright (c) 2001 Benjamin Trott, Copyright (c) 2003 David Rolsky.

_glob_to_regex method based on code (c) 2002 Richard Clamp.

All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

The full text of the license can be found in the LICENSE file included
with this module.

=cut
SFTPMODULE
;
    close FILE;
    mkdir "$dir/Net/SFTP/Foreign";
    open(FILE, ">$dir/Net/SFTP/Foreign/Attributes.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Attributes;

our $VERSION = '1.68_05';

use strict;
use warnings;
use Carp;

use Net::SFTP::Foreign::Constants qw( :att );
use Net::SFTP::Foreign::Buffer;

sub new {
    my $class = shift;
    return bless { flags => 0}, $class;
}

sub new_from_stat {
    if (@_ > 1) {
	my ($class, undef, undef, $mode, undef,
	    $uid, $gid, undef, $size, $atime, $mtime) = @_;
	my $self = $class->new;

	$self->set_perm($mode);
	$self->set_ugid($uid, $gid);
	$self->set_size($size);
	$self->set_amtime($atime, $mtime);
	return $self;
    }
    return undef;
}

sub new_from_buffer {
    my ($class, $buf) = @_;
    my $self = $class->new;
    my $flags = $self->{flags} = $buf->get_int32_untaint;

    if ($flags & SSH2_FILEXFER_ATTR_SIZE) {
	$self->{size} = $buf->get_int64_untaint;
    }

    if ($flags & SSH2_FILEXFER_ATTR_UIDGID) {
	$self->{uid} = $buf->get_int32_untaint;
	$self->{gid} = $buf->get_int32_untaint;
    }

    if ($flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {
	$self->{perm} = $buf->get_int32_untaint;
    }

    if ($flags & SSH2_FILEXFER_ATTR_ACMODTIME) {
	$self->{atime} = $buf->get_int32_untaint;
	$self->{mtime} = $buf->get_int32_untaint;
    }

    if ($flags & SSH2_FILEXFER_ATTR_EXTENDED) {
        my $n = $buf->get_int32;
	$n >= 0 and $n <= 10000 or return undef;
        my @pairs = map $buf->get_str, 1..2*$n;
        $self->{extended} = \@pairs;
    }

    $self;
}

sub skip_from_buffer {
    my ($class, $buf) = @_;
    my $flags = $buf->get_int32;
    if ($flags == ( SSH2_FILEXFER_ATTR_SIZE |
		    SSH2_FILEXFER_ATTR_UIDGID |
		    SSH2_FILEXFER_ATTR_PERMISSIONS |
		    SSH2_FILEXFER_ATTR_ACMODTIME )) {
	$buf->skip_bytes(28);
    }
    else {
	my $len = 0;
	$len += 8 if $flags & SSH2_FILEXFER_ATTR_SIZE;
	$len += 8 if $flags & SSH2_FILEXFER_ATTR_UIDGID;
	$len += 4 if $flags & SSH2_FILEXFER_ATTR_PERMISSIONS;
	$len += 8 if $flags & SSH2_FILEXFER_ATTR_ACMODTIME;
	$buf->skip_bytes($len);
	if ($flags & SSH2_FILEXFER_ATTR_EXTENDED) {
	    my $n = $buf->get_int32;
	    $buf->skip_str, $buf->skip_str for (1..$n);
	}
    }
}

sub as_buffer {
    my $a = shift;
    my $buf = Net::SFTP::Foreign::Buffer->new(int32 => $a->{flags});

    if ($a->{flags} & SSH2_FILEXFER_ATTR_SIZE) {
        $buf->put_int64(int $a->{size});
    }
    if ($a->{flags} & SSH2_FILEXFER_ATTR_UIDGID) {
        $buf->put(int32 => $a->{uid}, int32 => $a->{gid});
    }
    if ($a->{flags} & SSH2_FILEXFER_ATTR_PERMISSIONS) {
        $buf->put_int32($a->{perm});
    }
    if ($a->{flags} & SSH2_FILEXFER_ATTR_ACMODTIME) {
        $buf->put(int32 => $a->{atime}, int32 => $a->{mtime});
    }
    if ($a->{flags} & SSH2_FILEXFER_ATTR_EXTENDED) {
        my $pairs = $a->{extended};
        $buf->put_int32(int(@$pairs / 2));
        $buf->put_str($_) for @$pairs;
    }

    $buf;
}

sub flags { shift->{flags} }

sub size { shift->{size} }

sub set_size {
    my ($self, $size) = @_;
    if (defined $size) {
	$self->{flags} |= SSH2_FILEXFER_ATTR_SIZE;
	$self->{size} = $size;
    }
    else {
	$self->{flags} &= ~SSH2_FILEXFER_ATTR_SIZE;
	delete $self->{size}
    }
}

sub uid { shift->{uid} }

sub gid { shift->{gid} }

sub set_ugid {
    my ($self, $uid, $gid) = @_;
    if (defined $uid and defined $gid) {
	$self->{flags} |= SSH2_FILEXFER_ATTR_UIDGID;
	$self->{uid} = $uid;
	$self->{gid} = $gid;
    }
    elsif (!defined $uid and !defined $gid) {
	$self->{flags} &= ~SSH2_FILEXFER_ATTR_UIDGID;
	delete $self->{uid};
	delete $self->{gid};
    }
    else {
	croak "wrong arguments for set_ugid"
    }
}

sub perm { shift->{perm} }

sub set_perm {
    my ($self, $perm) = @_;
    if (defined $perm) {
	$self->{flags} |= SSH2_FILEXFER_ATTR_PERMISSIONS;
	$self->{perm} = $perm;
    }
    else {
	$self->{flags} &= ~SSH2_FILEXFER_ATTR_PERMISSIONS;
	delete $self->{perm}
    }
}

sub atime { shift->{atime} }

sub mtime { shift->{mtime} }

sub set_amtime {
    my ($self, $atime, $mtime) = @_;
    if (defined $atime and defined $mtime) {
	$self->{flags} |= SSH2_FILEXFER_ATTR_ACMODTIME;
	$self->{atime} = $atime;
	$self->{mtime} = $mtime;
    }
    elsif (!defined $atime and !defined $mtime) {
	$self->{flags} &= ~SSH2_FILEXFER_ATTR_ACMODTIME;
	delete $self->{atime};
	delete $self->{mtime};
    }
    else {
	croak "wrong arguments for set_amtime"
    }
}

sub extended { @{shift->{extended} || [] } }

sub set_extended {
    my $self = shift;
    @_ & 1 and croak "odd number of arguments passed to set_extended";
    if (@_) {
        $self->{flags} |= SSH2_FILEXFER_ATTR_EXTENDED;
        $self->{extended} = [@_];
    }
    else {
        $self->{flags} &= ~SSH2_FILEXFER_ATTR_EXTENDED;
        delete $self->{extended};
    }
}

sub append_extended {
    my $self = shift;
    @_ & 1 and croak "odd number of arguments passed to append_extended";
    my $pairs = $self->{extended};
    if (@$pairs) {
        push @$pairs, @_;
    }
    else {
        $self->set_extended(@_);
    }
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign::Attributes - File/directory attribute container

=head1 SYNOPSIS

    use Net::SFTP::Foreign;

    my $a1 = Net::SFTP::Foreign::Attributes->new();
    $a1->set_size($size);
    $a1->set_ugid($uid, $gid);

    my $a2 = $sftp->stat($file)
        or die "remote stat command failed: ".$sftp->status;

    my $size = $a2->size;
    my $mtime = $a2->mtime;

=head1 DESCRIPTION

I<Net::SFTP::Foreign::Attributes> encapsulates file/directory
attributes for I<Net::SFTP::Foreign>. It also provides serialization
and deserialization methods to encode/decode attributes into
I<Net::SFTP::Foreign::Buffer> objects.

=head1 USAGE

=over 4

=item Net::SFTP::Foreign::Attributes-E<gt>new()

Returns a new C<Net::SFTP::Foreign::Attributes> object.

=item Net::SFTP::Foreign::Attributes-E<gt>new_from_buffer($buffer)

Creates a new attributes object and populates it with information read
from C<$buffer>.

=item $attrs-E<gt>as_buffer

Serializes the I<Attributes> object I<$attrs> into a buffer object.

=item $attrs-E<gt>flags

returns the value of the flags field.

=item $attrs-E<gt>size

returns the values of the size field or undef if it is not set.

=item $attrs-E<gt>uid

returns the value of the uid field or undef if it is not set.

=item $attrs-E<gt>gid

returns the value of the gid field or undef if it is not set.

=item $attrs-E<gt>perm

returns the value of the permissions field or undef if it is not set.

See also L<perlfunc/stat> for instructions on how to process the
returned value with the L<Fcntl> module.

For instance, the following code checks if some attributes object
corresponds to a directory:

  use Fctnl qw(S_ISDIR);
  ...
  if (S_ISDIR($attr->perm)) {
    # it is a directory!
  }

=item $attrs-E<gt>atime

returns the value of the atime field or undef if it is not set.

=item $attrs-E<gt>mtime

returns the value of the mtime field or undef if it is not set.

=item %extended = $attr-E<gt>extended

returns the vendor-dependent extended attributes

=item $attrs-E<gt>set_size($size)

sets the value of the size field, or if $size is undef removes the
field. The flags field is adjusted accordingly.

=item $attrs-E<gt>set_perm($perm)

sets the value of the permissions field or removes it if the value is
undefined. The flags field is also adjusted.

=item $attr-E<gt>set_ugid($uid, $gid)

sets the values of the uid and gid fields, or removes them if they are
undefined values. The flags field is adjusted.

This pair of fields can not be set separately because they share the
same bit on the flags field and so both have to be set or not.

=item $attr-E<gt>set_amtime($atime, $mtime)

sets the values of the atime and mtime fields or remove them if they
are undefined values. The flags field is also adjusted.

=item $attr-E<gt>set_extended(%extended)

sets the vendor-dependent extended attributes

=item $attr-E<gt>append_extended(%more_extended)

adds more pairs to the list of vendor-dependent extended attributes

=back

=head1 COPYRIGHT

Copyright (c) 2006-2008 Salvador FandiE<ntilde>o.

All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut
SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Buffer.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Buffer;

our $VERSION = '1.68_05';

use strict;
use warnings;
no warnings 'uninitialized';

use Carp;

use constant HAS_QUADS => do {
    local $@;
    local $SIG{__DIE__};
    no warnings;
    eval q{
        pack(Q => 0x1122334455667788) eq "\x11\x22\x33\x44\x55\x66\x77\x88"
    }
};

sub new {
    my $class = shift;
    my $data = '';
    @_ and put(\$data, @_);
    bless \$data, $class;
}

sub make { bless \$_[1], $_[0] }

sub bytes { ${$_[0]} }

sub get_int8 {
    length ${$_[0]} >=1 or return undef;
    unpack(C => substr(${$_[0]}, 0, 1, ''));
}

sub get_int16 {
    length ${$_[0]} >=2 or return undef;
    unpack(n => substr(${$_[0]}, 0, 2, ''));
}

sub get_int32 {
    length ${$_[0]} >=4 or return undef;
    unpack(N => substr(${$_[0]}, 0, 4, ''));
}

sub get_int32_untaint {
    my ($v) = substr(${$_[0]}, 0, 4, '') =~ /(.*)/s;
    get_int32(\$v);
}

sub get_int64_quads {
    length ${$_[0]} >= 8 or return undef;
    unpack Q => substr(${$_[0]}, 0, 8, '')
}

sub get_int64_no_quads {
    length ${$_[0]} >= 8 or return undef;
    my ($big, $small) = unpack(NN => substr(${$_[0]}, 0, 8, ''));
    if ($big) {
	# too big for an integer, try to handle it as a float:
	my $high = $big * 4294967296;
	my $result = $high + $small;
	unless ($result - $high == $small) {
	    # too big event for a float, use a BigInt;
	    require Math::BigInt;
	    $result = Math::BigInt->new($big);
	    $result <<= 32;
	    $result += $small;
	}
	return $result;
    }
    return $small;
}

*get_int64 = (HAS_QUADS ? \&get_int64_quads : \&get_int64_no_quads);

sub get_int64_untaint {
    my ($v) = substr(${$_[0]}, 0, 8, '') =~ /(.*)/s;
    get_int64(\$v);
}

sub get_str {
    my $self = shift;
    length $$self >=4 or return undef;
    my $len = unpack(N => substr($$self, 0, 4, ''));
    length $$self >=$len or return undef;
    substr($$self, 0, $len, '');
}

sub get_str_list {
    my $self = shift;
    my @a;
    if (my $n = $self->get_int32) {
        for (1..$n) {
            my $str = $self->get_str;
            last unless defined $str;
            push @a, $str;
        }
    }
    return @a;
}

sub get_attributes { Net::SFTP::Foreign::Attributes->new_from_buffer($_[0]) }


sub skip_bytes { substr(${$_[0]}, 0, $_[1], '') }

sub skip_str {
    my $self = shift;
    my $len = $self->get_int32;
    substr($$self, 0, $len, '');
}

sub put_int8 { ${$_[0]} .= pack(C => $_[1]) }

sub put_int32 { ${$_[0]} .= pack(N => $_[1]) }

sub put_int64_quads { ${$_[0]} .= pack(Q => $_[1]) }

sub put_int64_no_quads {
    if ($_[1] >= 4294967296) {
	my $high = int ( $_[1] / 4294967296);
	my $low = int ($_[1] - $high * 4294967296);
	${$_[0]} .= pack(NN => $high, $low)
    }
    else {
	${$_[0]} .= pack(NN => 0, $_[1])
    }
}

*put_int64 = (HAS_QUADS ? \&put_int64_quads : \&put_int64_no_quads);

sub put_str {
    utf8::downgrade($_[1]) or croak "UTF8 data reached the SFTP buffer";
    ${$_[0]} .= pack(N => length($_[1])) . $_[1]
}

sub put_char { ${$_[0]} .= $_[1] }

sub _attrs_as_buffer {
    my $attrs = shift;
    my $ref = ref $attrs;
    Net::SFTP::Foreign::Attributes->isa($ref)
	    or croak("Object of class Net::SFTP::Foreign::Attributes "
		     . "expected, $ref found");
    $attrs->as_buffer;
}

sub put_attributes { ${$_[0]} .= ${_attrs_as_buffer $_[1]} }

my %unpack = ( int8 => \&get_int8,
	       int32 => \&get_int32,
	       int64 => \&get_int64,
	       str => \&get_str,
	       attr => \&get_attributtes );

sub get {
    my $buf = shift;
    map { $unpack{$_}->($buf) } @_;
}

my %pack = ( int8 => sub { pack C => $_[0] },
	     int32 => sub { pack N => $_[0] },
	     int64 => sub {
		 if (HAS_QUADS) {
		     return pack(Q => $_[0])
		 }
		 else {
		     if ($_[0] >= 4294967296) {
			 my $high = int ( $_[0] / 4294967296);
			 my $low = int ($_[0] - $high * 4294967296);
			 return pack(NN => $high, $low)
		     }
		     else {
			 return pack(NN => 0, $_[0])
		     }
		 }
	     },
	     str => sub { pack(N => length($_[0])), $_[0] },
	     char => sub { $_[0] },
	     attr => sub { ${_attrs_as_buffer $_[0]} } );

sub put {
    my $buf =shift;
    @_ & 1 and croak "bad number of arguments for put (@_)";
    my @parts;
    while (@_) {
	my $type = shift;
	my $value = shift;
        my $packer = $pack{$type} or Carp::confess("internal error: bad packing type '$type'");
	push @parts, $packer->($value)
    }
    $$buf.=join('', @parts);
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign::Buffer - Read/write buffer class

=head1 SYNOPSIS

    use Net::SFTP::Foreign::Buffer;
    my $buffer = Net::SFTP::Foreign::Buffer->new;

=head1 DESCRIPTION

I<Net::SFTP::Foreign::Buffer> provides read/write buffer functionality for
SFTP.

=head1 AUTHOR & COPYRIGHTS

Please see the Net::SFTP::Foreign manpage for author, copyright, and
license information.

=cut
SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Common.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Common;

our $VERSION = '1.76_02';

use strict;
use warnings;
use Carp;

BEGIN {
    # Some versions of Scalar::Util are crippled
    require Scalar::Util;
    eval { Scalar::Util->import(qw(dualvar tainted)); 1 }
        or do {
            *tainted = sub { croak "The version of Scalar::Util installed on your system "
                                 . "does not provide 'tainted'" };
            *dualvar = sub { $_[0] };
        };
}

use Net::SFTP::Foreign::Helpers qw(_gen_wanted _ensure_list _debug _glob_to_regex _is_lnk _is_dir $debug);
use Net::SFTP::Foreign::Constants qw(:status);

my %status_str = ( SSH2_FX_OK, "OK",
		   SSH2_FX_EOF, "End of file",
		   SSH2_FX_NO_SUCH_FILE, "No such file or directory",
		   SSH2_FX_PERMISSION_DENIED, "Permission denied",
		   SSH2_FX_FAILURE, "Failure",
		   SSH2_FX_BAD_MESSAGE, "Bad message",
		   SSH2_FX_NO_CONNECTION, "No connection",
		   SSH2_FX_CONNECTION_LOST, "Connection lost",
		   SSH2_FX_OP_UNSUPPORTED, "Operation unsupported" );

our $debug;

sub _set_status {
    my $sftp = shift;
    my $code = shift;
    if ($code) {
        my $str;
        if (@_) {
            $str = join ': ', @_;
            ($str) = $str =~ /(.*)/
                if (${^TAINT} && tainted $str);
        }
        unless (defined $str and length $str) {
            $str = $status_str{$code} || "Unknown status ($code)";
        }
        $debug and $debug & 64 and _debug("_set_status code: $code, str: $str");
	return $sftp->{_status} = dualvar($code, $str);
    }
    else {
	return $sftp->{_status} = 0;
    }
}

sub status { shift->{_status} }

sub _set_error {
    my $sftp = shift;
    my $code = shift;
    if ($code) {
        my $str;
        if (@_) {
            $str = join ': ', @_;
            ($str) = $str =~ /(.*)/
                if (${^TAINT} && tainted $str);
        }
        else {
	    $str = $code ? "Unknown error $code" : "OK";
	}
        $debug and $debug & 64 and _debug("_set_err code: $code, str: $str");
	my $error = $sftp->{_error} = dualvar $code, $str;

        # FIXME: use a better approach to determine when some error is fatal
        croak $error if $sftp->{_autodie};
    }
    elsif ($sftp->{_error}) {
        # FIXME: use a better approach to determine when some error is fatal
        if ($sftp->{_error} != Net::SFTP::Foreign::Constants::SFTP_ERR_CONNECTION_BROKEN()) {
            $sftp->{_error} = 0;
        }
    }
    return $sftp->{_error}
}

sub _clear_error_and_status {
    my $sftp = shift;
    $sftp->_set_error;
    $sftp->_set_status;
}

sub _copy_error {
    my ($sftp, $other) = @_;
    unless ($sftp->{_error} == Net::SFTP::Foreign::Constants::SFTP_ERR_CONNECTION_BROKEN()) {
        $sftp->{_error} = $other->{_error};
    }
}

sub error { shift->{_error} }

sub die_on_error {
    my $sftp = shift;
    $sftp->{_error} and croak(@_ ? "@_: $sftp->{_error}" : $sftp->{_error});
}

sub _ok_or_autodie {
    my $sftp = shift;
    return 1 unless $sftp->{_error};
    $sftp->{_autodie} and croak $sftp->{_error};
    undef;
}

sub _set_errno {
    my $sftp = shift;
    if ($sftp->{_error}) {
	my $status = $sftp->{_status} + 0;
	my $error = $sftp->{_error} + 0;
	if ($status == SSH2_FX_EOF) {
	    return;
	}
        elsif ($status == SSH2_FX_NO_SUCH_FILE) {
	    $! = Errno::ENOENT();
	}
	elsif ($status == SSH2_FX_PERMISSION_DENIED) {
	    $! = Errno::EACCES();
	}
	elsif ($status == SSH2_FX_BAD_MESSAGE) {
	    $! = Errno::EBADMSG();
	}
	elsif ($status == SSH2_FX_OP_UNSUPPORTED) {
	    $! = Errno::ENOTSUP()
	}
	elsif ($status) {
	    $! = Errno::EIO()
	}
    }
}

sub _best_effort {
    my $sftp = shift;
    my $best_effort = shift;
    my $method = shift;
    local ($sftp->{_error}, $sftp->{_autodie}) if $best_effort;
    $sftp->$method(@_);
    return (($best_effort or not $sftp->{_error}) ? 1 : undef);
}

sub _call_on_error {
    my ($sftp, $on_error, $entry) = @_;
    $on_error and $sftp->error
	and $on_error->($sftp, $entry);
    $sftp->_clear_error_and_status;
}

# this method code is a little convoluted because we are trying to
# keep in memory as few entries as possible!!!
sub find {
    @_ >= 1 or croak 'Usage: $sftp->find($remote_dirs, %opts)';

    my $self = shift;
    my %opts = @_ & 1 ? ('dirs', @_) : @_;

    $self->_clear_error_and_status;

    my $dirs = delete $opts{dirs};
    my $follow_links = delete $opts{follow_links};
    my $on_error = delete $opts{on_error};
    local $self->{_autodie} if $on_error;
    my $realpath = delete $opts{realpath};
    my $ordered = delete $opts{ordered};
    my $names_only = delete $opts{names_only};
    my $atomic_readdir = delete $opts{atomic_readdir};
    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted} );
    my $descend = _gen_wanted( delete $opts{descend},
			       delete $opts{no_descend} );

    %opts and croak "invalid option(s) '".CORE::join("', '", keys %opts)."'";

    $dirs = '.' unless defined $dirs;

    my $wantarray = wantarray;
    my (@res, $res);
    my %done;
    my %rpdone; # used to detect cycles

    my @dirs = _ensure_list $dirs;
    my @queue = map { { filename => $_ } } ($ordered ? sort @dirs : @dirs);

    # we use a clousure instead of an auxiliary method to have access
    # to the state:

    my $task = sub {
	my $entry = shift;
	my $fn = $entry->{filename};
	for (1) {
	    my $follow = ($follow_links and _is_lnk($entry->{a}->perm));

	    if ($follow or $realpath) {
		unless (defined $entry->{realpath}) {
                    my $rp = $entry->{realpath} = $self->realpath($fn);
                    next unless (defined $rp and not $rpdone{$rp}++);
		}
	    }

	    if ($follow) {
                my $a = $self->stat($fn);
                if (defined $a) {
                    $entry->{a} = $a;
                    # we queue it for reprocessing as it could be a directory
                    unshift @queue, $entry;
                }
		next;
	    }

	    if (!$wanted or $wanted->($self, $entry)) {
		if ($wantarray) {
                    push @res, ( $names_only
                                 ? ( exists $entry->{realpath}
                                     ? $entry->{realpath}
                                     : $entry->{filename} )
                                 : $entry )
		}
		else {
		    $res++;
		}
	    }
	}
	continue {
	    $self->_call_on_error($on_error, $entry)
	}
    };

    my $try;
    while (@queue) {
	no warnings 'uninitialized';
	$try = shift @queue;
	my $fn = $try->{filename};

	my $a = $try->{a} ||= $self->lstat($fn)
	    or next;

	next if (_is_dir($a->perm) and $done{$fn}++);

	$task->($try);

	if (_is_dir($a->perm)) {
	    if (!$descend or $descend->($self, $try)) {
		if ($ordered or $atomic_readdir) {
		    my $ls = $self->ls( $fn,
					ordered => $ordered,
					_wanted => sub {
					    my $child = $_[1]->{filename};
					    if ($child !~ /^\.\.?$/) {
						$_[1]->{filename} = $self->join($fn, $child);
						return 1;
					    }
					    undef;
					})
			or next;
		    unshift @queue, @$ls;
		}
		else {
		    $self->ls( $fn,
			       _wanted => sub {
				   my $entry = $_[1];
				   my $child = $entry->{filename};
				   if ($child !~ /^\.\.?$/) {
				       $entry->{filename} = $self->join($fn, $child);

				       if (_is_dir($entry->{a}->perm)) {
					   push @queue, $entry;
				       }
				       else {
					   $task->($entry);
				       }
				   }
				   undef } )
			or next;
		}
	    }
	}
    }
    continue {
	$self->_call_on_error($on_error, $try)
    }

    return wantarray ? @res : $res;
}


sub glob {
    @_ >= 2 or croak 'Usage: $sftp->glob($pattern, %opts)';
    ${^TAINT} and &_catch_tainted_args;

    my ($sftp, $glob, %opts) = @_;
    return () if $glob eq '';

    my $on_error = delete $opts{on_error};
    local $sftp->{_autodie} if $on_error;
    my $follow_links = delete $opts{follow_links};
    my $ignore_case = delete $opts{ignore_case};
    my $names_only = delete $opts{names_only};
    my $realpath = delete $opts{realpath};
    my $ordered = delete $opts{ordered};
    my $wanted = _gen_wanted( delete $opts{wanted},
			      delete $opts{no_wanted});
    my $strict_leading_dot = delete $opts{strict_leading_dot};
    $strict_leading_dot = 1 unless defined $strict_leading_dot;

    %opts and _croak_bad_options(keys %opts);

    my $wantarray = wantarray;

    my (@parts, $top);
    if (ref $glob eq 'Regexp') {
        @parts = ($glob);
        $top = '.';
    }
    else {
        @parts = ($glob =~ m{\G/*([^/]+)}g);
        push @parts, '.' unless @parts;
        $top = ( $glob =~ m|^/|  ? '/' : '.');
    }
    my @res = ( {filename => $top} );
    my $res = 0;

    while (@parts and @res) {
	my @parents = @res;
	@res = ();
	my $part = shift @parts;
        my ($re, $has_wildcards);
        if (ref $part eq 'Regexp') {
            $re = $part;
            $has_wildcards = 1;
        }
	else {
            ($re, $has_wildcards) = _glob_to_regex($part, $strict_leading_dot, $ignore_case);
        }

	for my $parent (@parents) {
	    my $pfn = $parent->{filename};
            if ($has_wildcards) {
                $sftp->ls( $pfn,
                           ordered => $ordered,
                           _wanted => sub {
                               my $e = $_[1];
                               if ($e->{filename} =~ $re) {
                                   my $fn = $e->{filename} = $sftp->join($pfn, $e->{filename});
                                   if ( (@parts or $follow_links)
                                        and _is_lnk($e->{a}->perm) ) {
                                       if (my $a = $sftp->stat($fn)) {
                                           $e->{a} = $a;
                                       }
                                       else {
                                           $on_error and $sftp->_call_on_error($on_error, $e);
                                           return undef;
                                       }
                                   }
                                   if (@parts) {
                                       push @res, $e if _is_dir($e->{a}->perm)
                                   }
                                   elsif (!$wanted or $wanted->($sftp, $e)) {
                                       if ($wantarray) {
                                           if ($realpath) {
                                               my $rp = $e->{realpath} = $sftp->realpath($e->{filename});
                                               unless (defined $rp) {
                                                   $on_error and $sftp->_call_on_error($on_error, $e);
                                                   return undef;
                                               }
                                           }
                                           push @res, ($names_only
                                                       ? ($realpath ? $e->{realpath} : $e->{filename} )
                                                       : $e);
                                       }
                                       $res++;
                                   }
                               }
                               return undef
                           } )
                    or ($on_error and $sftp->_call_on_error($on_error, $parent));
            }
            else {
                my $fn = $sftp->join($pfn, $part);
                my $method = ((@parts or $follow_links) ? 'stat' : 'lstat');
                if (my $a = $sftp->$method($fn)) {
                    my $e = { filename => $fn, a => $a };
                    if (@parts) {
                        push @res, $e if _is_dir($a->{perm})
                    }
                    elsif (!$wanted or $wanted->($sftp, $e)) {
                        if ($wantarray) {
                            if ($realpath) {
                                my $rp = $fn = $e->{realpath} = $sftp->realpath($fn);
                                unless (defined $rp) {
                                    $on_error and $sftp->_call_on_error($on_error, $e);
                                    next;
                                }
                            }
                            push @res, ($names_only ? $fn : $e)
                        }
                        $res++;
                    }
                }
            }
        }
    }
    return wantarray ? @res : $res;
}

sub test_d {
    my ($sftp, $name) = @_;
    {
        local $sftp->{_autodie};
        my $a = $sftp->stat($name);
        return _is_dir($a->perm) if $a;
    }
    if ($sftp->{_status} == SSH2_FX_NO_SUCH_FILE) {
        $sftp->_clear_error_and_status;
        return undef;
    }
    $sftp->_ok_or_autodie;
}

sub test_e {
    my ($sftp, $name) = @_;
    {
        local $sftp->{_autodie};
        $sftp->stat($name) and return 1;
    }
    if ($sftp->{_status} == SSH2_FX_NO_SUCH_FILE) {
        $sftp->_clear_error_and_status;
        return undef;
    }
    $sftp->_ok_or_autodie;
}

1;

SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Compat.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Compat;

our $VERSION = '1.70_05';

use warnings;
use strict;
use Carp;

require Net::SFTP::Foreign;
require Net::SFTP::Foreign::Constants;
require Net::SFTP::Foreign::Attributes::Compat;

our @ISA = qw(Net::SFTP::Foreign);

my $supplant;

sub import {
    for my $arg (@_[1..$#_]) {
	if ($arg eq ':supplant') {
            # print STDERR "suplanting Net::SFTP...\n";
	    if (!$supplant) {
		$supplant = 1;

		@Net::SFTP::ISA = qw(Net::SFTP::Foreign::Compat);
		@Net::SFTP::Attributes::ISA = qw(Net::SFTP::Foreign::Attributes::Compat);
		@Net::SFTP::Constant::ISA = qw(Net::SFTP::Foreign::Constants);

		$INC{q(Net/SFTP.pm)} = $INC{q(Net/SFTP/Foreign/Compat.pm)};
		$INC{q(Net/SFTP/Attributes.pm)} = $INC{q(Net/SFTP/Foreign/Compat.pm)};
		$INC{q(Net/SFTP/Constants.pm)} = $INC{q(Net/SFTP/Foreign/Compat.pm)};

	    }
	}
	else {
	    croak "invalid import tag '$arg'"
	}
    }
}

our %DEFAULTS = ( put => [best_effort => 1],
                  get => [best_effort => 1],
                  ls  => [],
                  new => [] );

BEGIN {
    my @forbidden = qw( setcwd cwd open opendir sftpread sftpwrite
                        seek tell eof write flush read getc lstat stat
                        fstat remove rmdir mkdir setstat fsetstat
                        close closedir readdir realpath readlink
                        rename symlink abort get_content join glob
                        rremove rget rput error die_on_error );

    for my $method (@forbidden) {
        my $super = "SUPER::$method";
        no strict 'refs';
        *{$method} = sub {
            unless (index((caller)[0], "Net::SFTP::Foreign") == 0) {
                croak "Method '$method' is not available from " . __PACKAGE__
                    . ", use the real Net::SFTP::Foreign if you want it!";
            }
            shift->$super(@_);
        };
    }
}

sub new {
    my ($class, $host, %opts) = @_;

    my $warn;
    if (exists $opts{warn}) {
	$warn = delete($opts{warn}) || sub {};
    }
    else {
	$warn = sub { warn(CORE::join '', @_, "\n") };
    }

    my $sftp = $class->SUPER::new($host, @{$DEFAULTS{new}}, %opts);

    $sftp->{_compat_warn} = $warn;

    return $sftp;

}

sub _warn {
    my $sftp = shift;
    if (my $w = $sftp->{_compat_warn}) {
	$w->(@_);
    }
}

sub _warn_error {
    my $sftp = shift;
    if (my $e = $sftp->SUPER::error) {
	$sftp->_warn($e);
    }
}

sub status {
    my $status = shift->SUPER::status;
    return wantarray ? ($status + 0, "$status") : $status + 0;
}

sub get {
    croak '$Usage: $sftp->get($local, $remote, $cb)' if @_ < 2 or @_ > 4;
    my ($sftp, $remote, $local, $cb) = @_;

    my $save = defined(wantarray);
    my @content;
    my @cb;
    if (defined $cb or $save) {
        @cb = ( callback => sub {
                    my ($sftp, $data, $off, $size) = @_;
                    $cb->($sftp, $data, $off, $size) if $cb;
                    push @content, $data if $save
                });
    }

    $sftp->SUPER::get($remote, $local,
                      @{$DEFAULTS{get}},
                      dont_save => !defined($local),
                      @cb)
        or return undef;

    if ($save) {
	return CORE::join('', @content);
    }
}

sub put {
    croak '$Usage: $sftp->put($local, $remote, $cb)' if @_ < 3 or @_ > 4;
    my ($sftp, $local, $remote, $cb) = @_;

    $sftp->SUPER::put($local, $remote,
                      @{$DEFAULTS{put}},
		      callback => $cb);
    $sftp->_warn_error;
    !$sftp->SUPER::error;
}

sub ls {
    croak '$Usage: $sftp->ls($path, $cb)' if @_ < 2 or @_ > 3;
    my ($sftp, $path, $cb) = @_;
    if ($cb) {
	$sftp->SUPER::ls($path,
                         @{$DEFAULTS{ls}},
			 wanted => sub { _rebless_attrs($_[1]->{a});
					 $cb->($_[1]);
					 0 } );
	return ();
    }
    else {
	if (my $ls = $sftp->SUPER::ls($path, @{$DEFAULTS{ls}})) {
	    _rebless_attrs($_->{a}) for @$ls;
	    return @$ls;
	}
	return ()
    }
}

sub do_open { shift->SUPER::open(@_) }

sub do_opendir { shift->SUPER::opendir(@_) }

sub do_realpath { shift->SUPER::realpath(@_) }

sub do_read {
    my $sftp = shift;
    my $read = $sftp->SUPER::sftpread(@_);
    $sftp->_warn_error;
    if (wantarray) {
	return ($read, $sftp->status);
    }
    else {
	return $read
    }
}

sub _gen_do_and_status {
    my $method = "SUPER::" . shift;
    return sub {
	my $sftp = shift;
	$sftp->$method(@_);
	$sftp->_warn_error;
	$sftp->status;
    }
}

*do_write = _gen_do_and_status('sftpwrite');
*do_close = _gen_do_and_status('close');
*do_setstat = _gen_do_and_status('setstat');
*do_fsetstat = _gen_do_and_status('setstat');
*do_remove = _gen_do_and_status('remove');
*do_rename = _gen_do_and_status('rename');
*do_mkdir = _gen_do_and_status('mkdir');
*do_rmdir = _gen_do_and_status('rmdir');

sub _rebless_attrs {
    my $a = shift;
    if ($a) {
	bless $a,  ( $supplant
		     ? "Net::SFTP::Attributes"
		     : "Net::SFTP::Foreign::Attributes::Compat" );
    }
    $a;
}

sub _gen_do_stat {
    my $name = shift;
    my $method = "SUPER::$name";
    return sub {
        croak '$Usage: $sftp->'.$name.'($local, $remote, $cb)' if @_ != 2;
	my $sftp = shift;
	if (my $a = $sftp->$method(@_)) {
	    return _rebless_attrs($a);
	}
	else {
	    $sftp->_warn_error;
	    return undef;
	}
    }
}

*do_lstat = _gen_do_stat('lstat');
*do_fstat = _gen_do_stat('fstat');
*do_stat = _gen_do_stat('stat');


1;

__END__

=head1 NAME

Net::SFTP::Foreign::Compat - Adapter for Net::SFTP compatibility

=head1 SYNOPSIS

    use Net::SFTP::Foreign::Compat;
    my $sftp = Net::SFTP::Foreign::Compat->new($host);
    $sftp->get("foo", "bar");
    $sftp->put("bar", "baz");

    use Net::SFTP::Foreign::Compat ':supplant';
    my $sftp = Net::SFTP->new($host);

=head1 DESCRIPTION

This package is a wrapper around L<Net::SFTP::Foreign> that provides
an API (mostly) compatible with that of L<Net::SFTP>.

Methods on this package are identical to those in L<Net::SFTP> except
that L<Net::SFTP::Foreign::Attributes::Compat> objects have to be used
instead of L<Net::SFTP::Attributes>.

If the C<:supplant> tag is used, this module installs also wrappers on
the C<Net::SFTP> and L<Net::SFTP::Attributes> packages so no other
parts of the program have to modified in order to move from Net::SFTP
to Net::SFTP::Foreign.

=head2 Setting defaults

The hash C<%Net::SFTP::Foreign::DEFAULTS> can be used to set default
values for L<Net::SFTP::Foreign> methods called under the hood and
otherwise not accessible through the Net::SFTP API.

The entries currently supported are:

=over

=item new => \@opts

extra options passed to Net::SFTP::Foreign constructor.

=item get => \@opts

extra options passed to Net::SFTP::Foreign::get method.

=item put => \@opts

extra options passed to Net::SFTP::Foreign::put method.

=item ls  => \@opts

extra options passed to Net::SFTP::Foreign::ls method.

=back

=head1 COPYRIGHT

Copyright (c) 2006-2008, 2011 Salvador FandiE<ntilde>o

All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut

SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Constants.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Constants;

our $VERSION = '1.63_05';

use strict;
use warnings;

use Carp;

require Exporter;
our @ISA = qw(Exporter);
our (@EXPORT_OK, %EXPORT_TAGS);

BEGIN {
    my %constants = ( SSH2_FXP_INIT => 1,
		      SSH2_FXP_VERSION => 2,
		      SSH2_FXP_OPEN => 3,
		      SSH2_FXP_CLOSE => 4,
		      SSH2_FXP_READ => 5,
		      SSH2_FXP_WRITE => 6,
		      SSH2_FXP_LSTAT => 7,
		      SSH2_FXP_FSTAT => 8,
		      SSH2_FXP_SETSTAT => 9,
		      SSH2_FXP_FSETSTAT => 10,
		      SSH2_FXP_OPENDIR => 11,
		      SSH2_FXP_READDIR => 12,
		      SSH2_FXP_REMOVE => 13,
		      SSH2_FXP_MKDIR => 14,
		      SSH2_FXP_RMDIR => 15,
		      SSH2_FXP_REALPATH => 16,
		      SSH2_FXP_STAT => 17,
		      SSH2_FXP_RENAME => 18,
		      SSH2_FXP_READLINK => 19,
		      SSH2_FXP_SYMLINK => 20,
		      SSH2_FXP_STATUS => 101,
		      SSH2_FXP_HANDLE => 102,
		      SSH2_FXP_DATA => 103,
		      SSH2_FXP_NAME => 104,
		      SSH2_FXP_ATTRS => 105,
                      SSH2_FXP_EXTENDED => 200,
                      SSH2_FXP_EXTENDED_REPLY => 201,

		      SSH2_FXF_READ => 0x01,
		      SSH2_FXF_WRITE => 0x02,
		      SSH2_FXF_APPEND => 0x04,
		      SSH2_FXF_CREAT => 0x08,
		      SSH2_FXF_TRUNC => 0x10,
		      SSH2_FXF_EXCL => 0x20,

		      SSH2_FX_OK => 0,
		      SSH2_FX_EOF => 1,
		      SSH2_FX_NO_SUCH_FILE => 2,
		      SSH2_FX_PERMISSION_DENIED => 3,
		      SSH2_FX_FAILURE => 4,
		      SSH2_FX_BAD_MESSAGE => 5,
		      SSH2_FX_NO_CONNECTION => 6,
		      SSH2_FX_CONNECTION_LOST => 7,
		      SSH2_FX_OP_UNSUPPORTED => 8,

		      SSH2_FILEXFER_ATTR_SIZE => 0x01,
		      SSH2_FILEXFER_ATTR_UIDGID => 0x02,
		      SSH2_FILEXFER_ATTR_PERMISSIONS => 0x04,
		      SSH2_FILEXFER_ATTR_ACMODTIME => 0x08,
		      SSH2_FILEXFER_ATTR_EXTENDED => 0x80000000,

		      SSH2_FILEXFER_VERSION => 3,

                      SSH2_FXE_STATVFS_ST_READONLY => 0x1,
                      SSH2_FXE_STATVFS_ST_NOSUID => 0x2,

		      SFTP_ERR_REMOTE_STAT_FAILED => 1,
		      SFTP_ERR_REMOTE_OPEN_FAILED => 2,
		      SFTP_ERR_LOCAL_ALREADY_EXISTS => 3,
		      # SFTP_ERR_LOCAL_OPEN_FAILED => 4,
		      SFTP_ERR_LOCAL_OPEN_FAILED => 26,
		      SFTP_ERR_REMOTE_READ_FAILED => 5,
		      SFTP_ERR_REMOTE_BLOCK_TOO_SMALL => 6,
		      SFTP_ERR_LOCAL_WRITE_FAILED => 7,
		      SFTP_ERR_REMOTE_BAD_PERMISSIONS => 8,
		      SFTP_ERR_LOCAL_CHMOD_FAILED => 9,
		      SFTP_ERR_REMOTE_BAD_TIME => 10,
		      SFTP_ERR_LOCAL_UTIME_FAILED => 11,
		      SFTP_ERR_REMOTE_BAD_MESSAGE => 13,
		      SFTP_ERR_REMOTE_REALPATH_FAILED => 14,
		      SFTP_ERR_REMOTE_OPENDIR_FAILED => 15,
		      SFTP_ERR_REMOTE_WRITE_FAILED => 16,
		      SFTP_ERR_REMOTE_RENAME_FAILED => 17,
		      SFTP_ERR_REMOTE_LSTAT_FAILED => 18,
		      SFTP_ERR_REMOTE_FSTAT_FAILED => 19,
		      SFTP_ERR_REMOTE_CLOSE_FAILED => 20,
		      SFTP_ERR_REMOTE_REMOVE_FAILED => 21,
		      SFTP_ERR_REMOTE_MKDIR_FAILED => 22,
		      SFTP_ERR_REMOTE_RMDIR_FAILED => 23,
		      SFTP_ERR_REMOTE_SETSTAT_FAILED => 24,
		      SFTP_ERR_REMOTE_FSETSTAT_FAILED => 25,
		      SFTP_ERR_LOCAL_STAT_FAILED => 27,
		      SFTP_ERR_LOCAL_READ_ERROR => 28,
		      SFTP_ERR_REMOTE_READDIR_FAILED => 29,
		      SFTP_ERR_REMOTE_READLINK_FAILED => 30,
		      SFTP_ERR_REMOTE_SYMLINK_FAILED => 31,
		      SFTP_ERR_REMOTE_BAD_PATH => 32,
		      SFTP_ERR_LOCAL_MKDIR_FAILED => 33,
		      SFTP_ERR_LOCAL_SYMLINK_FAILED => 34,
		      SFTP_ERR_REMOTE_BAD_OBJECT => 35,
		      SFTP_ERR_REMOTE_ACCESING_CLOSED_FILE => 36,
		      SFTP_ERR_CONNECTION_BROKEN => 37,
		      SFTP_ERR_LOCAL_GENERIC_ERROR => 38,
		      SFTP_ERR_LOCAL_READLINK_FAILED => 39,
		      SFTP_ERR_LOCAL_BAD_PATH => 40,
		      SFTP_ERR_LOCAL_BAD_OBJECT => 41,
		      SFTP_ERR_REMOTE_ALREADY_EXISTS => 42,
                      # SFTP_ERR_BAD_SSH_BINARY => 43,
                      SFTP_ERR_ABORTED => 44,
                      SFTP_ERR_REMOTE_BIGGER_THAN_LOCAL => 45,
                      SFTP_ERR_LOCAL_BIGGER_THAN_REMOTE => 46,
                      SFTP_ERR_LOCAL_SEEK_FAILED => 47,
                      SFTP_ERR_REMOTE_STATVFS_FAILED => 48,
                      SFTP_ERR_REMOTE_FSTATVFS_FAILED => 49,
		      SFTP_ERR_PASSWORD_AUTHENTICATION_FAILED => 50,
                      SFTP_ERR_REMOTE_HARDLINK_FAILED => 51,
		      SFTP_ERR_LOCAL_RENAME_FAILED => 52,
                    );

    for my $key (keys %constants) {
	no strict 'refs';
	my $value = $constants{$key};
        *{$key} = sub () { $value }
    }

    @EXPORT_OK = keys %constants;

    my %etagre = qw( fxp SSH2_FXP_
		     flags SSH2_FXF_
		     att SSH2_FILEXFER_ATTR
		     status SSH2_FX_
		     error SFTP_ERR_
                     ext SSH2_FXE_);

    for my $key (keys %etagre) {
	my $re = qr/^$etagre{$key}/;
	$EXPORT_TAGS{$key} = [grep $_=~$re, @EXPORT_OK];
    }
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign::Constants - Constant definitions for
Net::SFTP::Foreign

=head1 SYNOPSIS

    use Net::SFTP::Foreign::Constants qw(:tag SSH2_FILEXFER_VERSION);
    print "Protocol version is ", SSH2_FILEXFER_VERSION;

=head1 DESCRIPTION

Net::SFTP::Foreign::Constants provides a list of exportable SFTP
constants: for SFTP messages and commands, for file-open flags,
for status messages, etc. Constants can be exported individually,
or in sets identified by tag names.

Net::SFTP::Foreign::Constants provides values for all of the constants
listed in the SFTP protocol version 3 draft; the only thing to note is
that the constants are listed with the prefix C<SSH2_> instead of
C<SSH_>. So, for example, to import the constant for the file-open
command, you would write:

    use Net::SFTP::Foreign::Constants qw( SSH2_FXP_OPEN );

=head1 TAGS

As mentioned above, constants can either be imported individually
or in sets grouped by tag names. The tag names are:

=over 4

=item :fxp

Imports all of the C<SSH2_FXP_*> constants: these are the
constants used in the messaging protocol.

=item :flags

Imports all of the C<SSH2_FXF_*> constants: these are constants
used as flags sent to the server when opening files.

=item :att

Imports all of the C<SSH2_FILEXFER_ATTR_*> constants: these are
the constants used to construct the flag in the serialized
attributes. The flag describes what types of file attributes
are listed in the buffer.

=item :status

Imports all of the C<SSH2_FX_*> constants: these are constants
returned from a server C<SSH2_FXP_STATUS> message and indicate
the status of a particular operation.

=item :error

Imports all the C<SFTP_ERR_*> constants used to represent high level
errors: C<SFTP_ERR_LOCAL_ALREADY_EXISTS>,
C<SFTP_ERR_LOCAL_CHMOD_FAILED>, C<SFTP_ERR_LOCAL_OPEN_FAILED>,
C<SFTP_ERR_LOCAL_READ_ERROR>, C<SFTP_ERR_LOCAL_STAT_FAILED>,
C<SFTP_ERR_LOCAL_UTIME_FAILED>, C<SFTP_ERR_LOCAL_WRITE_FAILED>,
C<SFTP_ERR_REMOTE_BAD_PACKET_SEQUENCE>,
C<SFTP_ERR_REMOTE_BAD_PERMISSIONS>, C<SFTP_ERR_REMOTE_BAD_TIME>,
C<SFTP_ERR_REMOTE_BLOCK_TOO_SMALL>, C<SFTP_ERR_REMOTE_CLOSE_FAILED>,
C<SFTP_ERR_REMOTE_FSETSTAT_FAILED>, C<SFTP_ERR_REMOTE_FSTAT_FAILED>,
C<SFTP_ERR_REMOTE_LSTAT_FAILED>, C<SFTP_ERR_REMOTE_MKDIR_FAILED>,
C<SFTP_ERR_REMOTE_OPENDIR_FAILED>, C<SFTP_ERR_REMOTE_OPEN_FAILED>,
C<SFTP_ERR_REMOTE_READDIR_FAILED>, C<SFTP_ERR_REMOTE_READ_FAILED>,
C<SFTP_ERR_REMOTE_REALPATH_FAILED>, C<SFTP_ERR_REMOTE_REMOVE_FAILED>,
C<SFTP_ERR_REMOTE_RENAME_FAILED>, C<SFTP_ERR_REMOTE_RMDIR_FAILED>,
C<SFTP_ERR_REMOTE_READLINK_FAILED>, C<SFTP_ERR_REMOTE_SYMLINK_FAILED>,
C<SFTP_ERR_REMOTE_SETSTAT_FAILED>, C<SFTP_ERR_REMOTE_STAT_FAILED>,
C<SFTP_ERR_REMOTE_WRITE_FAILED> and
C<SFTP_ERR_REMOTE_HARDLINK_FAILED>.

Note: these constants are not defined on the SFTP draft.

=item :ext

Import all the C<SSH2_FXE_*> constants: there are the constants
defined for usage with SFTP extensions.

Currently, these are supported: C<SSH2_FXE_STATVFS_ST_RDONLY>,
C<SSH_FXE_STATVFS_ST_NOSUID>.

=back

There is one constant that does not fit into any of the
tag sets: C<SSH2_FILEXFER_VERSION>, which holds the value
of the SFTP protocol implemented by L<Net::SFTP::Foreign>.

=head1 AUTHOR & COPYRIGHTS

Please see the L<Net::SFTP::Foreign> manpage for author, copyright,
and license information.

=cut
SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Helpers.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Helpers;

our $VERSION = '1.74_06';

use strict;
use warnings;
use Carp qw(croak carp);

our @CARP_NOT = qw(Net::SFTP::Foreign);

use Scalar::Util qw(tainted);

require Exporter;
our @ISA = qw(Exporter);
our @EXPORT = qw( _sort_entries
		  _gen_wanted
		  _ensure_list
                  _catch_tainted_args
                  _debug
                  _gen_converter
		  _hexdump
		  $debug
                );
our @EXPORT_OK = qw( _is_lnk
                     _is_dir
                     _is_reg
                     _do_nothing
		     _glob_to_regex
                     _file_part
                     _umask_save_and_set
                     _tcroak );

our $debug;

BEGIN {
    eval "use Time::HiRes 'time'"
	if ($debug and $debug & 256)
}

sub _debug {
    local ($\, $!);
    my $caller = '';
    if ( $debug & 8192) {
	$caller = (caller 1)[3];
	$caller =~ s/[\w:]*:://;
	$caller .= ': ';
    }
    if ($debug & 256) {
	my $ts = sprintf("%010.5f", time);
        print STDERR "#$$ $ts $caller", @_,"\n"
    }
    else {
        print STDERR "# $caller", @_,"\n"
    }
}

sub _hexdump {
    local ($\, $!);
    no warnings qw(uninitialized);
    my $data = shift;
    while ($data =~ /(.{1,32})/smg) {
        my $line=$1;
        my @c= (( map { sprintf "%02x",$_ } unpack('C*', $line)),
                (("  ") x 32))[0..31];
        $line=~s/(.)/ my $c=$1; unpack("c",$c)>=32 ? $c : '.' /egms;
	local $\;
        print STDERR join(" ", @c, '|', $line), "\n";
    }
}

sub _do_nothing {}

{
    my $has_sk;
    sub _has_sk {
	unless (defined $has_sk) {
            local $@;
            local $SIG{__DIE__};
	    eval { require Sort::Key };
	    $has_sk = ($@ eq '');
	}
	return $has_sk;
    }
}

sub _sort_entries {
    my $e = shift;
    if (_has_sk) {
	&Sort::Key::keysort_inplace(sub { $_->{filename} }, $e);
    }
    else {
	@$e = sort { $a->{filename} cmp $b->{filename} } @$e;
    }
}

sub _gen_wanted {
    my ($ow, $onw) = my ($w, $nw) = @_;
    if (ref $w eq 'Regexp') {
	$w = sub { $_[1]->{filename} =~ $ow }
    }

    if (ref $nw eq 'Regexp') {
	$nw = sub { $_[1]->{filename} !~ $onw }
    }
    elsif (defined $nw) {
	$nw = sub { !&$onw };
    }

    if (defined $w and defined $nw) {
	return sub { &$nw and &$w }
    }

    return $w || $nw;
}

sub _ensure_list {
    my $l = shift;
    return () unless defined $l;
    local $@;
    local $SIG{__DIE__};
    local $SIG{__WARN__};
    no warnings;
    (eval { @$l; 1 } ? @$l : $l);
}

sub _glob_to_regex {
    my ($glob, $strict_leading_dot, $ignore_case) = @_;

    my ($regex, $in_curlies, $escaping);
    my $wildcards = 0;

    my $first_byte = 1;
    while ($glob =~ /\G(.)/g) {
	my $char = $1;
	# print "char: $char\n";
	if ($char eq '\\') {
	    $escaping = 1;
	}
	else {
	    if ($first_byte) {
		if ($strict_leading_dot) {
		    $regex .= '(?=[^\.])' unless $char eq '.';
		}
		$first_byte = 0;
	    }
	    if ($char eq '/') {
		$first_byte = 1;
	    }
	    if ($escaping) {
		$regex .= quotemeta $char;
	    }
	    else {
                $wildcards++;
		if ($char eq '*') {
		    $regex .= ".*";
		}
		elsif ($char eq '?') {
		    $regex .= '.'
		}
		elsif ($char eq '{') {
		    $regex .= '(?:(?:';
		    ++$in_curlies;
		}
		elsif ($char eq '}') {
		    $regex .= "))";
		    --$in_curlies;
		    $in_curlies < 0
			and croak "invalid glob pattern";
		}
		elsif ($char eq ',' && $in_curlies) {
		    $regex .= ")|(?:";
		}
		elsif ($char eq '[') {
		    if ($glob =~ /\G((?:\\.|[^\]])+)\]/g) {
			$regex .= "[$1]"
		    }
		    else {
			croak "invalid glob pattern";
		    }
		}
		else {
                    $wildcards--;
		    $regex .= quotemeta $char;
		}
	    }

	    $escaping = 0;
	}
    }

    croak "invalid glob pattern" if $in_curlies;

    my $re = $ignore_case ? qr/^$regex$/i : qr/^$regex$/;
    wantarray ? ($re, ($wildcards > 0 ? 1 : undef)) : $re
}

sub _tcroak {
    if (${^TAINT} > 0) {
	push @_, " while running with -T switch";
        goto &croak;
    }
    if (${^TAINT} < 0) {
	push @_, " while running with -t switch";
        goto &carp;
    }
}

sub _catch_tainted_args {
    my $i;
    for (@_) {
        next unless $i++;
        if (tainted($_)) {
            my (undef, undef, undef, $subn) = caller 1;
            my $msg = ( $subn =~ /::([a-z]\w*)$/
                        ? "Insecure argument '$_' on '$1' method call"
                        : "Insecure argument '$_' on method call" );
            _tcroak($msg);
        }
        elsif (ref($_)) {
            for (grep tainted($_),
		 do { local ($@, $SIG{__DIE__}); eval { values %$_ }}) {
		my (undef, undef, undef, $subn) = caller 1;
		my $msg = ( $subn =~ /::([a-z]\w*)$/
			    ? "Insecure argument on '$1' method call"
			    : "Insecure argument on method call" );
		_tcroak($msg);
            }
        }
    }
}

sub _gen_dos2unix {
    my $unix2dos = shift;
    my $name = ($unix2dos ? 'unix2dos' : 'dos2unix');
    my $previous;
    my $done;
    sub {
        $done and die "Internal error: bad calling sequence for $name transformation";
        my $adjustment = 0;
        for (@_) {
            if ($debug and $debug & 128) {
                _debug ("before $name: previous: $previous, data follows...");
                _hexdump($_);
            }
            if (length) {
                if ($previous) {
                    $adjustment++;
                    $_ = "\x0d$_";
                }
                $adjustment -= $previous = s/\x0d\z//s;
                if ($unix2dos) {
                    $adjustment += s/(?<!\x0d)\x0a/\x0d\x0a/gs;
                }
                else {
                    $adjustment -= s/\x0d\x0a/\x0a/gs;
                }
            }
            elsif ($previous) {
                $previous = 0;
                $done = 1;
                $adjustment++;
                $_ = "\x0d";
            }
            if ($debug and $debug & 128) {
                _debug ("after $name: previous: $previous, adjustment: $adjustment, data follows...");
                _hexdump($_);
            }
            return $adjustment;
        }
    }
}

sub _gen_converter {
    my $conversion = shift;

    return undef unless defined $conversion;

    if (ref $conversion) {
        if (ref $conversion eq 'CODE') {
            return sub {
                my $before = length $_[0];
                $conversion->($_[0]);
                length($_[0]) - $before;
            }
        }
        else {
            croak "unsupported conversion argument"
        }
    }
    elsif ($conversion eq 'dos2unix') {
        return _gen_dos2unix(0);
    }
    elsif ($conversion eq 'unix2dos') {
        return _gen_dos2unix(1);
    }
    else {
        croak "unknown conversion '$conversion'";
    }
}

sub _is_lnk { (0120000 & shift) == 0120000 }
sub _is_dir { (0040000 & shift) == 0040000 }
sub _is_reg { (0100000 & shift) == 0100000 }

sub _file_part {
    my $path = shift;
    $path =~ m{([^/]*)$} or croak "unable to get file part from path '$path'";
    $1;
}

sub _umask_save_and_set {
    my $umask = shift;
    if (defined $umask) {
        my $old = umask $umask;
        return bless \$old, 'Net::SFTP::Foreign::Helpers::umask_saver';
    }
    ()
}

sub Net::SFTP::Foreign::Helpers::umask_saver::DESTROY { umask ${$_[0]} }

1;

SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Local.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Local;

our $VERSION = '1.57';

use strict;
use warnings;
use Carp;
use File::Spec;

use Net::SFTP::Foreign::Attributes;
use Net::SFTP::Foreign::Constants qw(:error);
use Net::SFTP::Foreign::Helpers qw(_sort_entries _gen_wanted _do_nothing);
require Net::SFTP::Foreign::Common;
our @ISA = qw(Net::SFTP::Foreign::Common);

sub new {
    my $class = shift;
    my $self = { status => 0,
		 error => 0 };
    bless $self, $class;
}

sub realpath {
    $! = 0;
    File::Spec->rel2abs($_[1])
}

sub stat {
    $! = 0;
    my $a = Net::SFTP::Foreign::Attributes->new_from_stat(CORE::stat($_[1]));
    unless ($a) {
	$_[0]->_set_error(SFTP_ERR_LOCAL_STAT_FAILED, "Couldn't stat local file '$_[1]'", $!);
    }
    $a
}

sub lstat {
    $! = 0;
    my $a = Net::SFTP::Foreign::Attributes->new_from_stat(CORE::lstat($_[1]));
    unless ($a) {
	$_[0]->_set_error(SFTP_ERR_LOCAL_STAT_FAILED, "Couldn't stat local file '$_[1]'", $!);
    }
    $a
}

sub readlink {
    $! = 0;
    my $target = readlink $_[1];
    unless (defined $target) {
	$_[0]->_set_error(SFTP_ERR_LOCAL_READLINK_FAILED, "Couldn't read link '$_[1]'", $!);
    }
    $target
}

sub join {
    shift;
    my $path = File::Spec->join(@_);
    $path = File::Spec->canonpath($path);
    # print 'lfs->join("'.join('", "', @_)."\") => $path\n";
    $path
}

sub ls {
    my ($self, $dir, %opts) = @_;

    my $ordered = delete $opts{ordered};
    my $follow_links = delete $opts{follow_links};
    my $atomic_readdir = delete $opts{atomic_readdir};

    my $wanted = delete $opts{_wanted} ||
	_gen_wanted(delete $opts{wanted},
		    delete $opts{no_wanted});

    %opts and croak "invalid option(s) '".CORE::join("', '", keys %opts)."'";

    $! = 0;

    opendir(my $ldh, $dir)
	or return undef;

    my @dir;
    while (defined(my $part = readdir $ldh)) {
	my $fn = File::Spec->join($dir, $part);
	my $a = $self->lstat($fn);
	if ($a and $follow_links and S_ISLNK($a->perm)) {
	    if (my $fa = $self->stat($fn)) {
		$a = $fa;
	    }
	    else {
		$! = 0;
	    }
	}
	my $entry = { filename => $part,
		      a => $a };
	if ($atomic_readdir or !$wanted or $wanted->($self, $entry)) {
	    push @dir, $entry;
	}
    }

    if ($atomic_readdir and $wanted) {
	@dir = grep { $wanted->($self, $_) } @dir;
    }

    _sort_entries(\@dir) if $ordered;

    return \@dir;
}

1;

__END__

=head1 NAME

Net::SFTP::Foreign::Local - access local file system through Net::SFTP::Foreign API.

=head1 SYNOPSIS

    my $localfs = Net::SFTP::Foreign::Local->new;
    my @find = $localfs->find('.', no_wanted => qr/(?:\/|^).svn/);

=head1 DESCRIPTION

This module is a partial implementation of the L<Net::SFTP::Foreign>
interface for the local filesystem.

The methods currently implemented are: C<stat>, C<lstat>, C<ls> and
C<find>.

=head1 COPYRIGHT

Copyright (c) 2006 Salvador FandiE<ntilde>o.

All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.

=cut

SFTPMODULE
;
    close FILE;
    mkdir "$dir/Net/SFTP/Foreign/Backend";
    open(FILE, ">$dir/Net/SFTP/Foreign/Backend/Unix.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Backend::Unix;

our $VERSION = '1.76_03';

use strict;
use warnings;

use Carp;
our @CARP_NOT = qw(Net::SFTP::Foreign);

use Fcntl qw(O_NONBLOCK F_SETFL F_GETFL);
use POSIX ();
use Net::SFTP::Foreign::Helpers qw(_tcroak _ensure_list _debug _hexdump $debug);
use Net::SFTP::Foreign::Constants qw(SSH2_FX_BAD_MESSAGE
				     SFTP_ERR_REMOTE_BAD_MESSAGE);
use Time::HiRes qw(sleep time);

sub _new { shift }

sub _defaults {
   ( queue_size => 32 )
}

sub _init_transport_streams {
    my (undef, $sftp) = @_;
    for my $dir (qw(ssh_in ssh_out)) {
	binmode $sftp->{$dir};
	my $flags = fcntl($sftp->{$dir}, F_GETFL, 0);
	fcntl($sftp->{$dir}, F_SETFL, $flags | O_NONBLOCK);
    }
}

sub _open_dev_null {
    my $sftp = shift;
    my $dev_null;
    unless (open $dev_null, '>', "/dev/null") {
	$sftp->_conn_failed("Unable to redirect stderr to /dev/null");
	return;
    }
    $dev_null
}

sub _fileno_dup_over {
    my ($good_fn, $fh) = @_;
    if (defined $fh) {
        my @keep_open;
        my $fn = fileno $fh;
        for (1..5) {
            $fn >= $good_fn and return $fn;
            $fn = POSIX::dup($fn);
            push @keep_open, $fn;
        }
        POSIX::_exit(255);
    }
    undef;
}

sub _open4 {
    my $backend = shift;
    my $sftp = shift;
    my ($dad_in, $dad_out, $child_in, $child_out);
    unless (pipe ($dad_in, $child_out) and
            pipe ($child_in, $dad_out)) {
        $sftp->_conn_failed("Unable to created pipes: $!");
        return;
    }
    my $pid = fork;
    unless ($pid) {
        unless (defined $pid) {
            $sftp->_conn_failed("Unable to fork new process: $!");
            return;
        }
        close ($dad_in);
        close ($dad_out);

        shift; shift;
        my $child_err = shift;
        my $pty = shift;

        $pty->make_slave_controlling_terminal if defined $pty;

        my $child_err_fno = eval { no warnings; fileno($child_err  ? $child_err : *STDERR) };
        my $child_err_safe; # passed handler may be tied, so we
                            # duplicate it in order to get a plain OS
                            # handler.
        if (defined $child_err_fno and $child_err_fno >= 0) {
            open $child_err_safe, ">&=$child_err_fno" or POSIX::_exit(1);
        }
        else {
            open $child_err_safe, ">/dev/null" or POSIX::_exit(1);
        }

        my $child_in_fno       = _fileno_dup_over(0 => $child_in      );
        my $child_out_fno      = _fileno_dup_over(1 => $child_out     );
        my $child_err_safe_fno = _fileno_dup_over(2 => $child_err_safe);

        unless (($child_in_fno       == 0 or POSIX::dup2($child_in_fno,       0)) and
                ($child_out_fno      == 1 or POSIX::dup2($child_out_fno,      1)) and
                ($child_err_safe_fno == 2 or POSIX::dup2($child_err_safe_fno, 2))) {
            POSIX::_exit(1);
        }
        do { exec @_ };
        POSIX::_exit(1);
    }
    close $child_in;
    close $child_out;

    $_[0] = $dad_in;
    $_[1] = $dad_out;
    $pid;
}

sub _init_transport {
    my ($backend, $sftp, $opts) = @_;

    my $transport = delete $opts->{transport};

    if (defined $transport) {
	if (ref $transport eq 'ARRAY') {
            @{$sftp}{qw(ssh_in ssh_out pid)} = @$transport;
        }
        else {
            $sftp->{ssh_in} = $sftp->{ssh_out} = $transport;
            $sftp->{_ssh_out_is_not_dupped} = 1;
        }
    }
    else {
        my $user = delete $opts->{user};
        my $pass = delete $opts->{passphrase};
        my $ask_for_username_at_login;
	my $pass_is_passphrase;
        my $password_prompt;
        if (defined $pass) {
            $pass_is_passphrase = 1;
        }
        else {
            $pass = delete $opts->{password};
	    if (defined $pass) {
                $sftp->{_password_authentication} = 1;
                $password_prompt = $sftp->{_password_prompt} = delete $opts->{password_prompt};
                if (defined $password_prompt) {
                    unless (ref $password_prompt eq 'Regexp') {
                        $password_prompt = quotemeta $password_prompt;
                        $password_prompt = qr/$password_prompt\s*$/i;
                    }
                }
                $ask_for_username_at_login =
                    $sftp->{_ask_for_username_at_login} =
                        ( delete($opts->{ask_for_username_at_login}) ||
                          delete($opts->{asks_for_username_at_login}) );
                if ($ask_for_username_at_login) {
                    croak "ask_for_username_at_login set but user was not given" unless defined $user;
                    croak "ask_for_username_at_login can not be used with a custom password prompt"
                        if defined $password_prompt;
                }
            }
        }

        delete $opts->{expect_log_user}; # backward compatibility, not used anymore
	my $stderr_discard = delete $opts->{stderr_discard};
	my $stderr_fh = ($stderr_discard ? undef : delete $opts->{stderr_fh});
        my $open2_cmd = delete $opts->{open2_cmd};
        my $ssh_cmd_interface = delete $opts->{ssh_cmd_interface};

	my @open2_cmd;
        if (defined $open2_cmd) {
            @open2_cmd = _ensure_list($open2_cmd);
        }
        else {
            my $host = delete $opts->{host};
            defined $host or croak "sftp target host not defined";

            my $key_path = delete $opts->{key_path};

            my $ssh_cmd = delete $opts->{ssh_cmd};
            $ssh_cmd = 'ssh' unless defined $ssh_cmd;
            @open2_cmd = _ensure_list $ssh_cmd;

            unless (defined $ssh_cmd_interface) {
                $ssh_cmd_interface = ( "@open2_cmd" =~ /\bplink\b/i ? 'plink'  :
                                       "@open2_cmd" =~ /\bsshg3\b/i ? 'tectia' :
                                                                      'ssh'    );
            }

            my $port = delete $opts->{port};
	    my $ssh1 = delete $opts->{ssh1};

            my $more = delete $opts->{more};
            defined $more and !ref($more) and $more =~ /^-\w\s+\S/ and
                warnings::warnif("Net::SFTP::Foreign", "'more' argument looks like it should be split first");
            my @more = _ensure_list $more;

            my @preferred_authentications;
            if (defined $key_path) {
                push @preferred_authentications, 'publickey';
                push @open2_cmd, map { -i => $_ } _ensure_list $key_path;
            }

            if ($ssh_cmd_interface eq 'plink') {
                push @open2_cmd, -P => $port if defined $port;
                if (defined $pass and !$pass_is_passphrase) {
                    warnings::warnif("Net::SFTP::Foreign", "using insecure password authentication with plink");
                    push @open2_cmd, -pw => $pass;
                    undef $pass;
                }

            }
            elsif ($ssh_cmd_interface eq 'ssh') {
                push @open2_cmd, -p => $port if defined $port;
		if (defined $pass and !$pass_is_passphrase) {
		    push @open2_cmd, -o => 'NumberOfPasswordPrompts=1';
                    push @preferred_authentications, ('keyboard-interactive', 'password');
		}
                if (@preferred_authentications
                    and not grep { $more[$_] eq '-o' and
                                       $more[$_ + 1] =~ /^PreferredAuthentications\W/ } 0..$#more-1) {
                    push @open2_cmd, -o => 'PreferredAuthentications=' . join(',', @preferred_authentications);
                }
            }
            elsif ($ssh_cmd_interface eq 'tectia') {
            }
            else {
                die "Unsupported ssh_cmd_interface '$ssh_cmd_interface'";
            }

            push @open2_cmd, -l => $user if defined $user;
            push @open2_cmd, @more;
            push @open2_cmd, $host;
	    push @open2_cmd, ($ssh1 ? "/usr/lib/sftp-server" : -s => 'sftp');
        }

        my $redirect_stderr_to_tty = ( defined $pass and
                                       ( delete $opts->{redirect_stderr_to_tty} or $ssh_cmd_interface eq 'tectia' ) );

        $redirect_stderr_to_tty and ($stderr_discard or $stderr_fh)
            and croak "stderr_discard or stderr_fh can not be used together with password/passphrase "
                          . "authentication when Tectia client is used";

	$debug and $debug & 1 and _debug "ssh cmd: @open2_cmd\n";

	%$opts and return; # Net::SFTP::Foreign will find the
                           # unhandled options and croak

	if (${^TAINT} and Scalar::Util::tainted($ENV{PATH})) {
            _tcroak('Insecure $ENV{PATH}')
        }

	if ($stderr_discard) {
	    $stderr_fh = $backend->_open_dev_null($sftp) or return;
	}

        if (defined $pass) {
            # user has requested to use a password or a passphrase for
            # authentication we use IO::Pty to handle that

            eval { require IO::Pty; 1 }
                or croak "password authentication not available, IO::Pty is not installed or failed to load: $@";

            local ($ENV{SSH_ASKPASS}, $ENV{SSH_AUTH_SOCK}) if $pass_is_passphrase;

            my $name = $pass_is_passphrase ? 'Passphrase' : 'Password';

	    my $child;
            my $pty = IO::Pty->new;

            $redirect_stderr_to_tty and $stderr_fh = $pty->slave;

            $child = $backend->_open4($sftp, $sftp->{ssh_in}, $sftp->{ssh_out}, $stderr_fh, $pty, @open2_cmd);
            unless (defined $child) {
                $sftp->_conn_failed("Bad ssh command", $!);
                return;
            }
            $sftp->{pid} = $child;
            open my $pty_dup, '+>&', $pty; # store pty as a file handler instead of a object in
                                           # order to save it from being destroyed too early
                                           # during global destruction
            $sftp->{_pty} = $pty_dup;

            $debug and $debug & 65536 and _debug "starting password authentication";
            my $rv = '';
            vec($rv, fileno($pty), 1) = 1;
            my $buffer = '';
            my $at = 0;
            my $password_sent;
            my $start_time = time;
            while(1) {
                if (defined $sftp->{_timeout}) {
                    $debug and $debug & 65536 and _debug "checking timeout, max: $sftp->{_timeout}, ellapsed: " . (time - $start_time);
                    if (time - $start_time > $sftp->{_timeout}) {
                        $sftp->_conn_failed("login procedure timed out");
                        return;
                    }
                }

                if (waitpid($child, POSIX::WNOHANG()) > 0) {
                    undef $sftp->{pid};
                    my $err = $? >> 8;
                    $sftp->_conn_failed("SSH slave exited unexpectedly with error code $err");
                    return;
                }

                $debug and $debug & 65536 and _debug "waiting for data from the pty to become available";

                my $rv1 = $rv;
                select($rv1, undef, undef, 1) > 0 or next;
                if (my $bytes = sysread($pty, $buffer, 4096, length $buffer)) {
                    if ($debug and $debug & 65536) {
                        _debug "$bytes bytes readed from pty:";
                        _hexdump substr($buffer, -$bytes);
                    }
                    if ($buffer =~ /^The authenticity of host/mi or
                        $buffer =~ /^Warning: the \S+ host key for/mi) {
                        $sftp->_conn_failed("the authenticity of the target host can't be established, " .
                                            "the remote host public key is probably not present on the " .
                                            "'~/.ssh/known_hosts' file");
                        return;
                    }
                    if ($password_sent) {
                        $debug and $debug & 65536 and _debug "looking for password ok";
                        last if substr($buffer, $at) =~ /\n$/;
                    }
                    else {
                        $debug and $debug & 65536 and _debug "looking for user/password prompt";
                        my $re = ( defined $password_prompt
                                   ? $password_prompt
                                   : qr/(user|name|login)?[:?]\s*$/i );

                        $debug and $debug & 65536 and _debug "matching against $re";

                        if (substr($buffer, $at) =~ $re) {
                            if ($ask_for_username_at_login and
                                ($ask_for_username_at_login ne 'auto' or defined $1)) {
                                $debug and $debug & 65536 and _debug "sending username";
                                print $pty "$user\n";
                                undef $ask_for_username_at_login;
                            }
                            else {
                                $debug and $debug & 65536 and _debug "sending password";
                                print $pty "$pass\n";
                                $password_sent = 1;
                            }
                            $at = length $buffer;
                        }
                    }
                }
                else {
                    $debug and $debug & 65536 and _debug "no data available from pty, delaying until next read";
                    sleep 0.1;
                }

            }
            $debug and $debug & 65536 and _debug "password authentication done";
	    $pty->close_slave();
        }
        else {
	    $sftp->{pid} = $backend->_open4($sftp, $sftp->{ssh_in}, $sftp->{ssh_out}, $stderr_fh, undef, @open2_cmd);
            unless (defined $sftp->{pid}) {
                $sftp->_conn_failed("Bad ssh command", $!);
                return;
            }
        }
    }
    $backend->_init_transport_streams($sftp);
}

sub _after_init {
    my ($backend, $sftp) = @_;
    if ($sftp->{pid} and not $sftp->error) {
        # do not propagate signals sent from the terminal to the
        # slave SSH:
        local ($@, $!);
        eval { setpgrp($sftp->{pid}, 0) };
    }
}

sub _do_io {
    my (undef, $sftp, $timeout) = @_;

    $debug and $debug & 32 and _debug(sprintf "_do_io connected: %s", $sftp->{_connected} || 0);

    return undef unless $sftp->{_connected};

    my $fnoout = fileno $sftp->{ssh_out};
    my $fnoin = fileno $sftp->{ssh_in};
    my ($rv, $wv) = ('', '');
    vec($rv, $fnoin, 1) = 1;
    vec($wv, $fnoout, 1) = 1;

    my $bin = \$sftp->{_bin};
    my $bout = \$sftp->{_bout};

    local $SIG{PIPE} = 'IGNORE';

    my $len;
    while (1) {
        my $lbin = length $$bin;
	if (defined $len) {
            return 1 if $lbin >= $len;
	}
	elsif ($lbin >= 4) {
            $len = 4 + unpack N => $$bin;
            if ($len > 256 * 1024) {
                $sftp->_set_status(SSH2_FX_BAD_MESSAGE);
                $sftp->_set_error(SFTP_ERR_REMOTE_BAD_MESSAGE,
                                  "bad remote message received");
                return undef;
            }
            return 1 if $lbin >= $len;
        }

        my $rv1 = $rv;
        my $wv1 = length($$bout) ? $wv : '';

        $debug and $debug & 32 and _debug("_do_io select(-,-,-, ". (defined $timeout ? $timeout : 'undef') .")");

        my $n = select($rv1, $wv1, undef, $timeout);
        if ($n > 0) {
            if (vec($wv1, $fnoout, 1)) {
                my $written = syswrite($sftp->{ssh_out}, $$bout, 64 * 1024);
                if ($debug and $debug & 32) {
		    _debug (sprintf "_do_io write queue: %d, syswrite: %s, max: %d, \$!: %s",
			    length $$bout,
			    (defined $written ? $written : 'undef'),
			    64 * 1024, $!);
		    $debug & 2048 and $written and _hexdump(substr($$bout, 0, $written));
		}
                if ($written) {
                    substr($$bout, 0, $written, '');
                }
                elsif ($! != Errno::EAGAIN() and $! != Errno::EINTR()) {
                    $sftp->_conn_lost;
                    return undef;
                }
            }
            if (vec($rv1, $fnoin, 1)) {
                my $read = sysread($sftp->{ssh_in}, $$bin, 64 * 1024, length($$bin));
                if ($debug and $debug & 32) {
		    _debug (sprintf "_do_io read sysread: %s, total read: %d, \$!: %s",
			    (defined $read ? $read : 'undef'),
			    length $$bin,
			    $!);
		    $debug & 1024 and $read and _hexdump(substr($$bin, -$read));
		}
                if (!$read and $! != Errno::EAGAIN() and $! != Errno::EINTR()) {
                    $sftp->_conn_lost;
                    return undef;
                }
            }
        }
        else {
            $debug and $debug & 32 and _debug "_do_io select failed: $!";
            next if ($n < 0 and ($! == Errno::EINTR() or $! == Errno::EAGAIN()));
            return undef;
        }
    }
}

1;
SFTPMODULE
;
    close FILE;
    open(FILE, ">$dir/Net/SFTP/Foreign/Backend/Windows.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Backend::Windows;

our $VERSION = '1.70_08';

use strict;
use warnings;

use Carp;
our @CARP_NOT = qw(Net::SFTP::Foreign);

use IPC::Open3;
use POSIX ();
use Net::SFTP::Foreign::Helpers;
use Net::SFTP::Foreign::Constants qw(SSH2_FX_BAD_MESSAGE
				     SFTP_ERR_REMOTE_BAD_MESSAGE);

require Net::SFTP::Foreign::Backend::Unix;
our @ISA = qw(Net::SFTP::Foreign::Backend::Unix);

sub _defaults {
    ( queue_size => 16 )
}

sub _init_transport_streams {
    my ($backend, $sftp) = @_;
    binmode $sftp->{ssh_in};
    binmode $sftp->{ssh_out};
}

sub _open_dev_null {
    my $sftp = shift;
    my $dev_null;
    unless (open $dev_null, '>', 'NUL:') {
	$sftp->_conn_failed("Unable to redirect stderr for slave SSH process to NUL: $!");
	return;
    }
    $dev_null
}

sub _open4 {
    my $backend = shift;
    my $sftp = shift;

    defined $_[3] and croak "setting child PTY is not supported on Windows";

    my $fno = eval { defined $_[2] ? fileno $_[2] : fileno *STDERR };
    unless (defined $fno and $fno >= 0) {
        $sftp->_conn_failed("STDERR or stderr_fh is not a real file handle: " . (length $@ ? $@ : $!));
        return;
    }

    local *SSHERR;
    unless (open(SSHERR, ">>&=", $fno)) {
        $sftp->_conn_failed("Unable to duplicate stderr redirection file handle: $!");
        return undef;
    }

    goto NOTIE unless tied *STDERR;
    local *STDERR;
    unless (open STDERR, ">&=2") {
        $sftp->_conn_failed("Unable to reattach STDERR to fd 2: $!");
        return;
    }
 NOTIE:
    local ($@, $SIG{__DIE__}, $SIG{__WARN__});

    my $ppid = $$;
    my $pid = eval { open3(@_[1,0], ">&SSHERR", @_[4..$#_]) };
    $ppid == $$ or POSIX::_exit(-1);
    $pid;
}

sub _after_init {}

sub _sysreadn {
    my ($sftp, $n) = @_;
    my $bin = \$sftp->{_bin};
    while (1) {
	my $len = length $$bin;
	return 1 if $len >= $n;
	my $read = sysread($sftp->{ssh_in}, $$bin, $n - $len, $len);
	unless ($read) {
	    $sftp->_conn_lost;
	    return undef;
	}
    }
    return $n;
}

sub _do_io {
    my ($backend, $sftp, $timeout) = @_;

    return undef unless $sftp->{_connected};

    my $bin = \$sftp->{_bin};
    my $bout = \$sftp->{_bout};

    while (length $$bout) {
	my $written = syswrite($sftp->{ssh_out}, $$bout, 20480);
	unless ($written) {
	    $sftp->_conn_lost;
	    return undef;
	}
	substr($$bout, 0, $written, "");
    }

    defined $timeout and $timeout <= 0 and return;

    _sysreadn($sftp, 4) or return undef;

    my $len = 4 + unpack N => $$bin;
    if ($len > 256 * 1024) {
        $sftp->_set_status(SSH2_FX_BAD_MESSAGE);
        $sftp->_set_error(SFTP_ERR_REMOTE_BAD_MESSAGE,
                          "bad remote message received");
        return undef;
    }
    _sysreadn($sftp, $len);
}

1;
SFTPMODULE
;
    close FILE;
    mkdir "$dir/Net/SFTP/Foreign/Attributes";
    open(FILE, ">$dir/Net/SFTP/Foreign/Attributes/Compat.pm");
    print FILE <<'SFTPMODULE'
package Net::SFTP::Foreign::Attributes::Compat;

our $VERSION = '0.01';

use strict;
use warnings;

use Net::SFTP::Foreign::Attributes;
our @ISA = qw(Net::SFTP::Foreign::Attributes);

my @fields = qw( flags size uid gid perm atime mtime );

for my $f (@fields) {
    no strict 'refs';
    *$f = sub { @_ > 1 ? $_[0]->{$f} = $_[1] : $_[0]->{$f} || 0 }
}

sub new {
    my ($class, %param) = @_;

    my $a = $class->SUPER::new();

    if (my $stat = $param{Stat}) {
	$a->set_size($stat->[7]);
	$a->set_ugid($stat->[4], $stat->[5]);
	$a->set_perm($stat->[2]);
	$a->set_amtime($stat->[8], $stat->[9]);
    }
    $a;
}

1;
__END__

=head1 NAME

Net::SFTP::Foreign::Attributes::Compat - adapter for Net::SFTP::Attributes compatibility

=head1 SYNOPSIS

    use Net::SFTP::Foreign::Attributes::Compat;
    my $attrs = Net::SFTP::Foreign::Attributes->new(Stat => [ stat "foo" ]);
    my $size = $attrs->size;

=head1 DESCRIPTION

This module provides a wrapper for L<Net::SFTP::Foreign::Attributes>
exposing an API compatible to L<Net::SFTP::Attributes>.

=head1 AUTHOR & COPYRIGHTS

Please see the Net::SFTP::Foreign manpage for author, copyright, and
license information.

=cut
SFTPMODULE
;
    close FILE;
    push(@INC, $dir);
    require Net::SFTP::Foreign;
}
